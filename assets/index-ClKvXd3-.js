(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))n(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&n(i)}).observe(document,{childList:!0,subtree:!0});function a(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerPolicy&&(s.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?s.credentials="include":r.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(r){if(r.ep)return;r.ep=!0;const s=a(r);fetch(r.href,s)}})();var Z0={exports:{}},xf={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var dC;function pU(){if(dC)return xf;dC=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function a(n,r,s){var i=null;if(s!==void 0&&(i=""+s),r.key!==void 0&&(i=""+r.key),"key"in r){s={};for(var o in r)o!=="key"&&(s[o]=r[o])}else s=r;return r=s.ref,{$$typeof:e,type:n,key:i,ref:r!==void 0?r:null,props:s}}return xf.Fragment=t,xf.jsx=a,xf.jsxs=a,xf}var hC;function fU(){return hC||(hC=1,Z0.exports=pU()),Z0.exports}var it=fU(),Q0={exports:{}},ft={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var pC;function mU(){if(pC)return ft;pC=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),a=Symbol.for("react.fragment"),n=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),s=Symbol.for("react.consumer"),i=Symbol.for("react.context"),o=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),c=Symbol.for("react.lazy"),f=Symbol.iterator;function m(L){return L===null||typeof L!="object"?null:(L=f&&L[f]||L["@@iterator"],typeof L=="function"?L:null)}var g={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},b=Object.assign,v={};function x(L,q,le){this.props=L,this.context=q,this.refs=v,this.updater=le||g}x.prototype.isReactComponent={},x.prototype.setState=function(L,q){if(typeof L!="object"&&typeof L!="function"&&L!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,L,q,"setState")},x.prototype.forceUpdate=function(L){this.updater.enqueueForceUpdate(this,L,"forceUpdate")};function k(){}k.prototype=x.prototype;function S(L,q,le){this.props=L,this.context=q,this.refs=v,this.updater=le||g}var N=S.prototype=new k;N.constructor=S,b(N,x.prototype),N.isPureReactComponent=!0;var T=Array.isArray,_={H:null,A:null,T:null,S:null,V:null},R=Object.prototype.hasOwnProperty;function M(L,q,le,se,pe,ve){return le=ve.ref,{$$typeof:e,type:L,key:q,ref:le!==void 0?le:null,props:ve}}function F(L,q){return M(L.type,q,void 0,void 0,void 0,L.props)}function B(L){return typeof L=="object"&&L!==null&&L.$$typeof===e}function V(L){var q={"=":"=0",":":"=2"};return"$"+L.replace(/[=:]/g,function(le){return q[le]})}var P=/\/+/g;function A(L,q){return typeof L=="object"&&L!==null&&L.key!=null?V(""+L.key):q.toString(36)}function G(){}function J(L){switch(L.status){case"fulfilled":return L.value;case"rejected":throw L.reason;default:switch(typeof L.status=="string"?L.then(G,G):(L.status="pending",L.then(function(q){L.status==="pending"&&(L.status="fulfilled",L.value=q)},function(q){L.status==="pending"&&(L.status="rejected",L.reason=q)})),L.status){case"fulfilled":return L.value;case"rejected":throw L.reason}}throw L}function ee(L,q,le,se,pe){var ve=typeof L;(ve==="undefined"||ve==="boolean")&&(L=null);var Ie=!1;if(L===null)Ie=!0;else switch(ve){case"bigint":case"string":case"number":Ie=!0;break;case"object":switch(L.$$typeof){case e:case t:Ie=!0;break;case c:return Ie=L._init,ee(Ie(L._payload),q,le,se,pe)}}if(Ie)return pe=pe(L),Ie=se===""?"."+A(L,0):se,T(pe)?(le="",Ie!=null&&(le=Ie.replace(P,"$&/")+"/"),ee(pe,q,le,"",function(Le){return Le})):pe!=null&&(B(pe)&&(pe=F(pe,le+(pe.key==null||L&&L.key===pe.key?"":(""+pe.key).replace(P,"$&/")+"/")+Ie)),q.push(pe)),1;Ie=0;var Re=se===""?".":se+":";if(T(L))for(var Ne=0;Ne<L.length;Ne++)se=L[Ne],ve=Re+A(se,Ne),Ie+=ee(se,q,le,ve,pe);else if(Ne=m(L),typeof Ne=="function")for(L=Ne.call(L),Ne=0;!(se=L.next()).done;)se=se.value,ve=Re+A(se,Ne++),Ie+=ee(se,q,le,ve,pe);else if(ve==="object"){if(typeof L.then=="function")return ee(J(L),q,le,se,pe);throw q=String(L),Error("Objects are not valid as a React child (found: "+(q==="[object Object]"?"object with keys {"+Object.keys(L).join(", ")+"}":q)+"). If you meant to render a collection of children, use an array instead.")}return Ie}function W(L,q,le){if(L==null)return L;var se=[],pe=0;return ee(L,se,"","",function(ve){return q.call(le,ve,pe++)}),se}function X(L){if(L._status===-1){var q=L._result;q=q(),q.then(function(le){(L._status===0||L._status===-1)&&(L._status=1,L._result=le)},function(le){(L._status===0||L._status===-1)&&(L._status=2,L._result=le)}),L._status===-1&&(L._status=0,L._result=q)}if(L._status===1)return L._result.default;throw L._result}var Q=typeof reportError=="function"?reportError:function(L){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var q=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof L=="object"&&L!==null&&typeof L.message=="string"?String(L.message):String(L),error:L});if(!window.dispatchEvent(q))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",L);return}console.error(L)};function ce(){}return ft.Children={map:W,forEach:function(L,q,le){W(L,function(){q.apply(this,arguments)},le)},count:function(L){var q=0;return W(L,function(){q++}),q},toArray:function(L){return W(L,function(q){return q})||[]},only:function(L){if(!B(L))throw Error("React.Children.only expected to receive a single React element child.");return L}},ft.Component=x,ft.Fragment=a,ft.Profiler=r,ft.PureComponent=S,ft.StrictMode=n,ft.Suspense=u,ft.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=_,ft.__COMPILER_RUNTIME={__proto__:null,c:function(L){return _.H.useMemoCache(L)}},ft.cache=function(L){return function(){return L.apply(null,arguments)}},ft.cloneElement=function(L,q,le){if(L==null)throw Error("The argument must be a React element, but you passed "+L+".");var se=b({},L.props),pe=L.key,ve=void 0;if(q!=null)for(Ie in q.ref!==void 0&&(ve=void 0),q.key!==void 0&&(pe=""+q.key),q)!R.call(q,Ie)||Ie==="key"||Ie==="__self"||Ie==="__source"||Ie==="ref"&&q.ref===void 0||(se[Ie]=q[Ie]);var Ie=arguments.length-2;if(Ie===1)se.children=le;else if(1<Ie){for(var Re=Array(Ie),Ne=0;Ne<Ie;Ne++)Re[Ne]=arguments[Ne+2];se.children=Re}return M(L.type,pe,void 0,void 0,ve,se)},ft.createContext=function(L){return L={$$typeof:i,_currentValue:L,_currentValue2:L,_threadCount:0,Provider:null,Consumer:null},L.Provider=L,L.Consumer={$$typeof:s,_context:L},L},ft.createElement=function(L,q,le){var se,pe={},ve=null;if(q!=null)for(se in q.key!==void 0&&(ve=""+q.key),q)R.call(q,se)&&se!=="key"&&se!=="__self"&&se!=="__source"&&(pe[se]=q[se]);var Ie=arguments.length-2;if(Ie===1)pe.children=le;else if(1<Ie){for(var Re=Array(Ie),Ne=0;Ne<Ie;Ne++)Re[Ne]=arguments[Ne+2];pe.children=Re}if(L&&L.defaultProps)for(se in Ie=L.defaultProps,Ie)pe[se]===void 0&&(pe[se]=Ie[se]);return M(L,ve,void 0,void 0,null,pe)},ft.createRef=function(){return{current:null}},ft.forwardRef=function(L){return{$$typeof:o,render:L}},ft.isValidElement=B,ft.lazy=function(L){return{$$typeof:c,_payload:{_status:-1,_result:L},_init:X}},ft.memo=function(L,q){return{$$typeof:d,type:L,compare:q===void 0?null:q}},ft.startTransition=function(L){var q=_.T,le={};_.T=le;try{var se=L(),pe=_.S;pe!==null&&pe(le,se),typeof se=="object"&&se!==null&&typeof se.then=="function"&&se.then(ce,Q)}catch(ve){Q(ve)}finally{_.T=q}},ft.unstable_useCacheRefresh=function(){return _.H.useCacheRefresh()},ft.use=function(L){return _.H.use(L)},ft.useActionState=function(L,q,le){return _.H.useActionState(L,q,le)},ft.useCallback=function(L,q){return _.H.useCallback(L,q)},ft.useContext=function(L){return _.H.useContext(L)},ft.useDebugValue=function(){},ft.useDeferredValue=function(L,q){return _.H.useDeferredValue(L,q)},ft.useEffect=function(L,q,le){var se=_.H;if(typeof le=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return se.useEffect(L,q)},ft.useId=function(){return _.H.useId()},ft.useImperativeHandle=function(L,q,le){return _.H.useImperativeHandle(L,q,le)},ft.useInsertionEffect=function(L,q){return _.H.useInsertionEffect(L,q)},ft.useLayoutEffect=function(L,q){return _.H.useLayoutEffect(L,q)},ft.useMemo=function(L,q){return _.H.useMemo(L,q)},ft.useOptimistic=function(L,q){return _.H.useOptimistic(L,q)},ft.useReducer=function(L,q,le){return _.H.useReducer(L,q,le)},ft.useRef=function(L){return _.H.useRef(L)},ft.useState=function(L){return _.H.useState(L)},ft.useSyncExternalStore=function(L,q,le){return _.H.useSyncExternalStore(L,q,le)},ft.useTransition=function(){return _.H.useTransition()},ft.version="19.1.0",ft}var fC;function A1(){return fC||(fC=1,Q0.exports=mU()),Q0.exports}var ga=A1(),J0={exports:{}},wf={},ew={exports:{}},tw={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var mC;function gU(){return mC||(mC=1,function(e){function t(W,X){var Q=W.length;W.push(X);e:for(;0<Q;){var ce=Q-1>>>1,L=W[ce];if(0<r(L,X))W[ce]=X,W[Q]=L,Q=ce;else break e}}function a(W){return W.length===0?null:W[0]}function n(W){if(W.length===0)return null;var X=W[0],Q=W.pop();if(Q!==X){W[0]=Q;e:for(var ce=0,L=W.length,q=L>>>1;ce<q;){var le=2*(ce+1)-1,se=W[le],pe=le+1,ve=W[pe];if(0>r(se,Q))pe<L&&0>r(ve,se)?(W[ce]=ve,W[pe]=Q,ce=pe):(W[ce]=se,W[le]=Q,ce=le);else if(pe<L&&0>r(ve,Q))W[ce]=ve,W[pe]=Q,ce=pe;else break e}}return X}function r(W,X){var Q=W.sortIndex-X.sortIndex;return Q!==0?Q:W.id-X.id}if(e.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var s=performance;e.unstable_now=function(){return s.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var u=[],d=[],c=1,f=null,m=3,g=!1,b=!1,v=!1,x=!1,k=typeof setTimeout=="function"?setTimeout:null,S=typeof clearTimeout=="function"?clearTimeout:null,N=typeof setImmediate<"u"?setImmediate:null;function T(W){for(var X=a(d);X!==null;){if(X.callback===null)n(d);else if(X.startTime<=W)n(d),X.sortIndex=X.expirationTime,t(u,X);else break;X=a(d)}}function _(W){if(v=!1,T(W),!b)if(a(u)!==null)b=!0,R||(R=!0,A());else{var X=a(d);X!==null&&ee(_,X.startTime-W)}}var R=!1,M=-1,F=5,B=-1;function V(){return x?!0:!(e.unstable_now()-B<F)}function P(){if(x=!1,R){var W=e.unstable_now();B=W;var X=!0;try{e:{b=!1,v&&(v=!1,S(M),M=-1),g=!0;var Q=m;try{t:{for(T(W),f=a(u);f!==null&&!(f.expirationTime>W&&V());){var ce=f.callback;if(typeof ce=="function"){f.callback=null,m=f.priorityLevel;var L=ce(f.expirationTime<=W);if(W=e.unstable_now(),typeof L=="function"){f.callback=L,T(W),X=!0;break t}f===a(u)&&n(u),T(W)}else n(u);f=a(u)}if(f!==null)X=!0;else{var q=a(d);q!==null&&ee(_,q.startTime-W),X=!1}}break e}finally{f=null,m=Q,g=!1}X=void 0}}finally{X?A():R=!1}}}var A;if(typeof N=="function")A=function(){N(P)};else if(typeof MessageChannel<"u"){var G=new MessageChannel,J=G.port2;G.port1.onmessage=P,A=function(){J.postMessage(null)}}else A=function(){k(P,0)};function ee(W,X){M=k(function(){W(e.unstable_now())},X)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(W){W.callback=null},e.unstable_forceFrameRate=function(W){0>W||125<W?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):F=0<W?Math.floor(1e3/W):5},e.unstable_getCurrentPriorityLevel=function(){return m},e.unstable_next=function(W){switch(m){case 1:case 2:case 3:var X=3;break;default:X=m}var Q=m;m=X;try{return W()}finally{m=Q}},e.unstable_requestPaint=function(){x=!0},e.unstable_runWithPriority=function(W,X){switch(W){case 1:case 2:case 3:case 4:case 5:break;default:W=3}var Q=m;m=W;try{return X()}finally{m=Q}},e.unstable_scheduleCallback=function(W,X,Q){var ce=e.unstable_now();switch(typeof Q=="object"&&Q!==null?(Q=Q.delay,Q=typeof Q=="number"&&0<Q?ce+Q:ce):Q=ce,W){case 1:var L=-1;break;case 2:L=250;break;case 5:L=1073741823;break;case 4:L=1e4;break;default:L=5e3}return L=Q+L,W={id:c++,callback:X,priorityLevel:W,startTime:Q,expirationTime:L,sortIndex:-1},Q>ce?(W.sortIndex=Q,t(d,W),a(u)===null&&W===a(d)&&(v?(S(M),M=-1):v=!0,ee(_,Q-ce))):(W.sortIndex=L,t(u,W),b||g||(b=!0,R||(R=!0,A()))),W},e.unstable_shouldYield=V,e.unstable_wrapCallback=function(W){var X=m;return function(){var Q=m;m=X;try{return W.apply(this,arguments)}finally{m=Q}}}}(tw)),tw}var gC;function yU(){return gC||(gC=1,ew.exports=gU()),ew.exports}var aw={exports:{}},Sn={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var yC;function bU(){if(yC)return Sn;yC=1;var e=A1();function t(u){var d="https://react.dev/errors/"+u;if(1<arguments.length){d+="?args[]="+encodeURIComponent(arguments[1]);for(var c=2;c<arguments.length;c++)d+="&args[]="+encodeURIComponent(arguments[c])}return"Minified React error #"+u+"; visit "+d+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function a(){}var n={d:{f:a,r:function(){throw Error(t(522))},D:a,C:a,L:a,m:a,X:a,S:a,M:a},p:0,findDOMNode:null},r=Symbol.for("react.portal");function s(u,d,c){var f=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:r,key:f==null?null:""+f,children:u,containerInfo:d,implementation:c}}var i=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function o(u,d){if(u==="font")return"";if(typeof d=="string")return d==="use-credentials"?d:""}return Sn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=n,Sn.createPortal=function(u,d){var c=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!d||d.nodeType!==1&&d.nodeType!==9&&d.nodeType!==11)throw Error(t(299));return s(u,d,null,c)},Sn.flushSync=function(u){var d=i.T,c=n.p;try{if(i.T=null,n.p=2,u)return u()}finally{i.T=d,n.p=c,n.d.f()}},Sn.preconnect=function(u,d){typeof u=="string"&&(d?(d=d.crossOrigin,d=typeof d=="string"?d==="use-credentials"?d:"":void 0):d=null,n.d.C(u,d))},Sn.prefetchDNS=function(u){typeof u=="string"&&n.d.D(u)},Sn.preinit=function(u,d){if(typeof u=="string"&&d&&typeof d.as=="string"){var c=d.as,f=o(c,d.crossOrigin),m=typeof d.integrity=="string"?d.integrity:void 0,g=typeof d.fetchPriority=="string"?d.fetchPriority:void 0;c==="style"?n.d.S(u,typeof d.precedence=="string"?d.precedence:void 0,{crossOrigin:f,integrity:m,fetchPriority:g}):c==="script"&&n.d.X(u,{crossOrigin:f,integrity:m,fetchPriority:g,nonce:typeof d.nonce=="string"?d.nonce:void 0})}},Sn.preinitModule=function(u,d){if(typeof u=="string")if(typeof d=="object"&&d!==null){if(d.as==null||d.as==="script"){var c=o(d.as,d.crossOrigin);n.d.M(u,{crossOrigin:c,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0})}}else d==null&&n.d.M(u)},Sn.preload=function(u,d){if(typeof u=="string"&&typeof d=="object"&&d!==null&&typeof d.as=="string"){var c=d.as,f=o(c,d.crossOrigin);n.d.L(u,c,{crossOrigin:f,integrity:typeof d.integrity=="string"?d.integrity:void 0,nonce:typeof d.nonce=="string"?d.nonce:void 0,type:typeof d.type=="string"?d.type:void 0,fetchPriority:typeof d.fetchPriority=="string"?d.fetchPriority:void 0,referrerPolicy:typeof d.referrerPolicy=="string"?d.referrerPolicy:void 0,imageSrcSet:typeof d.imageSrcSet=="string"?d.imageSrcSet:void 0,imageSizes:typeof d.imageSizes=="string"?d.imageSizes:void 0,media:typeof d.media=="string"?d.media:void 0})}},Sn.preloadModule=function(u,d){if(typeof u=="string")if(d){var c=o(d.as,d.crossOrigin);n.d.m(u,{as:typeof d.as=="string"&&d.as!=="script"?d.as:void 0,crossOrigin:c,integrity:typeof d.integrity=="string"?d.integrity:void 0})}else n.d.m(u)},Sn.requestFormReset=function(u){n.d.r(u)},Sn.unstable_batchedUpdates=function(u,d){return u(d)},Sn.useFormState=function(u,d,c){return i.H.useFormState(u,d,c)},Sn.useFormStatus=function(){return i.H.useHostTransitionStatus()},Sn.version="19.1.0",Sn}var bC;function vU(){if(bC)return aw.exports;bC=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}return e(),aw.exports=bU(),aw.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var vC;function xU(){if(vC)return wf;vC=1;var e=yU(),t=A1(),a=vU();function n(l){var h="https://react.dev/errors/"+l;if(1<arguments.length){h+="?args[]="+encodeURIComponent(arguments[1]);for(var p=2;p<arguments.length;p++)h+="&args[]="+encodeURIComponent(arguments[p])}return"Minified React error #"+l+"; visit "+h+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function r(l){return!(!l||l.nodeType!==1&&l.nodeType!==9&&l.nodeType!==11)}function s(l){var h=l,p=l;if(l.alternate)for(;h.return;)h=h.return;else{l=h;do h=l,(h.flags&4098)!==0&&(p=h.return),l=h.return;while(l)}return h.tag===3?p:null}function i(l){if(l.tag===13){var h=l.memoizedState;if(h===null&&(l=l.alternate,l!==null&&(h=l.memoizedState)),h!==null)return h.dehydrated}return null}function o(l){if(s(l)!==l)throw Error(n(188))}function u(l){var h=l.alternate;if(!h){if(h=s(l),h===null)throw Error(n(188));return h!==l?null:l}for(var p=l,y=h;;){var w=p.return;if(w===null)break;var I=w.alternate;if(I===null){if(y=w.return,y!==null){p=y;continue}break}if(w.child===I.child){for(I=w.child;I;){if(I===p)return o(w),l;if(I===y)return o(w),h;I=I.sibling}throw Error(n(188))}if(p.return!==y.return)p=w,y=I;else{for(var $=!1,z=w.child;z;){if(z===p){$=!0,p=w,y=I;break}if(z===y){$=!0,y=w,p=I;break}z=z.sibling}if(!$){for(z=I.child;z;){if(z===p){$=!0,p=I,y=w;break}if(z===y){$=!0,y=I,p=w;break}z=z.sibling}if(!$)throw Error(n(189))}}if(p.alternate!==y)throw Error(n(190))}if(p.tag!==3)throw Error(n(188));return p.stateNode.current===p?l:h}function d(l){var h=l.tag;if(h===5||h===26||h===27||h===6)return l;for(l=l.child;l!==null;){if(h=d(l),h!==null)return h;l=l.sibling}return null}var c=Object.assign,f=Symbol.for("react.element"),m=Symbol.for("react.transitional.element"),g=Symbol.for("react.portal"),b=Symbol.for("react.fragment"),v=Symbol.for("react.strict_mode"),x=Symbol.for("react.profiler"),k=Symbol.for("react.provider"),S=Symbol.for("react.consumer"),N=Symbol.for("react.context"),T=Symbol.for("react.forward_ref"),_=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),M=Symbol.for("react.memo"),F=Symbol.for("react.lazy"),B=Symbol.for("react.activity"),V=Symbol.for("react.memo_cache_sentinel"),P=Symbol.iterator;function A(l){return l===null||typeof l!="object"?null:(l=P&&l[P]||l["@@iterator"],typeof l=="function"?l:null)}var G=Symbol.for("react.client.reference");function J(l){if(l==null)return null;if(typeof l=="function")return l.$$typeof===G?null:l.displayName||l.name||null;if(typeof l=="string")return l;switch(l){case b:return"Fragment";case x:return"Profiler";case v:return"StrictMode";case _:return"Suspense";case R:return"SuspenseList";case B:return"Activity"}if(typeof l=="object")switch(l.$$typeof){case g:return"Portal";case N:return(l.displayName||"Context")+".Provider";case S:return(l._context.displayName||"Context")+".Consumer";case T:var h=l.render;return l=l.displayName,l||(l=h.displayName||h.name||"",l=l!==""?"ForwardRef("+l+")":"ForwardRef"),l;case M:return h=l.displayName||null,h!==null?h:J(l.type)||"Memo";case F:h=l._payload,l=l._init;try{return J(l(h))}catch{}}return null}var ee=Array.isArray,W=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,X=a.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,Q={pending:!1,data:null,method:null,action:null},ce=[],L=-1;function q(l){return{current:l}}function le(l){0>L||(l.current=ce[L],ce[L]=null,L--)}function se(l,h){L++,ce[L]=l.current,l.current=h}var pe=q(null),ve=q(null),Ie=q(null),Re=q(null);function Ne(l,h){switch(se(Ie,h),se(ve,l),se(pe,null),h.nodeType){case 9:case 11:l=(l=h.documentElement)&&(l=l.namespaceURI)?B_(l):0;break;default:if(l=h.tagName,h=h.namespaceURI)h=B_(h),l=U_(h,l);else switch(l){case"svg":l=1;break;case"math":l=2;break;default:l=0}}le(pe),se(pe,l)}function Le(){le(pe),le(ve),le(Ie)}function je(l){l.memoizedState!==null&&se(Re,l);var h=pe.current,p=U_(h,l.type);h!==p&&(se(ve,l),se(pe,p))}function Je(l){ve.current===l&&(le(pe),le(ve)),Re.current===l&&(le(Re),mf._currentValue=Q)}var st=Object.prototype.hasOwnProperty,At=e.unstable_scheduleCallback,pt=e.unstable_cancelCallback,xt=e.unstable_shouldYield,tt=e.unstable_requestPaint,ot=e.unstable_now,Bt=e.unstable_getCurrentPriorityLevel,pn=e.unstable_ImmediatePriority,na=e.unstable_UserBlockingPriority,Fa=e.unstable_NormalPriority,Oa=e.unstable_LowPriority,nn=e.unstable_IdlePriority,Kn=e.log,wn=e.unstable_setDisableYieldValue,Na=null,$t=null;function ba(l){if(typeof Kn=="function"&&wn(l),$t&&typeof $t.setStrictMode=="function")try{$t.setStrictMode(Na,l)}catch{}}var va=Math.clz32?Math.clz32:Jo,Qo=Math.log,Xr=Math.LN2;function Jo(l){return l>>>=0,l===0?32:31-(Qo(l)/Xr|0)|0}var Fn=256,hr=4194304;function ra(l){var h=l&42;if(h!==0)return h;switch(l&-l){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return l&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return l&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return l}}function Ks(l,h,p){var y=l.pendingLanes;if(y===0)return 0;var w=0,I=l.suspendedLanes,$=l.pingedLanes;l=l.warmLanes;var z=y&134217727;return z!==0?(y=z&~I,y!==0?w=ra(y):($&=z,$!==0?w=ra($):p||(p=z&~l,p!==0&&(w=ra(p))))):(z=y&~I,z!==0?w=ra(z):$!==0?w=ra($):p||(p=y&~l,p!==0&&(w=ra(p)))),w===0?0:h!==0&&h!==w&&(h&I)===0&&(I=w&-w,p=h&-h,I>=p||I===32&&(p&4194048)!==0)?h:w}function ys(l,h){return(l.pendingLanes&~(l.suspendedLanes&~l.pingedLanes)&h)===0}function Oc(l,h){switch(l){case 1:case 2:case 4:case 8:case 64:return h+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return h+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function el(){var l=Fn;return Fn<<=1,(Fn&4194048)===0&&(Fn=256),l}function Er(){var l=hr;return hr<<=1,(hr&62914560)===0&&(hr=4194304),l}function bs(l){for(var h=[],p=0;31>p;p++)h.push(l);return h}function vs(l,h){l.pendingLanes|=h,h!==268435456&&(l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0)}function Xs(l,h,p,y,w,I){var $=l.pendingLanes;l.pendingLanes=p,l.suspendedLanes=0,l.pingedLanes=0,l.warmLanes=0,l.expiredLanes&=p,l.entangledLanes&=p,l.errorRecoveryDisabledLanes&=p,l.shellSuspendCounter=0;var z=l.entanglements,Y=l.expirationTimes,he=l.hiddenUpdates;for(p=$&~p;0<p;){var xe=31-va(p),Se=1<<xe;z[xe]=0,Y[xe]=-1;var fe=he[xe];if(fe!==null)for(he[xe]=null,xe=0;xe<fe.length;xe++){var me=fe[xe];me!==null&&(me.lane&=-536870913)}p&=~Se}y!==0&&xs(l,y,0),I!==0&&w===0&&l.tag!==0&&(l.suspendedLanes|=I&~($&~h))}function xs(l,h,p){l.pendingLanes|=h,l.suspendedLanes&=~h;var y=31-va(h);l.entangledLanes|=h,l.entanglements[y]=l.entanglements[y]|1073741824|p&4194090}function tl(l,h){var p=l.entangledLanes|=h;for(l=l.entanglements;p;){var y=31-va(p),w=1<<y;w&h|l[y]&h&&(l[y]|=h),p&=~w}}function ye(l){switch(l){case 2:l=1;break;case 8:l=4;break;case 32:l=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:l=128;break;case 268435456:l=134217728;break;default:l=0}return l}function _e(l){return l&=-l,2<l?8<l?(l&134217727)!==0?32:268435456:8:2}function Ve(){var l=X.p;return l!==0?l:(l=window.event,l===void 0?32:sC(l.type))}function De(l,h){var p=X.p;try{return X.p=l,h()}finally{X.p=p}}var It=Math.random().toString(36).slice(2),dt="__reactFiber$"+It,qe="__reactProps$"+It,Ye="__reactContainer$"+It,ia="__reactEvents$"+It,On="__reactListeners$"+It,Yr="__reactHandles$"+It,al="__reactResources$"+It,Zr="__reactMarker$"+It;function $i(l){delete l[dt],delete l[qe],delete l[ia],delete l[On],delete l[Yr]}function fa(l){var h=l[dt];if(h)return h;for(var p=l.parentNode;p;){if(h=p[Ye]||p[dt]){if(p=h.alternate,h.child!==null||p!==null&&p.child!==null)for(l=G_(l);l!==null;){if(p=l[dt])return p;l=G_(l)}return h}l=p,p=l.parentNode}return null}function zn(l){if(l=l[dt]||l[Ye]){var h=l.tag;if(h===5||h===6||h===13||h===26||h===27||h===3)return l}return null}function ws(l){var h=l.tag;if(h===5||h===26||h===27||h===6)return l.stateNode;throw Error(n(33))}function Ri(l){var h=l[al];return h||(h=l[al]={hoistableStyles:new Map,hoistableScripts:new Map}),h}function xa(l){l[Zr]=!0}var pg=new Set,fg={};function Ys(l,h){Ar(l,h),Ar(l+"Capture",h)}function Ar(l,h){for(fg[l]=h,l=0;l<h.length;l++)pg.add(h[l])}var Zv=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),mg={},yp={};function Qv(l){return st.call(yp,l)?!0:st.call(mg,l)?!1:Zv.test(l)?yp[l]=!0:(mg[l]=!0,!1)}function Di(l,h,p){if(Qv(h))if(p===null)l.removeAttribute(h);else{switch(typeof p){case"undefined":case"function":case"symbol":l.removeAttribute(h);return;case"boolean":var y=h.toLowerCase().slice(0,5);if(y!=="data-"&&y!=="aria-"){l.removeAttribute(h);return}}l.setAttribute(h,""+p)}}function zc(l,h,p){if(p===null)l.removeAttribute(h);else{switch(typeof p){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(h);return}l.setAttribute(h,""+p)}}function Qr(l,h,p,y){if(y===null)l.removeAttribute(p);else{switch(typeof y){case"undefined":case"function":case"symbol":case"boolean":l.removeAttribute(p);return}l.setAttributeNS(h,p,""+y)}}var bp,Zs;function ks(l){if(bp===void 0)try{throw Error()}catch(p){var h=p.stack.trim().match(/\n( *(at )?)/);bp=h&&h[1]||"",Zs=-1<p.stack.indexOf(`
    at`)?" (<anonymous>)":-1<p.stack.indexOf("@")?"@unknown:0:0":""}return`
`+bp+l+Zs}var vp=!1;function xp(l,h){if(!l||vp)return"";vp=!0;var p=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var y={DetermineComponentFrameRoot:function(){try{if(h){var Se=function(){throw Error()};if(Object.defineProperty(Se.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Se,[])}catch(me){var fe=me}Reflect.construct(l,[],Se)}else{try{Se.call()}catch(me){fe=me}l.call(Se.prototype)}}else{try{throw Error()}catch(me){fe=me}(Se=l())&&typeof Se.catch=="function"&&Se.catch(function(){})}}catch(me){if(me&&fe&&typeof me.stack=="string")return[me.stack,fe.stack]}return[null,null]}};y.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var w=Object.getOwnPropertyDescriptor(y.DetermineComponentFrameRoot,"name");w&&w.configurable&&Object.defineProperty(y.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var I=y.DetermineComponentFrameRoot(),$=I[0],z=I[1];if($&&z){var Y=$.split(`
`),he=z.split(`
`);for(w=y=0;y<Y.length&&!Y[y].includes("DetermineComponentFrameRoot");)y++;for(;w<he.length&&!he[w].includes("DetermineComponentFrameRoot");)w++;if(y===Y.length||w===he.length)for(y=Y.length-1,w=he.length-1;1<=y&&0<=w&&Y[y]!==he[w];)w--;for(;1<=y&&0<=w;y--,w--)if(Y[y]!==he[w]){if(y!==1||w!==1)do if(y--,w--,0>w||Y[y]!==he[w]){var xe=`
`+Y[y].replace(" at new "," at ");return l.displayName&&xe.includes("<anonymous>")&&(xe=xe.replace("<anonymous>",l.displayName)),xe}while(1<=y&&0<=w);break}}}finally{vp=!1,Error.prepareStackTrace=p}return(p=l?l.displayName||l.name:"")?ks(p):""}function Jv(l){switch(l.tag){case 26:case 27:case 5:return ks(l.type);case 16:return ks("Lazy");case 13:return ks("Suspense");case 19:return ks("SuspenseList");case 0:case 15:return xp(l.type,!1);case 11:return xp(l.type.render,!1);case 1:return xp(l.type,!0);case 31:return ks("Activity");default:return""}}function gg(l){try{var h="";do h+=Jv(l),l=l.return;while(l);return h}catch(p){return`
Error generating stack: `+p.message+`
`+p.stack}}function Ln(l){switch(typeof l){case"bigint":case"boolean":case"number":case"string":case"undefined":return l;case"object":return l;default:return""}}function wp(l){var h=l.type;return(l=l.nodeName)&&l.toLowerCase()==="input"&&(h==="checkbox"||h==="radio")}function ex(l){var h=wp(l)?"checked":"value",p=Object.getOwnPropertyDescriptor(l.constructor.prototype,h),y=""+l[h];if(!l.hasOwnProperty(h)&&typeof p<"u"&&typeof p.get=="function"&&typeof p.set=="function"){var w=p.get,I=p.set;return Object.defineProperty(l,h,{configurable:!0,get:function(){return w.call(this)},set:function($){y=""+$,I.call(this,$)}}),Object.defineProperty(l,h,{enumerable:p.enumerable}),{getValue:function(){return y},setValue:function($){y=""+$},stopTracking:function(){l._valueTracker=null,delete l[h]}}}}function Lc(l){l._valueTracker||(l._valueTracker=ex(l))}function kp(l){if(!l)return!1;var h=l._valueTracker;if(!h)return!0;var p=h.getValue(),y="";return l&&(y=wp(l)?l.checked?"true":"false":l.value),l=y,l!==p?(h.setValue(l),!0):!1}function nl(l){if(l=l||(typeof document<"u"?document:void 0),typeof l>"u")return null;try{return l.activeElement||l.body}catch{return l.body}}var tx=/[\n"\\]/g;function Xn(l){return l.replace(tx,function(h){return"\\"+h.charCodeAt(0).toString(16)+" "})}function Sp(l,h,p,y,w,I,$,z){l.name="",$!=null&&typeof $!="function"&&typeof $!="symbol"&&typeof $!="boolean"?l.type=$:l.removeAttribute("type"),h!=null?$==="number"?(h===0&&l.value===""||l.value!=h)&&(l.value=""+Ln(h)):l.value!==""+Ln(h)&&(l.value=""+Ln(h)):$!=="submit"&&$!=="reset"||l.removeAttribute("value"),h!=null?Bc(l,$,Ln(h)):p!=null?Bc(l,$,Ln(p)):y!=null&&l.removeAttribute("value"),w==null&&I!=null&&(l.defaultChecked=!!I),w!=null&&(l.checked=w&&typeof w!="function"&&typeof w!="symbol"),z!=null&&typeof z!="function"&&typeof z!="symbol"&&typeof z!="boolean"?l.name=""+Ln(z):l.removeAttribute("name")}function yg(l,h,p,y,w,I,$,z){if(I!=null&&typeof I!="function"&&typeof I!="symbol"&&typeof I!="boolean"&&(l.type=I),h!=null||p!=null){if(!(I!=="submit"&&I!=="reset"||h!=null))return;p=p!=null?""+Ln(p):"",h=h!=null?""+Ln(h):p,z||h===l.value||(l.value=h),l.defaultValue=h}y=y??w,y=typeof y!="function"&&typeof y!="symbol"&&!!y,l.checked=z?l.checked:!!y,l.defaultChecked=!!y,$!=null&&typeof $!="function"&&typeof $!="symbol"&&typeof $!="boolean"&&(l.name=$)}function Bc(l,h,p){h==="number"&&nl(l.ownerDocument)===l||l.defaultValue===""+p||(l.defaultValue=""+p)}function Jr(l,h,p,y){if(l=l.options,h){h={};for(var w=0;w<p.length;w++)h["$"+p[w]]=!0;for(p=0;p<l.length;p++)w=h.hasOwnProperty("$"+l[p].value),l[p].selected!==w&&(l[p].selected=w),w&&y&&(l[p].defaultSelected=!0)}else{for(p=""+Ln(p),h=null,w=0;w<l.length;w++){if(l[w].value===p){l[w].selected=!0,y&&(l[w].defaultSelected=!0);return}h!==null||l[w].disabled||(h=l[w])}h!==null&&(h.selected=!0)}}function Ip(l,h,p){if(h!=null&&(h=""+Ln(h),h!==l.value&&(l.value=h),p==null)){l.defaultValue!==h&&(l.defaultValue=h);return}l.defaultValue=p!=null?""+Ln(p):""}function Np(l,h,p,y){if(h==null){if(y!=null){if(p!=null)throw Error(n(92));if(ee(y)){if(1<y.length)throw Error(n(93));y=y[0]}p=y}p==null&&(p=""),h=p}p=Ln(h),l.defaultValue=p,y=l.textContent,y===p&&y!==""&&y!==null&&(l.value=y)}function Qs(l,h){if(h){var p=l.firstChild;if(p&&p===l.lastChild&&p.nodeType===3){p.nodeValue=h;return}}l.textContent=h}var Tp=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function _p(l,h,p){var y=h.indexOf("--")===0;p==null||typeof p=="boolean"||p===""?y?l.setProperty(h,""):h==="float"?l.cssFloat="":l[h]="":y?l.setProperty(h,p):typeof p!="number"||p===0||Tp.has(h)?h==="float"?l.cssFloat=p:l[h]=(""+p).trim():l[h]=p+"px"}function Cp(l,h,p){if(h!=null&&typeof h!="object")throw Error(n(62));if(l=l.style,p!=null){for(var y in p)!p.hasOwnProperty(y)||h!=null&&h.hasOwnProperty(y)||(y.indexOf("--")===0?l.setProperty(y,""):y==="float"?l.cssFloat="":l[y]="");for(var w in h)y=h[w],h.hasOwnProperty(w)&&p[w]!==y&&_p(l,w,y)}else for(var I in h)h.hasOwnProperty(I)&&_p(l,I,h[I])}function rl(l){if(l.indexOf("-")===-1)return!1;switch(l){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Uc=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Pc=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Js(l){return Pc.test(""+l)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":l}var Wc=null;function Mi(l){return l=l.target||l.srcElement||window,l.correspondingUseElement&&(l=l.correspondingUseElement),l.nodeType===3?l.parentNode:l}var es=null,Fi=null;function H(l){var h=zn(l);if(h&&(l=h.stateNode)){var p=l[qe]||null;e:switch(l=h.stateNode,h.type){case"input":if(Sp(l,p.value,p.defaultValue,p.defaultValue,p.checked,p.defaultChecked,p.type,p.name),h=p.name,p.type==="radio"&&h!=null){for(p=l;p.parentNode;)p=p.parentNode;for(p=p.querySelectorAll('input[name="'+Xn(""+h)+'"][type="radio"]'),h=0;h<p.length;h++){var y=p[h];if(y!==l&&y.form===l.form){var w=y[qe]||null;if(!w)throw Error(n(90));Sp(y,w.value,w.defaultValue,w.defaultValue,w.checked,w.defaultChecked,w.type,w.name)}}for(h=0;h<p.length;h++)y=p[h],y.form===l.form&&kp(y)}break e;case"textarea":Ip(l,p.value,p.defaultValue);break e;case"select":h=p.value,h!=null&&Jr(l,!!p.multiple,h,!1)}}}var ue=!1;function Ce(l,h,p){if(ue)return l(h,p);ue=!0;try{var y=l(h);return y}finally{if(ue=!1,(es!==null||Fi!==null)&&(Jg(),es&&(h=es,l=Fi,Fi=es=null,H(h),l)))for(h=0;h<l.length;h++)H(l[h])}}function Ge(l,h){var p=l.stateNode;if(p===null)return null;var y=p[qe]||null;if(y===null)return null;p=y[h];e:switch(h){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(y=!y.disabled)||(l=l.type,y=!(l==="button"||l==="input"||l==="select"||l==="textarea")),l=!y;break e;default:l=!1}if(l)return null;if(p&&typeof p!="function")throw Error(n(231,h,typeof p));return p}var Ke=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),at=!1;if(Ke)try{var Me={};Object.defineProperty(Me,"passive",{get:function(){at=!0}}),window.addEventListener("test",Me,Me),window.removeEventListener("test",Me,Me)}catch{at=!1}var Oe=null,jt=null,rn=null;function $r(){if(rn)return rn;var l,h=jt,p=h.length,y,w="value"in Oe?Oe.value:Oe.textContent,I=w.length;for(l=0;l<p&&h[l]===w[l];l++);var $=p-l;for(y=1;y<=$&&h[p-y]===w[I-y];y++);return rn=w.slice(l,1<y?1-y:void 0)}function sl(l){var h=l.keyCode;return"charCode"in l?(l=l.charCode,l===0&&h===13&&(l=13)):l=h,l===10&&(l=13),32<=l||l===13?l:0}function Oi(){return!0}function bg(){return!1}function Kt(l){function h(p,y,w,I,$){this._reactName=p,this._targetInst=w,this.type=y,this.nativeEvent=I,this.target=$,this.currentTarget=null;for(var z in l)l.hasOwnProperty(z)&&(p=l[z],this[z]=p?p(I):I[z]);return this.isDefaultPrevented=(I.defaultPrevented!=null?I.defaultPrevented:I.returnValue===!1)?Oi:bg,this.isPropagationStopped=bg,this}return c(h.prototype,{preventDefault:function(){this.defaultPrevented=!0;var p=this.nativeEvent;p&&(p.preventDefault?p.preventDefault():typeof p.returnValue!="unknown"&&(p.returnValue=!1),this.isDefaultPrevented=Oi)},stopPropagation:function(){var p=this.nativeEvent;p&&(p.stopPropagation?p.stopPropagation():typeof p.cancelBubble!="unknown"&&(p.cancelBubble=!0),this.isPropagationStopped=Oi)},persist:function(){},isPersistent:Oi}),h}var Yn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(l){return l.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},il=Kt(Yn),Ep=c({},Yn,{view:0,detail:0}),pB=Kt(Ep),ax,nx,Ap,vg=c({},Ep,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:sx,button:0,buttons:0,relatedTarget:function(l){return l.relatedTarget===void 0?l.fromElement===l.srcElement?l.toElement:l.fromElement:l.relatedTarget},movementX:function(l){return"movementX"in l?l.movementX:(l!==Ap&&(Ap&&l.type==="mousemove"?(ax=l.screenX-Ap.screenX,nx=l.screenY-Ap.screenY):nx=ax=0,Ap=l),ax)},movementY:function(l){return"movementY"in l?l.movementY:nx}}),HI=Kt(vg),fB=c({},vg,{dataTransfer:0}),mB=Kt(fB),gB=c({},Ep,{relatedTarget:0}),rx=Kt(gB),yB=c({},Yn,{animationName:0,elapsedTime:0,pseudoElement:0}),bB=Kt(yB),vB=c({},Yn,{clipboardData:function(l){return"clipboardData"in l?l.clipboardData:window.clipboardData}}),xB=Kt(vB),wB=c({},Yn,{data:0}),qI=Kt(wB),kB={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},SB={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},IB={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function NB(l){var h=this.nativeEvent;return h.getModifierState?h.getModifierState(l):(l=IB[l])?!!h[l]:!1}function sx(){return NB}var TB=c({},Ep,{key:function(l){if(l.key){var h=kB[l.key]||l.key;if(h!=="Unidentified")return h}return l.type==="keypress"?(l=sl(l),l===13?"Enter":String.fromCharCode(l)):l.type==="keydown"||l.type==="keyup"?SB[l.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:sx,charCode:function(l){return l.type==="keypress"?sl(l):0},keyCode:function(l){return l.type==="keydown"||l.type==="keyup"?l.keyCode:0},which:function(l){return l.type==="keypress"?sl(l):l.type==="keydown"||l.type==="keyup"?l.keyCode:0}}),_B=Kt(TB),CB=c({},vg,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),jI=Kt(CB),EB=c({},Ep,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:sx}),AB=Kt(EB),$B=c({},Yn,{propertyName:0,elapsedTime:0,pseudoElement:0}),RB=Kt($B),DB=c({},vg,{deltaX:function(l){return"deltaX"in l?l.deltaX:"wheelDeltaX"in l?-l.wheelDeltaX:0},deltaY:function(l){return"deltaY"in l?l.deltaY:"wheelDeltaY"in l?-l.wheelDeltaY:"wheelDelta"in l?-l.wheelDelta:0},deltaZ:0,deltaMode:0}),MB=Kt(DB),FB=c({},Yn,{newState:0,oldState:0}),OB=Kt(FB),zB=[9,13,27,32],ix=Ke&&"CompositionEvent"in window,$p=null;Ke&&"documentMode"in document&&($p=document.documentMode);var LB=Ke&&"TextEvent"in window&&!$p,KI=Ke&&(!ix||$p&&8<$p&&11>=$p),XI=" ",YI=!1;function ZI(l,h){switch(l){case"keyup":return zB.indexOf(h.keyCode)!==-1;case"keydown":return h.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function QI(l){return l=l.detail,typeof l=="object"&&"data"in l?l.data:null}var Vc=!1;function BB(l,h){switch(l){case"compositionend":return QI(h);case"keypress":return h.which!==32?null:(YI=!0,XI);case"textInput":return l=h.data,l===XI&&YI?null:l;default:return null}}function UB(l,h){if(Vc)return l==="compositionend"||!ix&&ZI(l,h)?(l=$r(),rn=jt=Oe=null,Vc=!1,l):null;switch(l){case"paste":return null;case"keypress":if(!(h.ctrlKey||h.altKey||h.metaKey)||h.ctrlKey&&h.altKey){if(h.char&&1<h.char.length)return h.char;if(h.which)return String.fromCharCode(h.which)}return null;case"compositionend":return KI&&h.locale!=="ko"?null:h.data;default:return null}}var PB={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function JI(l){var h=l&&l.nodeName&&l.nodeName.toLowerCase();return h==="input"?!!PB[l.type]:h==="textarea"}function eN(l,h,p,y){es?Fi?Fi.push(y):Fi=[y]:es=y,h=sy(h,"onChange"),0<h.length&&(p=new il("onChange","change",null,p,y),l.push({event:p,listeners:h}))}var Rp=null,Dp=null;function WB(l){M_(l,0)}function xg(l){var h=ws(l);if(kp(h))return l}function tN(l,h){if(l==="change")return h}var aN=!1;if(Ke){var ox;if(Ke){var lx="oninput"in document;if(!lx){var nN=document.createElement("div");nN.setAttribute("oninput","return;"),lx=typeof nN.oninput=="function"}ox=lx}else ox=!1;aN=ox&&(!document.documentMode||9<document.documentMode)}function rN(){Rp&&(Rp.detachEvent("onpropertychange",sN),Dp=Rp=null)}function sN(l){if(l.propertyName==="value"&&xg(Dp)){var h=[];eN(h,Dp,l,Mi(l)),Ce(WB,h)}}function VB(l,h,p){l==="focusin"?(rN(),Rp=h,Dp=p,Rp.attachEvent("onpropertychange",sN)):l==="focusout"&&rN()}function GB(l){if(l==="selectionchange"||l==="keyup"||l==="keydown")return xg(Dp)}function HB(l,h){if(l==="click")return xg(h)}function qB(l,h){if(l==="input"||l==="change")return xg(h)}function jB(l,h){return l===h&&(l!==0||1/l===1/h)||l!==l&&h!==h}var pr=typeof Object.is=="function"?Object.is:jB;function Mp(l,h){if(pr(l,h))return!0;if(typeof l!="object"||l===null||typeof h!="object"||h===null)return!1;var p=Object.keys(l),y=Object.keys(h);if(p.length!==y.length)return!1;for(y=0;y<p.length;y++){var w=p[y];if(!st.call(h,w)||!pr(l[w],h[w]))return!1}return!0}function iN(l){for(;l&&l.firstChild;)l=l.firstChild;return l}function oN(l,h){var p=iN(l);l=0;for(var y;p;){if(p.nodeType===3){if(y=l+p.textContent.length,l<=h&&y>=h)return{node:p,offset:h-l};l=y}e:{for(;p;){if(p.nextSibling){p=p.nextSibling;break e}p=p.parentNode}p=void 0}p=iN(p)}}function lN(l,h){return l&&h?l===h?!0:l&&l.nodeType===3?!1:h&&h.nodeType===3?lN(l,h.parentNode):"contains"in l?l.contains(h):l.compareDocumentPosition?!!(l.compareDocumentPosition(h)&16):!1:!1}function uN(l){l=l!=null&&l.ownerDocument!=null&&l.ownerDocument.defaultView!=null?l.ownerDocument.defaultView:window;for(var h=nl(l.document);h instanceof l.HTMLIFrameElement;){try{var p=typeof h.contentWindow.location.href=="string"}catch{p=!1}if(p)l=h.contentWindow;else break;h=nl(l.document)}return h}function ux(l){var h=l&&l.nodeName&&l.nodeName.toLowerCase();return h&&(h==="input"&&(l.type==="text"||l.type==="search"||l.type==="tel"||l.type==="url"||l.type==="password")||h==="textarea"||l.contentEditable==="true")}var KB=Ke&&"documentMode"in document&&11>=document.documentMode,Gc=null,cx=null,Fp=null,dx=!1;function cN(l,h,p){var y=p.window===p?p.document:p.nodeType===9?p:p.ownerDocument;dx||Gc==null||Gc!==nl(y)||(y=Gc,"selectionStart"in y&&ux(y)?y={start:y.selectionStart,end:y.selectionEnd}:(y=(y.ownerDocument&&y.ownerDocument.defaultView||window).getSelection(),y={anchorNode:y.anchorNode,anchorOffset:y.anchorOffset,focusNode:y.focusNode,focusOffset:y.focusOffset}),Fp&&Mp(Fp,y)||(Fp=y,y=sy(cx,"onSelect"),0<y.length&&(h=new il("onSelect","select",null,h,p),l.push({event:h,listeners:y}),h.target=Gc)))}function ol(l,h){var p={};return p[l.toLowerCase()]=h.toLowerCase(),p["Webkit"+l]="webkit"+h,p["Moz"+l]="moz"+h,p}var Hc={animationend:ol("Animation","AnimationEnd"),animationiteration:ol("Animation","AnimationIteration"),animationstart:ol("Animation","AnimationStart"),transitionrun:ol("Transition","TransitionRun"),transitionstart:ol("Transition","TransitionStart"),transitioncancel:ol("Transition","TransitionCancel"),transitionend:ol("Transition","TransitionEnd")},hx={},dN={};Ke&&(dN=document.createElement("div").style,"AnimationEvent"in window||(delete Hc.animationend.animation,delete Hc.animationiteration.animation,delete Hc.animationstart.animation),"TransitionEvent"in window||delete Hc.transitionend.transition);function ll(l){if(hx[l])return hx[l];if(!Hc[l])return l;var h=Hc[l],p;for(p in h)if(h.hasOwnProperty(p)&&p in dN)return hx[l]=h[p];return l}var hN=ll("animationend"),pN=ll("animationiteration"),fN=ll("animationstart"),XB=ll("transitionrun"),YB=ll("transitionstart"),ZB=ll("transitioncancel"),mN=ll("transitionend"),gN=new Map,px="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");px.push("scrollEnd");function ts(l,h){gN.set(l,h),Ys(h,[l])}var yN=new WeakMap;function Rr(l,h){if(typeof l=="object"&&l!==null){var p=yN.get(l);return p!==void 0?p:(h={value:l,source:h,stack:gg(h)},yN.set(l,h),h)}return{value:l,source:h,stack:gg(h)}}var Dr=[],qc=0,fx=0;function wg(){for(var l=qc,h=fx=qc=0;h<l;){var p=Dr[h];Dr[h++]=null;var y=Dr[h];Dr[h++]=null;var w=Dr[h];Dr[h++]=null;var I=Dr[h];if(Dr[h++]=null,y!==null&&w!==null){var $=y.pending;$===null?w.next=w:(w.next=$.next,$.next=w),y.pending=w}I!==0&&bN(p,w,I)}}function kg(l,h,p,y){Dr[qc++]=l,Dr[qc++]=h,Dr[qc++]=p,Dr[qc++]=y,fx|=y,l.lanes|=y,l=l.alternate,l!==null&&(l.lanes|=y)}function mx(l,h,p,y){return kg(l,h,p,y),Sg(l)}function jc(l,h){return kg(l,null,null,h),Sg(l)}function bN(l,h,p){l.lanes|=p;var y=l.alternate;y!==null&&(y.lanes|=p);for(var w=!1,I=l.return;I!==null;)I.childLanes|=p,y=I.alternate,y!==null&&(y.childLanes|=p),I.tag===22&&(l=I.stateNode,l===null||l._visibility&1||(w=!0)),l=I,I=I.return;return l.tag===3?(I=l.stateNode,w&&h!==null&&(w=31-va(p),l=I.hiddenUpdates,y=l[w],y===null?l[w]=[h]:y.push(h),h.lane=p|536870912),I):null}function Sg(l){if(50<of)throw of=0,w0=null,Error(n(185));for(var h=l.return;h!==null;)l=h,h=l.return;return l.tag===3?l.stateNode:null}var Kc={};function QB(l,h,p,y){this.tag=l,this.key=p,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=h,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=y,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function fr(l,h,p,y){return new QB(l,h,p,y)}function gx(l){return l=l.prototype,!(!l||!l.isReactComponent)}function ei(l,h){var p=l.alternate;return p===null?(p=fr(l.tag,h,l.key,l.mode),p.elementType=l.elementType,p.type=l.type,p.stateNode=l.stateNode,p.alternate=l,l.alternate=p):(p.pendingProps=h,p.type=l.type,p.flags=0,p.subtreeFlags=0,p.deletions=null),p.flags=l.flags&65011712,p.childLanes=l.childLanes,p.lanes=l.lanes,p.child=l.child,p.memoizedProps=l.memoizedProps,p.memoizedState=l.memoizedState,p.updateQueue=l.updateQueue,h=l.dependencies,p.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext},p.sibling=l.sibling,p.index=l.index,p.ref=l.ref,p.refCleanup=l.refCleanup,p}function vN(l,h){l.flags&=65011714;var p=l.alternate;return p===null?(l.childLanes=0,l.lanes=h,l.child=null,l.subtreeFlags=0,l.memoizedProps=null,l.memoizedState=null,l.updateQueue=null,l.dependencies=null,l.stateNode=null):(l.childLanes=p.childLanes,l.lanes=p.lanes,l.child=p.child,l.subtreeFlags=0,l.deletions=null,l.memoizedProps=p.memoizedProps,l.memoizedState=p.memoizedState,l.updateQueue=p.updateQueue,l.type=p.type,h=p.dependencies,l.dependencies=h===null?null:{lanes:h.lanes,firstContext:h.firstContext}),l}function Ig(l,h,p,y,w,I){var $=0;if(y=l,typeof l=="function")gx(l)&&($=1);else if(typeof l=="string")$=eU(l,p,pe.current)?26:l==="html"||l==="head"||l==="body"?27:5;else e:switch(l){case B:return l=fr(31,p,h,w),l.elementType=B,l.lanes=I,l;case b:return ul(p.children,w,I,h);case v:$=8,w|=24;break;case x:return l=fr(12,p,h,w|2),l.elementType=x,l.lanes=I,l;case _:return l=fr(13,p,h,w),l.elementType=_,l.lanes=I,l;case R:return l=fr(19,p,h,w),l.elementType=R,l.lanes=I,l;default:if(typeof l=="object"&&l!==null)switch(l.$$typeof){case k:case N:$=10;break e;case S:$=9;break e;case T:$=11;break e;case M:$=14;break e;case F:$=16,y=null;break e}$=29,p=Error(n(130,l===null?"null":typeof l,"")),y=null}return h=fr($,p,h,w),h.elementType=l,h.type=y,h.lanes=I,h}function ul(l,h,p,y){return l=fr(7,l,y,h),l.lanes=p,l}function yx(l,h,p){return l=fr(6,l,null,h),l.lanes=p,l}function bx(l,h,p){return h=fr(4,l.children!==null?l.children:[],l.key,h),h.lanes=p,h.stateNode={containerInfo:l.containerInfo,pendingChildren:null,implementation:l.implementation},h}var Xc=[],Yc=0,Ng=null,Tg=0,Mr=[],Fr=0,cl=null,ti=1,ai="";function dl(l,h){Xc[Yc++]=Tg,Xc[Yc++]=Ng,Ng=l,Tg=h}function xN(l,h,p){Mr[Fr++]=ti,Mr[Fr++]=ai,Mr[Fr++]=cl,cl=l;var y=ti;l=ai;var w=32-va(y)-1;y&=~(1<<w),p+=1;var I=32-va(h)+w;if(30<I){var $=w-w%5;I=(y&(1<<$)-1).toString(32),y>>=$,w-=$,ti=1<<32-va(h)+w|p<<w|y,ai=I+l}else ti=1<<I|p<<w|y,ai=l}function vx(l){l.return!==null&&(dl(l,1),xN(l,1,0))}function xx(l){for(;l===Ng;)Ng=Xc[--Yc],Xc[Yc]=null,Tg=Xc[--Yc],Xc[Yc]=null;for(;l===cl;)cl=Mr[--Fr],Mr[Fr]=null,ai=Mr[--Fr],Mr[Fr]=null,ti=Mr[--Fr],Mr[Fr]=null}var Bn=null,wa=null,Dt=!1,hl=null,Ss=!1,wx=Error(n(519));function pl(l){var h=Error(n(418,""));throw Lp(Rr(h,l)),wx}function wN(l){var h=l.stateNode,p=l.type,y=l.memoizedProps;switch(h[dt]=l,h[qe]=y,p){case"dialog":kt("cancel",h),kt("close",h);break;case"iframe":case"object":case"embed":kt("load",h);break;case"video":case"audio":for(p=0;p<uf.length;p++)kt(uf[p],h);break;case"source":kt("error",h);break;case"img":case"image":case"link":kt("error",h),kt("load",h);break;case"details":kt("toggle",h);break;case"input":kt("invalid",h),yg(h,y.value,y.defaultValue,y.checked,y.defaultChecked,y.type,y.name,!0),Lc(h);break;case"select":kt("invalid",h);break;case"textarea":kt("invalid",h),Np(h,y.value,y.defaultValue,y.children),Lc(h)}p=y.children,typeof p!="string"&&typeof p!="number"&&typeof p!="bigint"||h.textContent===""+p||y.suppressHydrationWarning===!0||L_(h.textContent,p)?(y.popover!=null&&(kt("beforetoggle",h),kt("toggle",h)),y.onScroll!=null&&kt("scroll",h),y.onScrollEnd!=null&&kt("scrollend",h),y.onClick!=null&&(h.onclick=iy),h=!0):h=!1,h||pl(l)}function kN(l){for(Bn=l.return;Bn;)switch(Bn.tag){case 5:case 13:Ss=!1;return;case 27:case 3:Ss=!0;return;default:Bn=Bn.return}}function Op(l){if(l!==Bn)return!1;if(!Dt)return kN(l),Dt=!0,!1;var h=l.tag,p;if((p=h!==3&&h!==27)&&((p=h===5)&&(p=l.type,p=!(p!=="form"&&p!=="button")||z0(l.type,l.memoizedProps)),p=!p),p&&wa&&pl(l),kN(l),h===13){if(l=l.memoizedState,l=l!==null?l.dehydrated:null,!l)throw Error(n(317));e:{for(l=l.nextSibling,h=0;l;){if(l.nodeType===8)if(p=l.data,p==="/$"){if(h===0){wa=ns(l.nextSibling);break e}h--}else p!=="$"&&p!=="$!"&&p!=="$?"||h++;l=l.nextSibling}wa=null}}else h===27?(h=wa,Qi(l.type)?(l=P0,P0=null,wa=l):wa=h):wa=Bn?ns(l.stateNode.nextSibling):null;return!0}function zp(){wa=Bn=null,Dt=!1}function SN(){var l=hl;return l!==null&&(Jn===null?Jn=l:Jn.push.apply(Jn,l),hl=null),l}function Lp(l){hl===null?hl=[l]:hl.push(l)}var kx=q(null),fl=null,ni=null;function zi(l,h,p){se(kx,h._currentValue),h._currentValue=p}function ri(l){l._currentValue=kx.current,le(kx)}function Sx(l,h,p){for(;l!==null;){var y=l.alternate;if((l.childLanes&h)!==h?(l.childLanes|=h,y!==null&&(y.childLanes|=h)):y!==null&&(y.childLanes&h)!==h&&(y.childLanes|=h),l===p)break;l=l.return}}function Ix(l,h,p,y){var w=l.child;for(w!==null&&(w.return=l);w!==null;){var I=w.dependencies;if(I!==null){var $=w.child;I=I.firstContext;e:for(;I!==null;){var z=I;I=w;for(var Y=0;Y<h.length;Y++)if(z.context===h[Y]){I.lanes|=p,z=I.alternate,z!==null&&(z.lanes|=p),Sx(I.return,p,l),y||($=null);break e}I=z.next}}else if(w.tag===18){if($=w.return,$===null)throw Error(n(341));$.lanes|=p,I=$.alternate,I!==null&&(I.lanes|=p),Sx($,p,l),$=null}else $=w.child;if($!==null)$.return=w;else for($=w;$!==null;){if($===l){$=null;break}if(w=$.sibling,w!==null){w.return=$.return,$=w;break}$=$.return}w=$}}function Bp(l,h,p,y){l=null;for(var w=h,I=!1;w!==null;){if(!I){if((w.flags&524288)!==0)I=!0;else if((w.flags&262144)!==0)break}if(w.tag===10){var $=w.alternate;if($===null)throw Error(n(387));if($=$.memoizedProps,$!==null){var z=w.type;pr(w.pendingProps.value,$.value)||(l!==null?l.push(z):l=[z])}}else if(w===Re.current){if($=w.alternate,$===null)throw Error(n(387));$.memoizedState.memoizedState!==w.memoizedState.memoizedState&&(l!==null?l.push(mf):l=[mf])}w=w.return}l!==null&&Ix(h,l,p,y),h.flags|=262144}function _g(l){for(l=l.firstContext;l!==null;){if(!pr(l.context._currentValue,l.memoizedValue))return!0;l=l.next}return!1}function ml(l){fl=l,ni=null,l=l.dependencies,l!==null&&(l.firstContext=null)}function kn(l){return IN(fl,l)}function Cg(l,h){return fl===null&&ml(l),IN(l,h)}function IN(l,h){var p=h._currentValue;if(h={context:h,memoizedValue:p,next:null},ni===null){if(l===null)throw Error(n(308));ni=h,l.dependencies={lanes:0,firstContext:h},l.flags|=524288}else ni=ni.next=h;return p}var JB=typeof AbortController<"u"?AbortController:function(){var l=[],h=this.signal={aborted:!1,addEventListener:function(p,y){l.push(y)}};this.abort=function(){h.aborted=!0,l.forEach(function(p){return p()})}},e4=e.unstable_scheduleCallback,t4=e.unstable_NormalPriority,Ha={$$typeof:N,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Nx(){return{controller:new JB,data:new Map,refCount:0}}function Up(l){l.refCount--,l.refCount===0&&e4(t4,function(){l.controller.abort()})}var Pp=null,Tx=0,Zc=0,Qc=null;function a4(l,h){if(Pp===null){var p=Pp=[];Tx=0,Zc=C0(),Qc={status:"pending",value:void 0,then:function(y){p.push(y)}}}return Tx++,h.then(NN,NN),h}function NN(){if(--Tx===0&&Pp!==null){Qc!==null&&(Qc.status="fulfilled");var l=Pp;Pp=null,Zc=0,Qc=null;for(var h=0;h<l.length;h++)(0,l[h])()}}function n4(l,h){var p=[],y={status:"pending",value:null,reason:null,then:function(w){p.push(w)}};return l.then(function(){y.status="fulfilled",y.value=h;for(var w=0;w<p.length;w++)(0,p[w])(h)},function(w){for(y.status="rejected",y.reason=w,w=0;w<p.length;w++)(0,p[w])(void 0)}),y}var TN=W.S;W.S=function(l,h){typeof h=="object"&&h!==null&&typeof h.then=="function"&&a4(l,h),TN!==null&&TN(l,h)};var gl=q(null);function _x(){var l=gl.current;return l!==null?l:sa.pooledCache}function Eg(l,h){h===null?se(gl,gl.current):se(gl,h.pool)}function _N(){var l=_x();return l===null?null:{parent:Ha._currentValue,pool:l}}var Wp=Error(n(460)),CN=Error(n(474)),Ag=Error(n(542)),Cx={then:function(){}};function EN(l){return l=l.status,l==="fulfilled"||l==="rejected"}function $g(){}function AN(l,h,p){switch(p=l[p],p===void 0?l.push(h):p!==h&&(h.then($g,$g),h=p),h.status){case"fulfilled":return h.value;case"rejected":throw l=h.reason,RN(l),l;default:if(typeof h.status=="string")h.then($g,$g);else{if(l=sa,l!==null&&100<l.shellSuspendCounter)throw Error(n(482));l=h,l.status="pending",l.then(function(y){if(h.status==="pending"){var w=h;w.status="fulfilled",w.value=y}},function(y){if(h.status==="pending"){var w=h;w.status="rejected",w.reason=y}})}switch(h.status){case"fulfilled":return h.value;case"rejected":throw l=h.reason,RN(l),l}throw Vp=h,Wp}}var Vp=null;function $N(){if(Vp===null)throw Error(n(459));var l=Vp;return Vp=null,l}function RN(l){if(l===Wp||l===Ag)throw Error(n(483))}var Li=!1;function Ex(l){l.updateQueue={baseState:l.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Ax(l,h){l=l.updateQueue,h.updateQueue===l&&(h.updateQueue={baseState:l.baseState,firstBaseUpdate:l.firstBaseUpdate,lastBaseUpdate:l.lastBaseUpdate,shared:l.shared,callbacks:null})}function Bi(l){return{lane:l,tag:0,payload:null,callback:null,next:null}}function Ui(l,h,p){var y=l.updateQueue;if(y===null)return null;if(y=y.shared,(Ut&2)!==0){var w=y.pending;return w===null?h.next=h:(h.next=w.next,w.next=h),y.pending=h,h=Sg(l),bN(l,null,p),h}return kg(l,y,h,p),Sg(l)}function Gp(l,h,p){if(h=h.updateQueue,h!==null&&(h=h.shared,(p&4194048)!==0)){var y=h.lanes;y&=l.pendingLanes,p|=y,h.lanes=p,tl(l,p)}}function $x(l,h){var p=l.updateQueue,y=l.alternate;if(y!==null&&(y=y.updateQueue,p===y)){var w=null,I=null;if(p=p.firstBaseUpdate,p!==null){do{var $={lane:p.lane,tag:p.tag,payload:p.payload,callback:null,next:null};I===null?w=I=$:I=I.next=$,p=p.next}while(p!==null);I===null?w=I=h:I=I.next=h}else w=I=h;p={baseState:y.baseState,firstBaseUpdate:w,lastBaseUpdate:I,shared:y.shared,callbacks:y.callbacks},l.updateQueue=p;return}l=p.lastBaseUpdate,l===null?p.firstBaseUpdate=h:l.next=h,p.lastBaseUpdate=h}var Rx=!1;function Hp(){if(Rx){var l=Qc;if(l!==null)throw l}}function qp(l,h,p,y){Rx=!1;var w=l.updateQueue;Li=!1;var I=w.firstBaseUpdate,$=w.lastBaseUpdate,z=w.shared.pending;if(z!==null){w.shared.pending=null;var Y=z,he=Y.next;Y.next=null,$===null?I=he:$.next=he,$=Y;var xe=l.alternate;xe!==null&&(xe=xe.updateQueue,z=xe.lastBaseUpdate,z!==$&&(z===null?xe.firstBaseUpdate=he:z.next=he,xe.lastBaseUpdate=Y))}if(I!==null){var Se=w.baseState;$=0,xe=he=Y=null,z=I;do{var fe=z.lane&-536870913,me=fe!==z.lane;if(me?(_t&fe)===fe:(y&fe)===fe){fe!==0&&fe===Zc&&(Rx=!0),xe!==null&&(xe=xe.next={lane:0,tag:z.tag,payload:z.payload,callback:null,next:null});e:{var et=l,Xe=z;fe=h;var Zt=p;switch(Xe.tag){case 1:if(et=Xe.payload,typeof et=="function"){Se=et.call(Zt,Se,fe);break e}Se=et;break e;case 3:et.flags=et.flags&-65537|128;case 0:if(et=Xe.payload,fe=typeof et=="function"?et.call(Zt,Se,fe):et,fe==null)break e;Se=c({},Se,fe);break e;case 2:Li=!0}}fe=z.callback,fe!==null&&(l.flags|=64,me&&(l.flags|=8192),me=w.callbacks,me===null?w.callbacks=[fe]:me.push(fe))}else me={lane:fe,tag:z.tag,payload:z.payload,callback:z.callback,next:null},xe===null?(he=xe=me,Y=Se):xe=xe.next=me,$|=fe;if(z=z.next,z===null){if(z=w.shared.pending,z===null)break;me=z,z=me.next,me.next=null,w.lastBaseUpdate=me,w.shared.pending=null}}while(!0);xe===null&&(Y=Se),w.baseState=Y,w.firstBaseUpdate=he,w.lastBaseUpdate=xe,I===null&&(w.shared.lanes=0),Ki|=$,l.lanes=$,l.memoizedState=Se}}function DN(l,h){if(typeof l!="function")throw Error(n(191,l));l.call(h)}function MN(l,h){var p=l.callbacks;if(p!==null)for(l.callbacks=null,l=0;l<p.length;l++)DN(p[l],h)}var Jc=q(null),Rg=q(0);function FN(l,h){l=di,se(Rg,l),se(Jc,h),di=l|h.baseLanes}function Dx(){se(Rg,di),se(Jc,Jc.current)}function Mx(){di=Rg.current,le(Jc),le(Rg)}var Pi=0,yt=null,Xt=null,za=null,Dg=!1,ed=!1,yl=!1,Mg=0,jp=0,td=null,r4=0;function Ta(){throw Error(n(321))}function Fx(l,h){if(h===null)return!1;for(var p=0;p<h.length&&p<l.length;p++)if(!pr(l[p],h[p]))return!1;return!0}function Ox(l,h,p,y,w,I){return Pi=I,yt=h,h.memoizedState=null,h.updateQueue=null,h.lanes=0,W.H=l===null||l.memoizedState===null?bT:vT,yl=!1,I=p(y,w),yl=!1,ed&&(I=zN(h,p,y,w)),ON(l),I}function ON(l){W.H=Ug;var h=Xt!==null&&Xt.next!==null;if(Pi=0,za=Xt=yt=null,Dg=!1,jp=0,td=null,h)throw Error(n(300));l===null||sn||(l=l.dependencies,l!==null&&_g(l)&&(sn=!0))}function zN(l,h,p,y){yt=l;var w=0;do{if(ed&&(td=null),jp=0,ed=!1,25<=w)throw Error(n(301));if(w+=1,za=Xt=null,l.updateQueue!=null){var I=l.updateQueue;I.lastEffect=null,I.events=null,I.stores=null,I.memoCache!=null&&(I.memoCache.index=0)}W.H=d4,I=h(p,y)}while(ed);return I}function s4(){var l=W.H,h=l.useState()[0];return h=typeof h.then=="function"?Kp(h):h,l=l.useState()[0],(Xt!==null?Xt.memoizedState:null)!==l&&(yt.flags|=1024),h}function zx(){var l=Mg!==0;return Mg=0,l}function Lx(l,h,p){h.updateQueue=l.updateQueue,h.flags&=-2053,l.lanes&=~p}function Bx(l){if(Dg){for(l=l.memoizedState;l!==null;){var h=l.queue;h!==null&&(h.pending=null),l=l.next}Dg=!1}Pi=0,za=Xt=yt=null,ed=!1,jp=Mg=0,td=null}function Zn(){var l={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return za===null?yt.memoizedState=za=l:za=za.next=l,za}function La(){if(Xt===null){var l=yt.alternate;l=l!==null?l.memoizedState:null}else l=Xt.next;var h=za===null?yt.memoizedState:za.next;if(h!==null)za=h,Xt=l;else{if(l===null)throw yt.alternate===null?Error(n(467)):Error(n(310));Xt=l,l={memoizedState:Xt.memoizedState,baseState:Xt.baseState,baseQueue:Xt.baseQueue,queue:Xt.queue,next:null},za===null?yt.memoizedState=za=l:za=za.next=l}return za}function Ux(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Kp(l){var h=jp;return jp+=1,td===null&&(td=[]),l=AN(td,l,h),h=yt,(za===null?h.memoizedState:za.next)===null&&(h=h.alternate,W.H=h===null||h.memoizedState===null?bT:vT),l}function Fg(l){if(l!==null&&typeof l=="object"){if(typeof l.then=="function")return Kp(l);if(l.$$typeof===N)return kn(l)}throw Error(n(438,String(l)))}function Px(l){var h=null,p=yt.updateQueue;if(p!==null&&(h=p.memoCache),h==null){var y=yt.alternate;y!==null&&(y=y.updateQueue,y!==null&&(y=y.memoCache,y!=null&&(h={data:y.data.map(function(w){return w.slice()}),index:0})))}if(h==null&&(h={data:[],index:0}),p===null&&(p=Ux(),yt.updateQueue=p),p.memoCache=h,p=h.data[h.index],p===void 0)for(p=h.data[h.index]=Array(l),y=0;y<l;y++)p[y]=V;return h.index++,p}function si(l,h){return typeof h=="function"?h(l):h}function Og(l){var h=La();return Wx(h,Xt,l)}function Wx(l,h,p){var y=l.queue;if(y===null)throw Error(n(311));y.lastRenderedReducer=p;var w=l.baseQueue,I=y.pending;if(I!==null){if(w!==null){var $=w.next;w.next=I.next,I.next=$}h.baseQueue=w=I,y.pending=null}if(I=l.baseState,w===null)l.memoizedState=I;else{h=w.next;var z=$=null,Y=null,he=h,xe=!1;do{var Se=he.lane&-536870913;if(Se!==he.lane?(_t&Se)===Se:(Pi&Se)===Se){var fe=he.revertLane;if(fe===0)Y!==null&&(Y=Y.next={lane:0,revertLane:0,action:he.action,hasEagerState:he.hasEagerState,eagerState:he.eagerState,next:null}),Se===Zc&&(xe=!0);else if((Pi&fe)===fe){he=he.next,fe===Zc&&(xe=!0);continue}else Se={lane:0,revertLane:he.revertLane,action:he.action,hasEagerState:he.hasEagerState,eagerState:he.eagerState,next:null},Y===null?(z=Y=Se,$=I):Y=Y.next=Se,yt.lanes|=fe,Ki|=fe;Se=he.action,yl&&p(I,Se),I=he.hasEagerState?he.eagerState:p(I,Se)}else fe={lane:Se,revertLane:he.revertLane,action:he.action,hasEagerState:he.hasEagerState,eagerState:he.eagerState,next:null},Y===null?(z=Y=fe,$=I):Y=Y.next=fe,yt.lanes|=Se,Ki|=Se;he=he.next}while(he!==null&&he!==h);if(Y===null?$=I:Y.next=z,!pr(I,l.memoizedState)&&(sn=!0,xe&&(p=Qc,p!==null)))throw p;l.memoizedState=I,l.baseState=$,l.baseQueue=Y,y.lastRenderedState=I}return w===null&&(y.lanes=0),[l.memoizedState,y.dispatch]}function Vx(l){var h=La(),p=h.queue;if(p===null)throw Error(n(311));p.lastRenderedReducer=l;var y=p.dispatch,w=p.pending,I=h.memoizedState;if(w!==null){p.pending=null;var $=w=w.next;do I=l(I,$.action),$=$.next;while($!==w);pr(I,h.memoizedState)||(sn=!0),h.memoizedState=I,h.baseQueue===null&&(h.baseState=I),p.lastRenderedState=I}return[I,y]}function LN(l,h,p){var y=yt,w=La(),I=Dt;if(I){if(p===void 0)throw Error(n(407));p=p()}else p=h();var $=!pr((Xt||w).memoizedState,p);$&&(w.memoizedState=p,sn=!0),w=w.queue;var z=PN.bind(null,y,w,l);if(Xp(2048,8,z,[l]),w.getSnapshot!==h||$||za!==null&&za.memoizedState.tag&1){if(y.flags|=2048,ad(9,zg(),UN.bind(null,y,w,p,h),null),sa===null)throw Error(n(349));I||(Pi&124)!==0||BN(y,h,p)}return p}function BN(l,h,p){l.flags|=16384,l={getSnapshot:h,value:p},h=yt.updateQueue,h===null?(h=Ux(),yt.updateQueue=h,h.stores=[l]):(p=h.stores,p===null?h.stores=[l]:p.push(l))}function UN(l,h,p,y){h.value=p,h.getSnapshot=y,WN(h)&&VN(l)}function PN(l,h,p){return p(function(){WN(h)&&VN(l)})}function WN(l){var h=l.getSnapshot;l=l.value;try{var p=h();return!pr(l,p)}catch{return!0}}function VN(l){var h=jc(l,2);h!==null&&vr(h,l,2)}function Gx(l){var h=Zn();if(typeof l=="function"){var p=l;if(l=p(),yl){ba(!0);try{p()}finally{ba(!1)}}}return h.memoizedState=h.baseState=l,h.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:si,lastRenderedState:l},h}function GN(l,h,p,y){return l.baseState=p,Wx(l,Xt,typeof y=="function"?y:si)}function i4(l,h,p,y,w){if(Bg(l))throw Error(n(485));if(l=h.action,l!==null){var I={payload:w,action:l,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function($){I.listeners.push($)}};W.T!==null?p(!0):I.isTransition=!1,y(I),p=h.pending,p===null?(I.next=h.pending=I,HN(h,I)):(I.next=p.next,h.pending=p.next=I)}}function HN(l,h){var p=h.action,y=h.payload,w=l.state;if(h.isTransition){var I=W.T,$={};W.T=$;try{var z=p(w,y),Y=W.S;Y!==null&&Y($,z),qN(l,h,z)}catch(he){Hx(l,h,he)}finally{W.T=I}}else try{I=p(w,y),qN(l,h,I)}catch(he){Hx(l,h,he)}}function qN(l,h,p){p!==null&&typeof p=="object"&&typeof p.then=="function"?p.then(function(y){jN(l,h,y)},function(y){return Hx(l,h,y)}):jN(l,h,p)}function jN(l,h,p){h.status="fulfilled",h.value=p,KN(h),l.state=p,h=l.pending,h!==null&&(p=h.next,p===h?l.pending=null:(p=p.next,h.next=p,HN(l,p)))}function Hx(l,h,p){var y=l.pending;if(l.pending=null,y!==null){y=y.next;do h.status="rejected",h.reason=p,KN(h),h=h.next;while(h!==y)}l.action=null}function KN(l){l=l.listeners;for(var h=0;h<l.length;h++)(0,l[h])()}function XN(l,h){return h}function YN(l,h){if(Dt){var p=sa.formState;if(p!==null){e:{var y=yt;if(Dt){if(wa){t:{for(var w=wa,I=Ss;w.nodeType!==8;){if(!I){w=null;break t}if(w=ns(w.nextSibling),w===null){w=null;break t}}I=w.data,w=I==="F!"||I==="F"?w:null}if(w){wa=ns(w.nextSibling),y=w.data==="F!";break e}}pl(y)}y=!1}y&&(h=p[0])}}return p=Zn(),p.memoizedState=p.baseState=h,y={pending:null,lanes:0,dispatch:null,lastRenderedReducer:XN,lastRenderedState:h},p.queue=y,p=mT.bind(null,yt,y),y.dispatch=p,y=Gx(!1),I=Yx.bind(null,yt,!1,y.queue),y=Zn(),w={state:h,dispatch:null,action:l,pending:null},y.queue=w,p=i4.bind(null,yt,w,I,p),w.dispatch=p,y.memoizedState=l,[h,p,!1]}function ZN(l){var h=La();return QN(h,Xt,l)}function QN(l,h,p){if(h=Wx(l,h,XN)[0],l=Og(si)[0],typeof h=="object"&&h!==null&&typeof h.then=="function")try{var y=Kp(h)}catch($){throw $===Wp?Ag:$}else y=h;h=La();var w=h.queue,I=w.dispatch;return p!==h.memoizedState&&(yt.flags|=2048,ad(9,zg(),o4.bind(null,w,p),null)),[y,I,l]}function o4(l,h){l.action=h}function JN(l){var h=La(),p=Xt;if(p!==null)return QN(h,p,l);La(),h=h.memoizedState,p=La();var y=p.queue.dispatch;return p.memoizedState=l,[h,y,!1]}function ad(l,h,p,y){return l={tag:l,create:p,deps:y,inst:h,next:null},h=yt.updateQueue,h===null&&(h=Ux(),yt.updateQueue=h),p=h.lastEffect,p===null?h.lastEffect=l.next=l:(y=p.next,p.next=l,l.next=y,h.lastEffect=l),l}function zg(){return{destroy:void 0,resource:void 0}}function eT(){return La().memoizedState}function Lg(l,h,p,y){var w=Zn();y=y===void 0?null:y,yt.flags|=l,w.memoizedState=ad(1|h,zg(),p,y)}function Xp(l,h,p,y){var w=La();y=y===void 0?null:y;var I=w.memoizedState.inst;Xt!==null&&y!==null&&Fx(y,Xt.memoizedState.deps)?w.memoizedState=ad(h,I,p,y):(yt.flags|=l,w.memoizedState=ad(1|h,I,p,y))}function tT(l,h){Lg(8390656,8,l,h)}function aT(l,h){Xp(2048,8,l,h)}function nT(l,h){return Xp(4,2,l,h)}function rT(l,h){return Xp(4,4,l,h)}function sT(l,h){if(typeof h=="function"){l=l();var p=h(l);return function(){typeof p=="function"?p():h(null)}}if(h!=null)return l=l(),h.current=l,function(){h.current=null}}function iT(l,h,p){p=p!=null?p.concat([l]):null,Xp(4,4,sT.bind(null,h,l),p)}function qx(){}function oT(l,h){var p=La();h=h===void 0?null:h;var y=p.memoizedState;return h!==null&&Fx(h,y[1])?y[0]:(p.memoizedState=[l,h],l)}function lT(l,h){var p=La();h=h===void 0?null:h;var y=p.memoizedState;if(h!==null&&Fx(h,y[1]))return y[0];if(y=l(),yl){ba(!0);try{l()}finally{ba(!1)}}return p.memoizedState=[y,h],y}function jx(l,h,p){return p===void 0||(Pi&1073741824)!==0?l.memoizedState=h:(l.memoizedState=p,l=d_(),yt.lanes|=l,Ki|=l,p)}function uT(l,h,p,y){return pr(p,h)?p:Jc.current!==null?(l=jx(l,p,y),pr(l,h)||(sn=!0),l):(Pi&42)===0?(sn=!0,l.memoizedState=p):(l=d_(),yt.lanes|=l,Ki|=l,h)}function cT(l,h,p,y,w){var I=X.p;X.p=I!==0&&8>I?I:8;var $=W.T,z={};W.T=z,Yx(l,!1,h,p);try{var Y=w(),he=W.S;if(he!==null&&he(z,Y),Y!==null&&typeof Y=="object"&&typeof Y.then=="function"){var xe=n4(Y,y);Yp(l,h,xe,br(l))}else Yp(l,h,y,br(l))}catch(Se){Yp(l,h,{then:function(){},status:"rejected",reason:Se},br())}finally{X.p=I,W.T=$}}function l4(){}function Kx(l,h,p,y){if(l.tag!==5)throw Error(n(476));var w=dT(l).queue;cT(l,w,h,Q,p===null?l4:function(){return hT(l),p(y)})}function dT(l){var h=l.memoizedState;if(h!==null)return h;h={memoizedState:Q,baseState:Q,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:si,lastRenderedState:Q},next:null};var p={};return h.next={memoizedState:p,baseState:p,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:si,lastRenderedState:p},next:null},l.memoizedState=h,l=l.alternate,l!==null&&(l.memoizedState=h),h}function hT(l){var h=dT(l).next.queue;Yp(l,h,{},br())}function Xx(){return kn(mf)}function pT(){return La().memoizedState}function fT(){return La().memoizedState}function u4(l){for(var h=l.return;h!==null;){switch(h.tag){case 24:case 3:var p=br();l=Bi(p);var y=Ui(h,l,p);y!==null&&(vr(y,h,p),Gp(y,h,p)),h={cache:Nx()},l.payload=h;return}h=h.return}}function c4(l,h,p){var y=br();p={lane:y,revertLane:0,action:p,hasEagerState:!1,eagerState:null,next:null},Bg(l)?gT(h,p):(p=mx(l,h,p,y),p!==null&&(vr(p,l,y),yT(p,h,y)))}function mT(l,h,p){var y=br();Yp(l,h,p,y)}function Yp(l,h,p,y){var w={lane:y,revertLane:0,action:p,hasEagerState:!1,eagerState:null,next:null};if(Bg(l))gT(h,w);else{var I=l.alternate;if(l.lanes===0&&(I===null||I.lanes===0)&&(I=h.lastRenderedReducer,I!==null))try{var $=h.lastRenderedState,z=I($,p);if(w.hasEagerState=!0,w.eagerState=z,pr(z,$))return kg(l,h,w,0),sa===null&&wg(),!1}catch{}finally{}if(p=mx(l,h,w,y),p!==null)return vr(p,l,y),yT(p,h,y),!0}return!1}function Yx(l,h,p,y){if(y={lane:2,revertLane:C0(),action:y,hasEagerState:!1,eagerState:null,next:null},Bg(l)){if(h)throw Error(n(479))}else h=mx(l,p,y,2),h!==null&&vr(h,l,2)}function Bg(l){var h=l.alternate;return l===yt||h!==null&&h===yt}function gT(l,h){ed=Dg=!0;var p=l.pending;p===null?h.next=h:(h.next=p.next,p.next=h),l.pending=h}function yT(l,h,p){if((p&4194048)!==0){var y=h.lanes;y&=l.pendingLanes,p|=y,h.lanes=p,tl(l,p)}}var Ug={readContext:kn,use:Fg,useCallback:Ta,useContext:Ta,useEffect:Ta,useImperativeHandle:Ta,useLayoutEffect:Ta,useInsertionEffect:Ta,useMemo:Ta,useReducer:Ta,useRef:Ta,useState:Ta,useDebugValue:Ta,useDeferredValue:Ta,useTransition:Ta,useSyncExternalStore:Ta,useId:Ta,useHostTransitionStatus:Ta,useFormState:Ta,useActionState:Ta,useOptimistic:Ta,useMemoCache:Ta,useCacheRefresh:Ta},bT={readContext:kn,use:Fg,useCallback:function(l,h){return Zn().memoizedState=[l,h===void 0?null:h],l},useContext:kn,useEffect:tT,useImperativeHandle:function(l,h,p){p=p!=null?p.concat([l]):null,Lg(4194308,4,sT.bind(null,h,l),p)},useLayoutEffect:function(l,h){return Lg(4194308,4,l,h)},useInsertionEffect:function(l,h){Lg(4,2,l,h)},useMemo:function(l,h){var p=Zn();h=h===void 0?null:h;var y=l();if(yl){ba(!0);try{l()}finally{ba(!1)}}return p.memoizedState=[y,h],y},useReducer:function(l,h,p){var y=Zn();if(p!==void 0){var w=p(h);if(yl){ba(!0);try{p(h)}finally{ba(!1)}}}else w=h;return y.memoizedState=y.baseState=w,l={pending:null,lanes:0,dispatch:null,lastRenderedReducer:l,lastRenderedState:w},y.queue=l,l=l.dispatch=c4.bind(null,yt,l),[y.memoizedState,l]},useRef:function(l){var h=Zn();return l={current:l},h.memoizedState=l},useState:function(l){l=Gx(l);var h=l.queue,p=mT.bind(null,yt,h);return h.dispatch=p,[l.memoizedState,p]},useDebugValue:qx,useDeferredValue:function(l,h){var p=Zn();return jx(p,l,h)},useTransition:function(){var l=Gx(!1);return l=cT.bind(null,yt,l.queue,!0,!1),Zn().memoizedState=l,[!1,l]},useSyncExternalStore:function(l,h,p){var y=yt,w=Zn();if(Dt){if(p===void 0)throw Error(n(407));p=p()}else{if(p=h(),sa===null)throw Error(n(349));(_t&124)!==0||BN(y,h,p)}w.memoizedState=p;var I={value:p,getSnapshot:h};return w.queue=I,tT(PN.bind(null,y,I,l),[l]),y.flags|=2048,ad(9,zg(),UN.bind(null,y,I,p,h),null),p},useId:function(){var l=Zn(),h=sa.identifierPrefix;if(Dt){var p=ai,y=ti;p=(y&~(1<<32-va(y)-1)).toString(32)+p,h=""+h+"R"+p,p=Mg++,0<p&&(h+="H"+p.toString(32)),h+=""}else p=r4++,h=""+h+"r"+p.toString(32)+"";return l.memoizedState=h},useHostTransitionStatus:Xx,useFormState:YN,useActionState:YN,useOptimistic:function(l){var h=Zn();h.memoizedState=h.baseState=l;var p={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return h.queue=p,h=Yx.bind(null,yt,!0,p),p.dispatch=h,[l,h]},useMemoCache:Px,useCacheRefresh:function(){return Zn().memoizedState=u4.bind(null,yt)}},vT={readContext:kn,use:Fg,useCallback:oT,useContext:kn,useEffect:aT,useImperativeHandle:iT,useInsertionEffect:nT,useLayoutEffect:rT,useMemo:lT,useReducer:Og,useRef:eT,useState:function(){return Og(si)},useDebugValue:qx,useDeferredValue:function(l,h){var p=La();return uT(p,Xt.memoizedState,l,h)},useTransition:function(){var l=Og(si)[0],h=La().memoizedState;return[typeof l=="boolean"?l:Kp(l),h]},useSyncExternalStore:LN,useId:pT,useHostTransitionStatus:Xx,useFormState:ZN,useActionState:ZN,useOptimistic:function(l,h){var p=La();return GN(p,Xt,l,h)},useMemoCache:Px,useCacheRefresh:fT},d4={readContext:kn,use:Fg,useCallback:oT,useContext:kn,useEffect:aT,useImperativeHandle:iT,useInsertionEffect:nT,useLayoutEffect:rT,useMemo:lT,useReducer:Vx,useRef:eT,useState:function(){return Vx(si)},useDebugValue:qx,useDeferredValue:function(l,h){var p=La();return Xt===null?jx(p,l,h):uT(p,Xt.memoizedState,l,h)},useTransition:function(){var l=Vx(si)[0],h=La().memoizedState;return[typeof l=="boolean"?l:Kp(l),h]},useSyncExternalStore:LN,useId:pT,useHostTransitionStatus:Xx,useFormState:JN,useActionState:JN,useOptimistic:function(l,h){var p=La();return Xt!==null?GN(p,Xt,l,h):(p.baseState=l,[l,p.queue.dispatch])},useMemoCache:Px,useCacheRefresh:fT},nd=null,Zp=0;function Pg(l){var h=Zp;return Zp+=1,nd===null&&(nd=[]),AN(nd,l,h)}function Qp(l,h){h=h.props.ref,l.ref=h!==void 0?h:null}function Wg(l,h){throw h.$$typeof===f?Error(n(525)):(l=Object.prototype.toString.call(h),Error(n(31,l==="[object Object]"?"object with keys {"+Object.keys(h).join(", ")+"}":l)))}function xT(l){var h=l._init;return h(l._payload)}function wT(l){function h(oe,re){if(l){var de=oe.deletions;de===null?(oe.deletions=[re],oe.flags|=16):de.push(re)}}function p(oe,re){if(!l)return null;for(;re!==null;)h(oe,re),re=re.sibling;return null}function y(oe){for(var re=new Map;oe!==null;)oe.key!==null?re.set(oe.key,oe):re.set(oe.index,oe),oe=oe.sibling;return re}function w(oe,re){return oe=ei(oe,re),oe.index=0,oe.sibling=null,oe}function I(oe,re,de){return oe.index=de,l?(de=oe.alternate,de!==null?(de=de.index,de<re?(oe.flags|=67108866,re):de):(oe.flags|=67108866,re)):(oe.flags|=1048576,re)}function $(oe){return l&&oe.alternate===null&&(oe.flags|=67108866),oe}function z(oe,re,de,we){return re===null||re.tag!==6?(re=yx(de,oe.mode,we),re.return=oe,re):(re=w(re,de),re.return=oe,re)}function Y(oe,re,de,we){var Ue=de.type;return Ue===b?xe(oe,re,de.props.children,we,de.key):re!==null&&(re.elementType===Ue||typeof Ue=="object"&&Ue!==null&&Ue.$$typeof===F&&xT(Ue)===re.type)?(re=w(re,de.props),Qp(re,de),re.return=oe,re):(re=Ig(de.type,de.key,de.props,null,oe.mode,we),Qp(re,de),re.return=oe,re)}function he(oe,re,de,we){return re===null||re.tag!==4||re.stateNode.containerInfo!==de.containerInfo||re.stateNode.implementation!==de.implementation?(re=bx(de,oe.mode,we),re.return=oe,re):(re=w(re,de.children||[]),re.return=oe,re)}function xe(oe,re,de,we,Ue){return re===null||re.tag!==7?(re=ul(de,oe.mode,we,Ue),re.return=oe,re):(re=w(re,de),re.return=oe,re)}function Se(oe,re,de){if(typeof re=="string"&&re!==""||typeof re=="number"||typeof re=="bigint")return re=yx(""+re,oe.mode,de),re.return=oe,re;if(typeof re=="object"&&re!==null){switch(re.$$typeof){case m:return de=Ig(re.type,re.key,re.props,null,oe.mode,de),Qp(de,re),de.return=oe,de;case g:return re=bx(re,oe.mode,de),re.return=oe,re;case F:var we=re._init;return re=we(re._payload),Se(oe,re,de)}if(ee(re)||A(re))return re=ul(re,oe.mode,de,null),re.return=oe,re;if(typeof re.then=="function")return Se(oe,Pg(re),de);if(re.$$typeof===N)return Se(oe,Cg(oe,re),de);Wg(oe,re)}return null}function fe(oe,re,de,we){var Ue=re!==null?re.key:null;if(typeof de=="string"&&de!==""||typeof de=="number"||typeof de=="bigint")return Ue!==null?null:z(oe,re,""+de,we);if(typeof de=="object"&&de!==null){switch(de.$$typeof){case m:return de.key===Ue?Y(oe,re,de,we):null;case g:return de.key===Ue?he(oe,re,de,we):null;case F:return Ue=de._init,de=Ue(de._payload),fe(oe,re,de,we)}if(ee(de)||A(de))return Ue!==null?null:xe(oe,re,de,we,null);if(typeof de.then=="function")return fe(oe,re,Pg(de),we);if(de.$$typeof===N)return fe(oe,re,Cg(oe,de),we);Wg(oe,de)}return null}function me(oe,re,de,we,Ue){if(typeof we=="string"&&we!==""||typeof we=="number"||typeof we=="bigint")return oe=oe.get(de)||null,z(re,oe,""+we,Ue);if(typeof we=="object"&&we!==null){switch(we.$$typeof){case m:return oe=oe.get(we.key===null?de:we.key)||null,Y(re,oe,we,Ue);case g:return oe=oe.get(we.key===null?de:we.key)||null,he(re,oe,we,Ue);case F:var vt=we._init;return we=vt(we._payload),me(oe,re,de,we,Ue)}if(ee(we)||A(we))return oe=oe.get(de)||null,xe(re,oe,we,Ue,null);if(typeof we.then=="function")return me(oe,re,de,Pg(we),Ue);if(we.$$typeof===N)return me(oe,re,de,Cg(re,we),Ue);Wg(re,we)}return null}function et(oe,re,de,we){for(var Ue=null,vt=null,He=re,Ze=re=0,ln=null;He!==null&&Ze<de.length;Ze++){He.index>Ze?(ln=He,He=null):ln=He.sibling;var Rt=fe(oe,He,de[Ze],we);if(Rt===null){He===null&&(He=ln);break}l&&He&&Rt.alternate===null&&h(oe,He),re=I(Rt,re,Ze),vt===null?Ue=Rt:vt.sibling=Rt,vt=Rt,He=ln}if(Ze===de.length)return p(oe,He),Dt&&dl(oe,Ze),Ue;if(He===null){for(;Ze<de.length;Ze++)He=Se(oe,de[Ze],we),He!==null&&(re=I(He,re,Ze),vt===null?Ue=He:vt.sibling=He,vt=He);return Dt&&dl(oe,Ze),Ue}for(He=y(He);Ze<de.length;Ze++)ln=me(He,oe,Ze,de[Ze],we),ln!==null&&(l&&ln.alternate!==null&&He.delete(ln.key===null?Ze:ln.key),re=I(ln,re,Ze),vt===null?Ue=ln:vt.sibling=ln,vt=ln);return l&&He.forEach(function(no){return h(oe,no)}),Dt&&dl(oe,Ze),Ue}function Xe(oe,re,de,we){if(de==null)throw Error(n(151));for(var Ue=null,vt=null,He=re,Ze=re=0,ln=null,Rt=de.next();He!==null&&!Rt.done;Ze++,Rt=de.next()){He.index>Ze?(ln=He,He=null):ln=He.sibling;var no=fe(oe,He,Rt.value,we);if(no===null){He===null&&(He=ln);break}l&&He&&no.alternate===null&&h(oe,He),re=I(no,re,Ze),vt===null?Ue=no:vt.sibling=no,vt=no,He=ln}if(Rt.done)return p(oe,He),Dt&&dl(oe,Ze),Ue;if(He===null){for(;!Rt.done;Ze++,Rt=de.next())Rt=Se(oe,Rt.value,we),Rt!==null&&(re=I(Rt,re,Ze),vt===null?Ue=Rt:vt.sibling=Rt,vt=Rt);return Dt&&dl(oe,Ze),Ue}for(He=y(He);!Rt.done;Ze++,Rt=de.next())Rt=me(He,oe,Ze,Rt.value,we),Rt!==null&&(l&&Rt.alternate!==null&&He.delete(Rt.key===null?Ze:Rt.key),re=I(Rt,re,Ze),vt===null?Ue=Rt:vt.sibling=Rt,vt=Rt);return l&&He.forEach(function(hU){return h(oe,hU)}),Dt&&dl(oe,Ze),Ue}function Zt(oe,re,de,we){if(typeof de=="object"&&de!==null&&de.type===b&&de.key===null&&(de=de.props.children),typeof de=="object"&&de!==null){switch(de.$$typeof){case m:e:{for(var Ue=de.key;re!==null;){if(re.key===Ue){if(Ue=de.type,Ue===b){if(re.tag===7){p(oe,re.sibling),we=w(re,de.props.children),we.return=oe,oe=we;break e}}else if(re.elementType===Ue||typeof Ue=="object"&&Ue!==null&&Ue.$$typeof===F&&xT(Ue)===re.type){p(oe,re.sibling),we=w(re,de.props),Qp(we,de),we.return=oe,oe=we;break e}p(oe,re);break}else h(oe,re);re=re.sibling}de.type===b?(we=ul(de.props.children,oe.mode,we,de.key),we.return=oe,oe=we):(we=Ig(de.type,de.key,de.props,null,oe.mode,we),Qp(we,de),we.return=oe,oe=we)}return $(oe);case g:e:{for(Ue=de.key;re!==null;){if(re.key===Ue)if(re.tag===4&&re.stateNode.containerInfo===de.containerInfo&&re.stateNode.implementation===de.implementation){p(oe,re.sibling),we=w(re,de.children||[]),we.return=oe,oe=we;break e}else{p(oe,re);break}else h(oe,re);re=re.sibling}we=bx(de,oe.mode,we),we.return=oe,oe=we}return $(oe);case F:return Ue=de._init,de=Ue(de._payload),Zt(oe,re,de,we)}if(ee(de))return et(oe,re,de,we);if(A(de)){if(Ue=A(de),typeof Ue!="function")throw Error(n(150));return de=Ue.call(de),Xe(oe,re,de,we)}if(typeof de.then=="function")return Zt(oe,re,Pg(de),we);if(de.$$typeof===N)return Zt(oe,re,Cg(oe,de),we);Wg(oe,de)}return typeof de=="string"&&de!==""||typeof de=="number"||typeof de=="bigint"?(de=""+de,re!==null&&re.tag===6?(p(oe,re.sibling),we=w(re,de),we.return=oe,oe=we):(p(oe,re),we=yx(de,oe.mode,we),we.return=oe,oe=we),$(oe)):p(oe,re)}return function(oe,re,de,we){try{Zp=0;var Ue=Zt(oe,re,de,we);return nd=null,Ue}catch(He){if(He===Wp||He===Ag)throw He;var vt=fr(29,He,null,oe.mode);return vt.lanes=we,vt.return=oe,vt}finally{}}}var rd=wT(!0),kT=wT(!1),Or=q(null),Is=null;function Wi(l){var h=l.alternate;se(qa,qa.current&1),se(Or,l),Is===null&&(h===null||Jc.current!==null||h.memoizedState!==null)&&(Is=l)}function ST(l){if(l.tag===22){if(se(qa,qa.current),se(Or,l),Is===null){var h=l.alternate;h!==null&&h.memoizedState!==null&&(Is=l)}}else Vi()}function Vi(){se(qa,qa.current),se(Or,Or.current)}function ii(l){le(Or),Is===l&&(Is=null),le(qa)}var qa=q(0);function Vg(l){for(var h=l;h!==null;){if(h.tag===13){var p=h.memoizedState;if(p!==null&&(p=p.dehydrated,p===null||p.data==="$?"||U0(p)))return h}else if(h.tag===19&&h.memoizedProps.revealOrder!==void 0){if((h.flags&128)!==0)return h}else if(h.child!==null){h.child.return=h,h=h.child;continue}if(h===l)break;for(;h.sibling===null;){if(h.return===null||h.return===l)return null;h=h.return}h.sibling.return=h.return,h=h.sibling}return null}function Zx(l,h,p,y){h=l.memoizedState,p=p(y,h),p=p==null?h:c({},h,p),l.memoizedState=p,l.lanes===0&&(l.updateQueue.baseState=p)}var Qx={enqueueSetState:function(l,h,p){l=l._reactInternals;var y=br(),w=Bi(y);w.payload=h,p!=null&&(w.callback=p),h=Ui(l,w,y),h!==null&&(vr(h,l,y),Gp(h,l,y))},enqueueReplaceState:function(l,h,p){l=l._reactInternals;var y=br(),w=Bi(y);w.tag=1,w.payload=h,p!=null&&(w.callback=p),h=Ui(l,w,y),h!==null&&(vr(h,l,y),Gp(h,l,y))},enqueueForceUpdate:function(l,h){l=l._reactInternals;var p=br(),y=Bi(p);y.tag=2,h!=null&&(y.callback=h),h=Ui(l,y,p),h!==null&&(vr(h,l,p),Gp(h,l,p))}};function IT(l,h,p,y,w,I,$){return l=l.stateNode,typeof l.shouldComponentUpdate=="function"?l.shouldComponentUpdate(y,I,$):h.prototype&&h.prototype.isPureReactComponent?!Mp(p,y)||!Mp(w,I):!0}function NT(l,h,p,y){l=h.state,typeof h.componentWillReceiveProps=="function"&&h.componentWillReceiveProps(p,y),typeof h.UNSAFE_componentWillReceiveProps=="function"&&h.UNSAFE_componentWillReceiveProps(p,y),h.state!==l&&Qx.enqueueReplaceState(h,h.state,null)}function bl(l,h){var p=h;if("ref"in h){p={};for(var y in h)y!=="ref"&&(p[y]=h[y])}if(l=l.defaultProps){p===h&&(p=c({},p));for(var w in l)p[w]===void 0&&(p[w]=l[w])}return p}var Gg=typeof reportError=="function"?reportError:function(l){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var h=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof l=="object"&&l!==null&&typeof l.message=="string"?String(l.message):String(l),error:l});if(!window.dispatchEvent(h))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",l);return}console.error(l)};function TT(l){Gg(l)}function _T(l){console.error(l)}function CT(l){Gg(l)}function Hg(l,h){try{var p=l.onUncaughtError;p(h.value,{componentStack:h.stack})}catch(y){setTimeout(function(){throw y})}}function ET(l,h,p){try{var y=l.onCaughtError;y(p.value,{componentStack:p.stack,errorBoundary:h.tag===1?h.stateNode:null})}catch(w){setTimeout(function(){throw w})}}function Jx(l,h,p){return p=Bi(p),p.tag=3,p.payload={element:null},p.callback=function(){Hg(l,h)},p}function AT(l){return l=Bi(l),l.tag=3,l}function $T(l,h,p,y){var w=p.type.getDerivedStateFromError;if(typeof w=="function"){var I=y.value;l.payload=function(){return w(I)},l.callback=function(){ET(h,p,y)}}var $=p.stateNode;$!==null&&typeof $.componentDidCatch=="function"&&(l.callback=function(){ET(h,p,y),typeof w!="function"&&(Xi===null?Xi=new Set([this]):Xi.add(this));var z=y.stack;this.componentDidCatch(y.value,{componentStack:z!==null?z:""})})}function h4(l,h,p,y,w){if(p.flags|=32768,y!==null&&typeof y=="object"&&typeof y.then=="function"){if(h=p.alternate,h!==null&&Bp(h,p,w,!0),p=Or.current,p!==null){switch(p.tag){case 13:return Is===null?S0():p.alternate===null&&ka===0&&(ka=3),p.flags&=-257,p.flags|=65536,p.lanes=w,y===Cx?p.flags|=16384:(h=p.updateQueue,h===null?p.updateQueue=new Set([y]):h.add(y),N0(l,y,w)),!1;case 22:return p.flags|=65536,y===Cx?p.flags|=16384:(h=p.updateQueue,h===null?(h={transitions:null,markerInstances:null,retryQueue:new Set([y])},p.updateQueue=h):(p=h.retryQueue,p===null?h.retryQueue=new Set([y]):p.add(y)),N0(l,y,w)),!1}throw Error(n(435,p.tag))}return N0(l,y,w),S0(),!1}if(Dt)return h=Or.current,h!==null?((h.flags&65536)===0&&(h.flags|=256),h.flags|=65536,h.lanes=w,y!==wx&&(l=Error(n(422),{cause:y}),Lp(Rr(l,p)))):(y!==wx&&(h=Error(n(423),{cause:y}),Lp(Rr(h,p))),l=l.current.alternate,l.flags|=65536,w&=-w,l.lanes|=w,y=Rr(y,p),w=Jx(l.stateNode,y,w),$x(l,w),ka!==4&&(ka=2)),!1;var I=Error(n(520),{cause:y});if(I=Rr(I,p),sf===null?sf=[I]:sf.push(I),ka!==4&&(ka=2),h===null)return!0;y=Rr(y,p),p=h;do{switch(p.tag){case 3:return p.flags|=65536,l=w&-w,p.lanes|=l,l=Jx(p.stateNode,y,l),$x(p,l),!1;case 1:if(h=p.type,I=p.stateNode,(p.flags&128)===0&&(typeof h.getDerivedStateFromError=="function"||I!==null&&typeof I.componentDidCatch=="function"&&(Xi===null||!Xi.has(I))))return p.flags|=65536,w&=-w,p.lanes|=w,w=AT(w),$T(w,l,p,y),$x(p,w),!1}p=p.return}while(p!==null);return!1}var RT=Error(n(461)),sn=!1;function fn(l,h,p,y){h.child=l===null?kT(h,null,p,y):rd(h,l.child,p,y)}function DT(l,h,p,y,w){p=p.render;var I=h.ref;if("ref"in y){var $={};for(var z in y)z!=="ref"&&($[z]=y[z])}else $=y;return ml(h),y=Ox(l,h,p,$,I,w),z=zx(),l!==null&&!sn?(Lx(l,h,w),oi(l,h,w)):(Dt&&z&&vx(h),h.flags|=1,fn(l,h,y,w),h.child)}function MT(l,h,p,y,w){if(l===null){var I=p.type;return typeof I=="function"&&!gx(I)&&I.defaultProps===void 0&&p.compare===null?(h.tag=15,h.type=I,FT(l,h,I,y,w)):(l=Ig(p.type,null,y,h,h.mode,w),l.ref=h.ref,l.return=h,h.child=l)}if(I=l.child,!o0(l,w)){var $=I.memoizedProps;if(p=p.compare,p=p!==null?p:Mp,p($,y)&&l.ref===h.ref)return oi(l,h,w)}return h.flags|=1,l=ei(I,y),l.ref=h.ref,l.return=h,h.child=l}function FT(l,h,p,y,w){if(l!==null){var I=l.memoizedProps;if(Mp(I,y)&&l.ref===h.ref)if(sn=!1,h.pendingProps=y=I,o0(l,w))(l.flags&131072)!==0&&(sn=!0);else return h.lanes=l.lanes,oi(l,h,w)}return e0(l,h,p,y,w)}function OT(l,h,p){var y=h.pendingProps,w=y.children,I=l!==null?l.memoizedState:null;if(y.mode==="hidden"){if((h.flags&128)!==0){if(y=I!==null?I.baseLanes|p:p,l!==null){for(w=h.child=l.child,I=0;w!==null;)I=I|w.lanes|w.childLanes,w=w.sibling;h.childLanes=I&~y}else h.childLanes=0,h.child=null;return zT(l,h,y,p)}if((p&536870912)!==0)h.memoizedState={baseLanes:0,cachePool:null},l!==null&&Eg(h,I!==null?I.cachePool:null),I!==null?FN(h,I):Dx(),ST(h);else return h.lanes=h.childLanes=536870912,zT(l,h,I!==null?I.baseLanes|p:p,p)}else I!==null?(Eg(h,I.cachePool),FN(h,I),Vi(),h.memoizedState=null):(l!==null&&Eg(h,null),Dx(),Vi());return fn(l,h,w,p),h.child}function zT(l,h,p,y){var w=_x();return w=w===null?null:{parent:Ha._currentValue,pool:w},h.memoizedState={baseLanes:p,cachePool:w},l!==null&&Eg(h,null),Dx(),ST(h),l!==null&&Bp(l,h,y,!0),null}function qg(l,h){var p=h.ref;if(p===null)l!==null&&l.ref!==null&&(h.flags|=4194816);else{if(typeof p!="function"&&typeof p!="object")throw Error(n(284));(l===null||l.ref!==p)&&(h.flags|=4194816)}}function e0(l,h,p,y,w){return ml(h),p=Ox(l,h,p,y,void 0,w),y=zx(),l!==null&&!sn?(Lx(l,h,w),oi(l,h,w)):(Dt&&y&&vx(h),h.flags|=1,fn(l,h,p,w),h.child)}function LT(l,h,p,y,w,I){return ml(h),h.updateQueue=null,p=zN(h,y,p,w),ON(l),y=zx(),l!==null&&!sn?(Lx(l,h,I),oi(l,h,I)):(Dt&&y&&vx(h),h.flags|=1,fn(l,h,p,I),h.child)}function BT(l,h,p,y,w){if(ml(h),h.stateNode===null){var I=Kc,$=p.contextType;typeof $=="object"&&$!==null&&(I=kn($)),I=new p(y,I),h.memoizedState=I.state!==null&&I.state!==void 0?I.state:null,I.updater=Qx,h.stateNode=I,I._reactInternals=h,I=h.stateNode,I.props=y,I.state=h.memoizedState,I.refs={},Ex(h),$=p.contextType,I.context=typeof $=="object"&&$!==null?kn($):Kc,I.state=h.memoizedState,$=p.getDerivedStateFromProps,typeof $=="function"&&(Zx(h,p,$,y),I.state=h.memoizedState),typeof p.getDerivedStateFromProps=="function"||typeof I.getSnapshotBeforeUpdate=="function"||typeof I.UNSAFE_componentWillMount!="function"&&typeof I.componentWillMount!="function"||($=I.state,typeof I.componentWillMount=="function"&&I.componentWillMount(),typeof I.UNSAFE_componentWillMount=="function"&&I.UNSAFE_componentWillMount(),$!==I.state&&Qx.enqueueReplaceState(I,I.state,null),qp(h,y,I,w),Hp(),I.state=h.memoizedState),typeof I.componentDidMount=="function"&&(h.flags|=4194308),y=!0}else if(l===null){I=h.stateNode;var z=h.memoizedProps,Y=bl(p,z);I.props=Y;var he=I.context,xe=p.contextType;$=Kc,typeof xe=="object"&&xe!==null&&($=kn(xe));var Se=p.getDerivedStateFromProps;xe=typeof Se=="function"||typeof I.getSnapshotBeforeUpdate=="function",z=h.pendingProps!==z,xe||typeof I.UNSAFE_componentWillReceiveProps!="function"&&typeof I.componentWillReceiveProps!="function"||(z||he!==$)&&NT(h,I,y,$),Li=!1;var fe=h.memoizedState;I.state=fe,qp(h,y,I,w),Hp(),he=h.memoizedState,z||fe!==he||Li?(typeof Se=="function"&&(Zx(h,p,Se,y),he=h.memoizedState),(Y=Li||IT(h,p,Y,y,fe,he,$))?(xe||typeof I.UNSAFE_componentWillMount!="function"&&typeof I.componentWillMount!="function"||(typeof I.componentWillMount=="function"&&I.componentWillMount(),typeof I.UNSAFE_componentWillMount=="function"&&I.UNSAFE_componentWillMount()),typeof I.componentDidMount=="function"&&(h.flags|=4194308)):(typeof I.componentDidMount=="function"&&(h.flags|=4194308),h.memoizedProps=y,h.memoizedState=he),I.props=y,I.state=he,I.context=$,y=Y):(typeof I.componentDidMount=="function"&&(h.flags|=4194308),y=!1)}else{I=h.stateNode,Ax(l,h),$=h.memoizedProps,xe=bl(p,$),I.props=xe,Se=h.pendingProps,fe=I.context,he=p.contextType,Y=Kc,typeof he=="object"&&he!==null&&(Y=kn(he)),z=p.getDerivedStateFromProps,(he=typeof z=="function"||typeof I.getSnapshotBeforeUpdate=="function")||typeof I.UNSAFE_componentWillReceiveProps!="function"&&typeof I.componentWillReceiveProps!="function"||($!==Se||fe!==Y)&&NT(h,I,y,Y),Li=!1,fe=h.memoizedState,I.state=fe,qp(h,y,I,w),Hp();var me=h.memoizedState;$!==Se||fe!==me||Li||l!==null&&l.dependencies!==null&&_g(l.dependencies)?(typeof z=="function"&&(Zx(h,p,z,y),me=h.memoizedState),(xe=Li||IT(h,p,xe,y,fe,me,Y)||l!==null&&l.dependencies!==null&&_g(l.dependencies))?(he||typeof I.UNSAFE_componentWillUpdate!="function"&&typeof I.componentWillUpdate!="function"||(typeof I.componentWillUpdate=="function"&&I.componentWillUpdate(y,me,Y),typeof I.UNSAFE_componentWillUpdate=="function"&&I.UNSAFE_componentWillUpdate(y,me,Y)),typeof I.componentDidUpdate=="function"&&(h.flags|=4),typeof I.getSnapshotBeforeUpdate=="function"&&(h.flags|=1024)):(typeof I.componentDidUpdate!="function"||$===l.memoizedProps&&fe===l.memoizedState||(h.flags|=4),typeof I.getSnapshotBeforeUpdate!="function"||$===l.memoizedProps&&fe===l.memoizedState||(h.flags|=1024),h.memoizedProps=y,h.memoizedState=me),I.props=y,I.state=me,I.context=Y,y=xe):(typeof I.componentDidUpdate!="function"||$===l.memoizedProps&&fe===l.memoizedState||(h.flags|=4),typeof I.getSnapshotBeforeUpdate!="function"||$===l.memoizedProps&&fe===l.memoizedState||(h.flags|=1024),y=!1)}return I=y,qg(l,h),y=(h.flags&128)!==0,I||y?(I=h.stateNode,p=y&&typeof p.getDerivedStateFromError!="function"?null:I.render(),h.flags|=1,l!==null&&y?(h.child=rd(h,l.child,null,w),h.child=rd(h,null,p,w)):fn(l,h,p,w),h.memoizedState=I.state,l=h.child):l=oi(l,h,w),l}function UT(l,h,p,y){return zp(),h.flags|=256,fn(l,h,p,y),h.child}var t0={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function a0(l){return{baseLanes:l,cachePool:_N()}}function n0(l,h,p){return l=l!==null?l.childLanes&~p:0,h&&(l|=zr),l}function PT(l,h,p){var y=h.pendingProps,w=!1,I=(h.flags&128)!==0,$;if(($=I)||($=l!==null&&l.memoizedState===null?!1:(qa.current&2)!==0),$&&(w=!0,h.flags&=-129),$=(h.flags&32)!==0,h.flags&=-33,l===null){if(Dt){if(w?Wi(h):Vi(),Dt){var z=wa,Y;if(Y=z){e:{for(Y=z,z=Ss;Y.nodeType!==8;){if(!z){z=null;break e}if(Y=ns(Y.nextSibling),Y===null){z=null;break e}}z=Y}z!==null?(h.memoizedState={dehydrated:z,treeContext:cl!==null?{id:ti,overflow:ai}:null,retryLane:536870912,hydrationErrors:null},Y=fr(18,null,null,0),Y.stateNode=z,Y.return=h,h.child=Y,Bn=h,wa=null,Y=!0):Y=!1}Y||pl(h)}if(z=h.memoizedState,z!==null&&(z=z.dehydrated,z!==null))return U0(z)?h.lanes=32:h.lanes=536870912,null;ii(h)}return z=y.children,y=y.fallback,w?(Vi(),w=h.mode,z=jg({mode:"hidden",children:z},w),y=ul(y,w,p,null),z.return=h,y.return=h,z.sibling=y,h.child=z,w=h.child,w.memoizedState=a0(p),w.childLanes=n0(l,$,p),h.memoizedState=t0,y):(Wi(h),r0(h,z))}if(Y=l.memoizedState,Y!==null&&(z=Y.dehydrated,z!==null)){if(I)h.flags&256?(Wi(h),h.flags&=-257,h=s0(l,h,p)):h.memoizedState!==null?(Vi(),h.child=l.child,h.flags|=128,h=null):(Vi(),w=y.fallback,z=h.mode,y=jg({mode:"visible",children:y.children},z),w=ul(w,z,p,null),w.flags|=2,y.return=h,w.return=h,y.sibling=w,h.child=y,rd(h,l.child,null,p),y=h.child,y.memoizedState=a0(p),y.childLanes=n0(l,$,p),h.memoizedState=t0,h=w);else if(Wi(h),U0(z)){if($=z.nextSibling&&z.nextSibling.dataset,$)var he=$.dgst;$=he,y=Error(n(419)),y.stack="",y.digest=$,Lp({value:y,source:null,stack:null}),h=s0(l,h,p)}else if(sn||Bp(l,h,p,!1),$=(p&l.childLanes)!==0,sn||$){if($=sa,$!==null&&(y=p&-p,y=(y&42)!==0?1:ye(y),y=(y&($.suspendedLanes|p))!==0?0:y,y!==0&&y!==Y.retryLane))throw Y.retryLane=y,jc(l,y),vr($,l,y),RT;z.data==="$?"||S0(),h=s0(l,h,p)}else z.data==="$?"?(h.flags|=192,h.child=l.child,h=null):(l=Y.treeContext,wa=ns(z.nextSibling),Bn=h,Dt=!0,hl=null,Ss=!1,l!==null&&(Mr[Fr++]=ti,Mr[Fr++]=ai,Mr[Fr++]=cl,ti=l.id,ai=l.overflow,cl=h),h=r0(h,y.children),h.flags|=4096);return h}return w?(Vi(),w=y.fallback,z=h.mode,Y=l.child,he=Y.sibling,y=ei(Y,{mode:"hidden",children:y.children}),y.subtreeFlags=Y.subtreeFlags&65011712,he!==null?w=ei(he,w):(w=ul(w,z,p,null),w.flags|=2),w.return=h,y.return=h,y.sibling=w,h.child=y,y=w,w=h.child,z=l.child.memoizedState,z===null?z=a0(p):(Y=z.cachePool,Y!==null?(he=Ha._currentValue,Y=Y.parent!==he?{parent:he,pool:he}:Y):Y=_N(),z={baseLanes:z.baseLanes|p,cachePool:Y}),w.memoizedState=z,w.childLanes=n0(l,$,p),h.memoizedState=t0,y):(Wi(h),p=l.child,l=p.sibling,p=ei(p,{mode:"visible",children:y.children}),p.return=h,p.sibling=null,l!==null&&($=h.deletions,$===null?(h.deletions=[l],h.flags|=16):$.push(l)),h.child=p,h.memoizedState=null,p)}function r0(l,h){return h=jg({mode:"visible",children:h},l.mode),h.return=l,l.child=h}function jg(l,h){return l=fr(22,l,null,h),l.lanes=0,l.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},l}function s0(l,h,p){return rd(h,l.child,null,p),l=r0(h,h.pendingProps.children),l.flags|=2,h.memoizedState=null,l}function WT(l,h,p){l.lanes|=h;var y=l.alternate;y!==null&&(y.lanes|=h),Sx(l.return,h,p)}function i0(l,h,p,y,w){var I=l.memoizedState;I===null?l.memoizedState={isBackwards:h,rendering:null,renderingStartTime:0,last:y,tail:p,tailMode:w}:(I.isBackwards=h,I.rendering=null,I.renderingStartTime=0,I.last=y,I.tail=p,I.tailMode=w)}function VT(l,h,p){var y=h.pendingProps,w=y.revealOrder,I=y.tail;if(fn(l,h,y.children,p),y=qa.current,(y&2)!==0)y=y&1|2,h.flags|=128;else{if(l!==null&&(l.flags&128)!==0)e:for(l=h.child;l!==null;){if(l.tag===13)l.memoizedState!==null&&WT(l,p,h);else if(l.tag===19)WT(l,p,h);else if(l.child!==null){l.child.return=l,l=l.child;continue}if(l===h)break e;for(;l.sibling===null;){if(l.return===null||l.return===h)break e;l=l.return}l.sibling.return=l.return,l=l.sibling}y&=1}switch(se(qa,y),w){case"forwards":for(p=h.child,w=null;p!==null;)l=p.alternate,l!==null&&Vg(l)===null&&(w=p),p=p.sibling;p=w,p===null?(w=h.child,h.child=null):(w=p.sibling,p.sibling=null),i0(h,!1,w,p,I);break;case"backwards":for(p=null,w=h.child,h.child=null;w!==null;){if(l=w.alternate,l!==null&&Vg(l)===null){h.child=w;break}l=w.sibling,w.sibling=p,p=w,w=l}i0(h,!0,p,null,I);break;case"together":i0(h,!1,null,null,void 0);break;default:h.memoizedState=null}return h.child}function oi(l,h,p){if(l!==null&&(h.dependencies=l.dependencies),Ki|=h.lanes,(p&h.childLanes)===0)if(l!==null){if(Bp(l,h,p,!1),(p&h.childLanes)===0)return null}else return null;if(l!==null&&h.child!==l.child)throw Error(n(153));if(h.child!==null){for(l=h.child,p=ei(l,l.pendingProps),h.child=p,p.return=h;l.sibling!==null;)l=l.sibling,p=p.sibling=ei(l,l.pendingProps),p.return=h;p.sibling=null}return h.child}function o0(l,h){return(l.lanes&h)!==0?!0:(l=l.dependencies,!!(l!==null&&_g(l)))}function p4(l,h,p){switch(h.tag){case 3:Ne(h,h.stateNode.containerInfo),zi(h,Ha,l.memoizedState.cache),zp();break;case 27:case 5:je(h);break;case 4:Ne(h,h.stateNode.containerInfo);break;case 10:zi(h,h.type,h.memoizedProps.value);break;case 13:var y=h.memoizedState;if(y!==null)return y.dehydrated!==null?(Wi(h),h.flags|=128,null):(p&h.child.childLanes)!==0?PT(l,h,p):(Wi(h),l=oi(l,h,p),l!==null?l.sibling:null);Wi(h);break;case 19:var w=(l.flags&128)!==0;if(y=(p&h.childLanes)!==0,y||(Bp(l,h,p,!1),y=(p&h.childLanes)!==0),w){if(y)return VT(l,h,p);h.flags|=128}if(w=h.memoizedState,w!==null&&(w.rendering=null,w.tail=null,w.lastEffect=null),se(qa,qa.current),y)break;return null;case 22:case 23:return h.lanes=0,OT(l,h,p);case 24:zi(h,Ha,l.memoizedState.cache)}return oi(l,h,p)}function GT(l,h,p){if(l!==null)if(l.memoizedProps!==h.pendingProps)sn=!0;else{if(!o0(l,p)&&(h.flags&128)===0)return sn=!1,p4(l,h,p);sn=(l.flags&131072)!==0}else sn=!1,Dt&&(h.flags&1048576)!==0&&xN(h,Tg,h.index);switch(h.lanes=0,h.tag){case 16:e:{l=h.pendingProps;var y=h.elementType,w=y._init;if(y=w(y._payload),h.type=y,typeof y=="function")gx(y)?(l=bl(y,l),h.tag=1,h=BT(null,h,y,l,p)):(h.tag=0,h=e0(null,h,y,l,p));else{if(y!=null){if(w=y.$$typeof,w===T){h.tag=11,h=DT(null,h,y,l,p);break e}else if(w===M){h.tag=14,h=MT(null,h,y,l,p);break e}}throw h=J(y)||y,Error(n(306,h,""))}}return h;case 0:return e0(l,h,h.type,h.pendingProps,p);case 1:return y=h.type,w=bl(y,h.pendingProps),BT(l,h,y,w,p);case 3:e:{if(Ne(h,h.stateNode.containerInfo),l===null)throw Error(n(387));y=h.pendingProps;var I=h.memoizedState;w=I.element,Ax(l,h),qp(h,y,null,p);var $=h.memoizedState;if(y=$.cache,zi(h,Ha,y),y!==I.cache&&Ix(h,[Ha],p,!0),Hp(),y=$.element,I.isDehydrated)if(I={element:y,isDehydrated:!1,cache:$.cache},h.updateQueue.baseState=I,h.memoizedState=I,h.flags&256){h=UT(l,h,y,p);break e}else if(y!==w){w=Rr(Error(n(424)),h),Lp(w),h=UT(l,h,y,p);break e}else{switch(l=h.stateNode.containerInfo,l.nodeType){case 9:l=l.body;break;default:l=l.nodeName==="HTML"?l.ownerDocument.body:l}for(wa=ns(l.firstChild),Bn=h,Dt=!0,hl=null,Ss=!0,p=kT(h,null,y,p),h.child=p;p;)p.flags=p.flags&-3|4096,p=p.sibling}else{if(zp(),y===w){h=oi(l,h,p);break e}fn(l,h,y,p)}h=h.child}return h;case 26:return qg(l,h),l===null?(p=K_(h.type,null,h.pendingProps,null))?h.memoizedState=p:Dt||(p=h.type,l=h.pendingProps,y=oy(Ie.current).createElement(p),y[dt]=h,y[qe]=l,gn(y,p,l),xa(y),h.stateNode=y):h.memoizedState=K_(h.type,l.memoizedProps,h.pendingProps,l.memoizedState),null;case 27:return je(h),l===null&&Dt&&(y=h.stateNode=H_(h.type,h.pendingProps,Ie.current),Bn=h,Ss=!0,w=wa,Qi(h.type)?(P0=w,wa=ns(y.firstChild)):wa=w),fn(l,h,h.pendingProps.children,p),qg(l,h),l===null&&(h.flags|=4194304),h.child;case 5:return l===null&&Dt&&((w=y=wa)&&(y=P4(y,h.type,h.pendingProps,Ss),y!==null?(h.stateNode=y,Bn=h,wa=ns(y.firstChild),Ss=!1,w=!0):w=!1),w||pl(h)),je(h),w=h.type,I=h.pendingProps,$=l!==null?l.memoizedProps:null,y=I.children,z0(w,I)?y=null:$!==null&&z0(w,$)&&(h.flags|=32),h.memoizedState!==null&&(w=Ox(l,h,s4,null,null,p),mf._currentValue=w),qg(l,h),fn(l,h,y,p),h.child;case 6:return l===null&&Dt&&((l=p=wa)&&(p=W4(p,h.pendingProps,Ss),p!==null?(h.stateNode=p,Bn=h,wa=null,l=!0):l=!1),l||pl(h)),null;case 13:return PT(l,h,p);case 4:return Ne(h,h.stateNode.containerInfo),y=h.pendingProps,l===null?h.child=rd(h,null,y,p):fn(l,h,y,p),h.child;case 11:return DT(l,h,h.type,h.pendingProps,p);case 7:return fn(l,h,h.pendingProps,p),h.child;case 8:return fn(l,h,h.pendingProps.children,p),h.child;case 12:return fn(l,h,h.pendingProps.children,p),h.child;case 10:return y=h.pendingProps,zi(h,h.type,y.value),fn(l,h,y.children,p),h.child;case 9:return w=h.type._context,y=h.pendingProps.children,ml(h),w=kn(w),y=y(w),h.flags|=1,fn(l,h,y,p),h.child;case 14:return MT(l,h,h.type,h.pendingProps,p);case 15:return FT(l,h,h.type,h.pendingProps,p);case 19:return VT(l,h,p);case 31:return y=h.pendingProps,p=h.mode,y={mode:y.mode,children:y.children},l===null?(p=jg(y,p),p.ref=h.ref,h.child=p,p.return=h,h=p):(p=ei(l.child,y),p.ref=h.ref,h.child=p,p.return=h,h=p),h;case 22:return OT(l,h,p);case 24:return ml(h),y=kn(Ha),l===null?(w=_x(),w===null&&(w=sa,I=Nx(),w.pooledCache=I,I.refCount++,I!==null&&(w.pooledCacheLanes|=p),w=I),h.memoizedState={parent:y,cache:w},Ex(h),zi(h,Ha,w)):((l.lanes&p)!==0&&(Ax(l,h),qp(h,null,null,p),Hp()),w=l.memoizedState,I=h.memoizedState,w.parent!==y?(w={parent:y,cache:y},h.memoizedState=w,h.lanes===0&&(h.memoizedState=h.updateQueue.baseState=w),zi(h,Ha,y)):(y=I.cache,zi(h,Ha,y),y!==w.cache&&Ix(h,[Ha],p,!0))),fn(l,h,h.pendingProps.children,p),h.child;case 29:throw h.pendingProps}throw Error(n(156,h.tag))}function li(l){l.flags|=4}function HT(l,h){if(h.type!=="stylesheet"||(h.state.loading&4)!==0)l.flags&=-16777217;else if(l.flags|=16777216,!J_(h)){if(h=Or.current,h!==null&&((_t&4194048)===_t?Is!==null:(_t&62914560)!==_t&&(_t&536870912)===0||h!==Is))throw Vp=Cx,CN;l.flags|=8192}}function Kg(l,h){h!==null&&(l.flags|=4),l.flags&16384&&(h=l.tag!==22?Er():536870912,l.lanes|=h,ld|=h)}function Jp(l,h){if(!Dt)switch(l.tailMode){case"hidden":h=l.tail;for(var p=null;h!==null;)h.alternate!==null&&(p=h),h=h.sibling;p===null?l.tail=null:p.sibling=null;break;case"collapsed":p=l.tail;for(var y=null;p!==null;)p.alternate!==null&&(y=p),p=p.sibling;y===null?h||l.tail===null?l.tail=null:l.tail.sibling=null:y.sibling=null}}function ma(l){var h=l.alternate!==null&&l.alternate.child===l.child,p=0,y=0;if(h)for(var w=l.child;w!==null;)p|=w.lanes|w.childLanes,y|=w.subtreeFlags&65011712,y|=w.flags&65011712,w.return=l,w=w.sibling;else for(w=l.child;w!==null;)p|=w.lanes|w.childLanes,y|=w.subtreeFlags,y|=w.flags,w.return=l,w=w.sibling;return l.subtreeFlags|=y,l.childLanes=p,h}function f4(l,h,p){var y=h.pendingProps;switch(xx(h),h.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ma(h),null;case 1:return ma(h),null;case 3:return p=h.stateNode,y=null,l!==null&&(y=l.memoizedState.cache),h.memoizedState.cache!==y&&(h.flags|=2048),ri(Ha),Le(),p.pendingContext&&(p.context=p.pendingContext,p.pendingContext=null),(l===null||l.child===null)&&(Op(h)?li(h):l===null||l.memoizedState.isDehydrated&&(h.flags&256)===0||(h.flags|=1024,SN())),ma(h),null;case 26:return p=h.memoizedState,l===null?(li(h),p!==null?(ma(h),HT(h,p)):(ma(h),h.flags&=-16777217)):p?p!==l.memoizedState?(li(h),ma(h),HT(h,p)):(ma(h),h.flags&=-16777217):(l.memoizedProps!==y&&li(h),ma(h),h.flags&=-16777217),null;case 27:Je(h),p=Ie.current;var w=h.type;if(l!==null&&h.stateNode!=null)l.memoizedProps!==y&&li(h);else{if(!y){if(h.stateNode===null)throw Error(n(166));return ma(h),null}l=pe.current,Op(h)?wN(h):(l=H_(w,y,p),h.stateNode=l,li(h))}return ma(h),null;case 5:if(Je(h),p=h.type,l!==null&&h.stateNode!=null)l.memoizedProps!==y&&li(h);else{if(!y){if(h.stateNode===null)throw Error(n(166));return ma(h),null}if(l=pe.current,Op(h))wN(h);else{switch(w=oy(Ie.current),l){case 1:l=w.createElementNS("http://www.w3.org/2000/svg",p);break;case 2:l=w.createElementNS("http://www.w3.org/1998/Math/MathML",p);break;default:switch(p){case"svg":l=w.createElementNS("http://www.w3.org/2000/svg",p);break;case"math":l=w.createElementNS("http://www.w3.org/1998/Math/MathML",p);break;case"script":l=w.createElement("div"),l.innerHTML="<script><\/script>",l=l.removeChild(l.firstChild);break;case"select":l=typeof y.is=="string"?w.createElement("select",{is:y.is}):w.createElement("select"),y.multiple?l.multiple=!0:y.size&&(l.size=y.size);break;default:l=typeof y.is=="string"?w.createElement(p,{is:y.is}):w.createElement(p)}}l[dt]=h,l[qe]=y;e:for(w=h.child;w!==null;){if(w.tag===5||w.tag===6)l.appendChild(w.stateNode);else if(w.tag!==4&&w.tag!==27&&w.child!==null){w.child.return=w,w=w.child;continue}if(w===h)break e;for(;w.sibling===null;){if(w.return===null||w.return===h)break e;w=w.return}w.sibling.return=w.return,w=w.sibling}h.stateNode=l;e:switch(gn(l,p,y),p){case"button":case"input":case"select":case"textarea":l=!!y.autoFocus;break e;case"img":l=!0;break e;default:l=!1}l&&li(h)}}return ma(h),h.flags&=-16777217,null;case 6:if(l&&h.stateNode!=null)l.memoizedProps!==y&&li(h);else{if(typeof y!="string"&&h.stateNode===null)throw Error(n(166));if(l=Ie.current,Op(h)){if(l=h.stateNode,p=h.memoizedProps,y=null,w=Bn,w!==null)switch(w.tag){case 27:case 5:y=w.memoizedProps}l[dt]=h,l=!!(l.nodeValue===p||y!==null&&y.suppressHydrationWarning===!0||L_(l.nodeValue,p)),l||pl(h)}else l=oy(l).createTextNode(y),l[dt]=h,h.stateNode=l}return ma(h),null;case 13:if(y=h.memoizedState,l===null||l.memoizedState!==null&&l.memoizedState.dehydrated!==null){if(w=Op(h),y!==null&&y.dehydrated!==null){if(l===null){if(!w)throw Error(n(318));if(w=h.memoizedState,w=w!==null?w.dehydrated:null,!w)throw Error(n(317));w[dt]=h}else zp(),(h.flags&128)===0&&(h.memoizedState=null),h.flags|=4;ma(h),w=!1}else w=SN(),l!==null&&l.memoizedState!==null&&(l.memoizedState.hydrationErrors=w),w=!0;if(!w)return h.flags&256?(ii(h),h):(ii(h),null)}if(ii(h),(h.flags&128)!==0)return h.lanes=p,h;if(p=y!==null,l=l!==null&&l.memoizedState!==null,p){y=h.child,w=null,y.alternate!==null&&y.alternate.memoizedState!==null&&y.alternate.memoizedState.cachePool!==null&&(w=y.alternate.memoizedState.cachePool.pool);var I=null;y.memoizedState!==null&&y.memoizedState.cachePool!==null&&(I=y.memoizedState.cachePool.pool),I!==w&&(y.flags|=2048)}return p!==l&&p&&(h.child.flags|=8192),Kg(h,h.updateQueue),ma(h),null;case 4:return Le(),l===null&&R0(h.stateNode.containerInfo),ma(h),null;case 10:return ri(h.type),ma(h),null;case 19:if(le(qa),w=h.memoizedState,w===null)return ma(h),null;if(y=(h.flags&128)!==0,I=w.rendering,I===null)if(y)Jp(w,!1);else{if(ka!==0||l!==null&&(l.flags&128)!==0)for(l=h.child;l!==null;){if(I=Vg(l),I!==null){for(h.flags|=128,Jp(w,!1),l=I.updateQueue,h.updateQueue=l,Kg(h,l),h.subtreeFlags=0,l=p,p=h.child;p!==null;)vN(p,l),p=p.sibling;return se(qa,qa.current&1|2),h.child}l=l.sibling}w.tail!==null&&ot()>Zg&&(h.flags|=128,y=!0,Jp(w,!1),h.lanes=4194304)}else{if(!y)if(l=Vg(I),l!==null){if(h.flags|=128,y=!0,l=l.updateQueue,h.updateQueue=l,Kg(h,l),Jp(w,!0),w.tail===null&&w.tailMode==="hidden"&&!I.alternate&&!Dt)return ma(h),null}else 2*ot()-w.renderingStartTime>Zg&&p!==536870912&&(h.flags|=128,y=!0,Jp(w,!1),h.lanes=4194304);w.isBackwards?(I.sibling=h.child,h.child=I):(l=w.last,l!==null?l.sibling=I:h.child=I,w.last=I)}return w.tail!==null?(h=w.tail,w.rendering=h,w.tail=h.sibling,w.renderingStartTime=ot(),h.sibling=null,l=qa.current,se(qa,y?l&1|2:l&1),h):(ma(h),null);case 22:case 23:return ii(h),Mx(),y=h.memoizedState!==null,l!==null?l.memoizedState!==null!==y&&(h.flags|=8192):y&&(h.flags|=8192),y?(p&536870912)!==0&&(h.flags&128)===0&&(ma(h),h.subtreeFlags&6&&(h.flags|=8192)):ma(h),p=h.updateQueue,p!==null&&Kg(h,p.retryQueue),p=null,l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(p=l.memoizedState.cachePool.pool),y=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(y=h.memoizedState.cachePool.pool),y!==p&&(h.flags|=2048),l!==null&&le(gl),null;case 24:return p=null,l!==null&&(p=l.memoizedState.cache),h.memoizedState.cache!==p&&(h.flags|=2048),ri(Ha),ma(h),null;case 25:return null;case 30:return null}throw Error(n(156,h.tag))}function m4(l,h){switch(xx(h),h.tag){case 1:return l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 3:return ri(Ha),Le(),l=h.flags,(l&65536)!==0&&(l&128)===0?(h.flags=l&-65537|128,h):null;case 26:case 27:case 5:return Je(h),null;case 13:if(ii(h),l=h.memoizedState,l!==null&&l.dehydrated!==null){if(h.alternate===null)throw Error(n(340));zp()}return l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 19:return le(qa),null;case 4:return Le(),null;case 10:return ri(h.type),null;case 22:case 23:return ii(h),Mx(),l!==null&&le(gl),l=h.flags,l&65536?(h.flags=l&-65537|128,h):null;case 24:return ri(Ha),null;case 25:return null;default:return null}}function qT(l,h){switch(xx(h),h.tag){case 3:ri(Ha),Le();break;case 26:case 27:case 5:Je(h);break;case 4:Le();break;case 13:ii(h);break;case 19:le(qa);break;case 10:ri(h.type);break;case 22:case 23:ii(h),Mx(),l!==null&&le(gl);break;case 24:ri(Ha)}}function ef(l,h){try{var p=h.updateQueue,y=p!==null?p.lastEffect:null;if(y!==null){var w=y.next;p=w;do{if((p.tag&l)===l){y=void 0;var I=p.create,$=p.inst;y=I(),$.destroy=y}p=p.next}while(p!==w)}}catch(z){Jt(h,h.return,z)}}function Gi(l,h,p){try{var y=h.updateQueue,w=y!==null?y.lastEffect:null;if(w!==null){var I=w.next;y=I;do{if((y.tag&l)===l){var $=y.inst,z=$.destroy;if(z!==void 0){$.destroy=void 0,w=h;var Y=p,he=z;try{he()}catch(xe){Jt(w,Y,xe)}}}y=y.next}while(y!==I)}}catch(xe){Jt(h,h.return,xe)}}function jT(l){var h=l.updateQueue;if(h!==null){var p=l.stateNode;try{MN(h,p)}catch(y){Jt(l,l.return,y)}}}function KT(l,h,p){p.props=bl(l.type,l.memoizedProps),p.state=l.memoizedState;try{p.componentWillUnmount()}catch(y){Jt(l,h,y)}}function tf(l,h){try{var p=l.ref;if(p!==null){switch(l.tag){case 26:case 27:case 5:var y=l.stateNode;break;case 30:y=l.stateNode;break;default:y=l.stateNode}typeof p=="function"?l.refCleanup=p(y):p.current=y}}catch(w){Jt(l,h,w)}}function Ns(l,h){var p=l.ref,y=l.refCleanup;if(p!==null)if(typeof y=="function")try{y()}catch(w){Jt(l,h,w)}finally{l.refCleanup=null,l=l.alternate,l!=null&&(l.refCleanup=null)}else if(typeof p=="function")try{p(null)}catch(w){Jt(l,h,w)}else p.current=null}function XT(l){var h=l.type,p=l.memoizedProps,y=l.stateNode;try{e:switch(h){case"button":case"input":case"select":case"textarea":p.autoFocus&&y.focus();break e;case"img":p.src?y.src=p.src:p.srcSet&&(y.srcset=p.srcSet)}}catch(w){Jt(l,l.return,w)}}function l0(l,h,p){try{var y=l.stateNode;O4(y,l.type,p,h),y[qe]=h}catch(w){Jt(l,l.return,w)}}function YT(l){return l.tag===5||l.tag===3||l.tag===26||l.tag===27&&Qi(l.type)||l.tag===4}function u0(l){e:for(;;){for(;l.sibling===null;){if(l.return===null||YT(l.return))return null;l=l.return}for(l.sibling.return=l.return,l=l.sibling;l.tag!==5&&l.tag!==6&&l.tag!==18;){if(l.tag===27&&Qi(l.type)||l.flags&2||l.child===null||l.tag===4)continue e;l.child.return=l,l=l.child}if(!(l.flags&2))return l.stateNode}}function c0(l,h,p){var y=l.tag;if(y===5||y===6)l=l.stateNode,h?(p.nodeType===9?p.body:p.nodeName==="HTML"?p.ownerDocument.body:p).insertBefore(l,h):(h=p.nodeType===9?p.body:p.nodeName==="HTML"?p.ownerDocument.body:p,h.appendChild(l),p=p._reactRootContainer,p!=null||h.onclick!==null||(h.onclick=iy));else if(y!==4&&(y===27&&Qi(l.type)&&(p=l.stateNode,h=null),l=l.child,l!==null))for(c0(l,h,p),l=l.sibling;l!==null;)c0(l,h,p),l=l.sibling}function Xg(l,h,p){var y=l.tag;if(y===5||y===6)l=l.stateNode,h?p.insertBefore(l,h):p.appendChild(l);else if(y!==4&&(y===27&&Qi(l.type)&&(p=l.stateNode),l=l.child,l!==null))for(Xg(l,h,p),l=l.sibling;l!==null;)Xg(l,h,p),l=l.sibling}function ZT(l){var h=l.stateNode,p=l.memoizedProps;try{for(var y=l.type,w=h.attributes;w.length;)h.removeAttributeNode(w[0]);gn(h,y,p),h[dt]=l,h[qe]=p}catch(I){Jt(l,l.return,I)}}var ui=!1,_a=!1,d0=!1,QT=typeof WeakSet=="function"?WeakSet:Set,on=null;function g4(l,h){if(l=l.containerInfo,F0=py,l=uN(l),ux(l)){if("selectionStart"in l)var p={start:l.selectionStart,end:l.selectionEnd};else e:{p=(p=l.ownerDocument)&&p.defaultView||window;var y=p.getSelection&&p.getSelection();if(y&&y.rangeCount!==0){p=y.anchorNode;var w=y.anchorOffset,I=y.focusNode;y=y.focusOffset;try{p.nodeType,I.nodeType}catch{p=null;break e}var $=0,z=-1,Y=-1,he=0,xe=0,Se=l,fe=null;t:for(;;){for(var me;Se!==p||w!==0&&Se.nodeType!==3||(z=$+w),Se!==I||y!==0&&Se.nodeType!==3||(Y=$+y),Se.nodeType===3&&($+=Se.nodeValue.length),(me=Se.firstChild)!==null;)fe=Se,Se=me;for(;;){if(Se===l)break t;if(fe===p&&++he===w&&(z=$),fe===I&&++xe===y&&(Y=$),(me=Se.nextSibling)!==null)break;Se=fe,fe=Se.parentNode}Se=me}p=z===-1||Y===-1?null:{start:z,end:Y}}else p=null}p=p||{start:0,end:0}}else p=null;for(O0={focusedElem:l,selectionRange:p},py=!1,on=h;on!==null;)if(h=on,l=h.child,(h.subtreeFlags&1024)!==0&&l!==null)l.return=h,on=l;else for(;on!==null;){switch(h=on,I=h.alternate,l=h.flags,h.tag){case 0:break;case 11:case 15:break;case 1:if((l&1024)!==0&&I!==null){l=void 0,p=h,w=I.memoizedProps,I=I.memoizedState,y=p.stateNode;try{var et=bl(p.type,w,p.elementType===p.type);l=y.getSnapshotBeforeUpdate(et,I),y.__reactInternalSnapshotBeforeUpdate=l}catch(Xe){Jt(p,p.return,Xe)}}break;case 3:if((l&1024)!==0){if(l=h.stateNode.containerInfo,p=l.nodeType,p===9)B0(l);else if(p===1)switch(l.nodeName){case"HEAD":case"HTML":case"BODY":B0(l);break;default:l.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((l&1024)!==0)throw Error(n(163))}if(l=h.sibling,l!==null){l.return=h.return,on=l;break}on=h.return}}function JT(l,h,p){var y=p.flags;switch(p.tag){case 0:case 11:case 15:Hi(l,p),y&4&&ef(5,p);break;case 1:if(Hi(l,p),y&4)if(l=p.stateNode,h===null)try{l.componentDidMount()}catch($){Jt(p,p.return,$)}else{var w=bl(p.type,h.memoizedProps);h=h.memoizedState;try{l.componentDidUpdate(w,h,l.__reactInternalSnapshotBeforeUpdate)}catch($){Jt(p,p.return,$)}}y&64&&jT(p),y&512&&tf(p,p.return);break;case 3:if(Hi(l,p),y&64&&(l=p.updateQueue,l!==null)){if(h=null,p.child!==null)switch(p.child.tag){case 27:case 5:h=p.child.stateNode;break;case 1:h=p.child.stateNode}try{MN(l,h)}catch($){Jt(p,p.return,$)}}break;case 27:h===null&&y&4&&ZT(p);case 26:case 5:Hi(l,p),h===null&&y&4&&XT(p),y&512&&tf(p,p.return);break;case 12:Hi(l,p);break;case 13:Hi(l,p),y&4&&a_(l,p),y&64&&(l=p.memoizedState,l!==null&&(l=l.dehydrated,l!==null&&(p=N4.bind(null,p),V4(l,p))));break;case 22:if(y=p.memoizedState!==null||ui,!y){h=h!==null&&h.memoizedState!==null||_a,w=ui;var I=_a;ui=y,(_a=h)&&!I?qi(l,p,(p.subtreeFlags&8772)!==0):Hi(l,p),ui=w,_a=I}break;case 30:break;default:Hi(l,p)}}function e_(l){var h=l.alternate;h!==null&&(l.alternate=null,e_(h)),l.child=null,l.deletions=null,l.sibling=null,l.tag===5&&(h=l.stateNode,h!==null&&$i(h)),l.stateNode=null,l.return=null,l.dependencies=null,l.memoizedProps=null,l.memoizedState=null,l.pendingProps=null,l.stateNode=null,l.updateQueue=null}var ua=null,Qn=!1;function ci(l,h,p){for(p=p.child;p!==null;)t_(l,h,p),p=p.sibling}function t_(l,h,p){if($t&&typeof $t.onCommitFiberUnmount=="function")try{$t.onCommitFiberUnmount(Na,p)}catch{}switch(p.tag){case 26:_a||Ns(p,h),ci(l,h,p),p.memoizedState?p.memoizedState.count--:p.stateNode&&(p=p.stateNode,p.parentNode.removeChild(p));break;case 27:_a||Ns(p,h);var y=ua,w=Qn;Qi(p.type)&&(ua=p.stateNode,Qn=!1),ci(l,h,p),df(p.stateNode),ua=y,Qn=w;break;case 5:_a||Ns(p,h);case 6:if(y=ua,w=Qn,ua=null,ci(l,h,p),ua=y,Qn=w,ua!==null)if(Qn)try{(ua.nodeType===9?ua.body:ua.nodeName==="HTML"?ua.ownerDocument.body:ua).removeChild(p.stateNode)}catch(I){Jt(p,h,I)}else try{ua.removeChild(p.stateNode)}catch(I){Jt(p,h,I)}break;case 18:ua!==null&&(Qn?(l=ua,V_(l.nodeType===9?l.body:l.nodeName==="HTML"?l.ownerDocument.body:l,p.stateNode),vf(l)):V_(ua,p.stateNode));break;case 4:y=ua,w=Qn,ua=p.stateNode.containerInfo,Qn=!0,ci(l,h,p),ua=y,Qn=w;break;case 0:case 11:case 14:case 15:_a||Gi(2,p,h),_a||Gi(4,p,h),ci(l,h,p);break;case 1:_a||(Ns(p,h),y=p.stateNode,typeof y.componentWillUnmount=="function"&&KT(p,h,y)),ci(l,h,p);break;case 21:ci(l,h,p);break;case 22:_a=(y=_a)||p.memoizedState!==null,ci(l,h,p),_a=y;break;default:ci(l,h,p)}}function a_(l,h){if(h.memoizedState===null&&(l=h.alternate,l!==null&&(l=l.memoizedState,l!==null&&(l=l.dehydrated,l!==null))))try{vf(l)}catch(p){Jt(h,h.return,p)}}function y4(l){switch(l.tag){case 13:case 19:var h=l.stateNode;return h===null&&(h=l.stateNode=new QT),h;case 22:return l=l.stateNode,h=l._retryCache,h===null&&(h=l._retryCache=new QT),h;default:throw Error(n(435,l.tag))}}function h0(l,h){var p=y4(l);h.forEach(function(y){var w=T4.bind(null,l,y);p.has(y)||(p.add(y),y.then(w,w))})}function mr(l,h){var p=h.deletions;if(p!==null)for(var y=0;y<p.length;y++){var w=p[y],I=l,$=h,z=$;e:for(;z!==null;){switch(z.tag){case 27:if(Qi(z.type)){ua=z.stateNode,Qn=!1;break e}break;case 5:ua=z.stateNode,Qn=!1;break e;case 3:case 4:ua=z.stateNode.containerInfo,Qn=!0;break e}z=z.return}if(ua===null)throw Error(n(160));t_(I,$,w),ua=null,Qn=!1,I=w.alternate,I!==null&&(I.return=null),w.return=null}if(h.subtreeFlags&13878)for(h=h.child;h!==null;)n_(h,l),h=h.sibling}var as=null;function n_(l,h){var p=l.alternate,y=l.flags;switch(l.tag){case 0:case 11:case 14:case 15:mr(h,l),gr(l),y&4&&(Gi(3,l,l.return),ef(3,l),Gi(5,l,l.return));break;case 1:mr(h,l),gr(l),y&512&&(_a||p===null||Ns(p,p.return)),y&64&&ui&&(l=l.updateQueue,l!==null&&(y=l.callbacks,y!==null&&(p=l.shared.hiddenCallbacks,l.shared.hiddenCallbacks=p===null?y:p.concat(y))));break;case 26:var w=as;if(mr(h,l),gr(l),y&512&&(_a||p===null||Ns(p,p.return)),y&4){var I=p!==null?p.memoizedState:null;if(y=l.memoizedState,p===null)if(y===null)if(l.stateNode===null){e:{y=l.type,p=l.memoizedProps,w=w.ownerDocument||w;t:switch(y){case"title":I=w.getElementsByTagName("title")[0],(!I||I[Zr]||I[dt]||I.namespaceURI==="http://www.w3.org/2000/svg"||I.hasAttribute("itemprop"))&&(I=w.createElement(y),w.head.insertBefore(I,w.querySelector("head > title"))),gn(I,y,p),I[dt]=l,xa(I),y=I;break e;case"link":var $=Z_("link","href",w).get(y+(p.href||""));if($){for(var z=0;z<$.length;z++)if(I=$[z],I.getAttribute("href")===(p.href==null||p.href===""?null:p.href)&&I.getAttribute("rel")===(p.rel==null?null:p.rel)&&I.getAttribute("title")===(p.title==null?null:p.title)&&I.getAttribute("crossorigin")===(p.crossOrigin==null?null:p.crossOrigin)){$.splice(z,1);break t}}I=w.createElement(y),gn(I,y,p),w.head.appendChild(I);break;case"meta":if($=Z_("meta","content",w).get(y+(p.content||""))){for(z=0;z<$.length;z++)if(I=$[z],I.getAttribute("content")===(p.content==null?null:""+p.content)&&I.getAttribute("name")===(p.name==null?null:p.name)&&I.getAttribute("property")===(p.property==null?null:p.property)&&I.getAttribute("http-equiv")===(p.httpEquiv==null?null:p.httpEquiv)&&I.getAttribute("charset")===(p.charSet==null?null:p.charSet)){$.splice(z,1);break t}}I=w.createElement(y),gn(I,y,p),w.head.appendChild(I);break;default:throw Error(n(468,y))}I[dt]=l,xa(I),y=I}l.stateNode=y}else Q_(w,l.type,l.stateNode);else l.stateNode=Y_(w,y,l.memoizedProps);else I!==y?(I===null?p.stateNode!==null&&(p=p.stateNode,p.parentNode.removeChild(p)):I.count--,y===null?Q_(w,l.type,l.stateNode):Y_(w,y,l.memoizedProps)):y===null&&l.stateNode!==null&&l0(l,l.memoizedProps,p.memoizedProps)}break;case 27:mr(h,l),gr(l),y&512&&(_a||p===null||Ns(p,p.return)),p!==null&&y&4&&l0(l,l.memoizedProps,p.memoizedProps);break;case 5:if(mr(h,l),gr(l),y&512&&(_a||p===null||Ns(p,p.return)),l.flags&32){w=l.stateNode;try{Qs(w,"")}catch(me){Jt(l,l.return,me)}}y&4&&l.stateNode!=null&&(w=l.memoizedProps,l0(l,w,p!==null?p.memoizedProps:w)),y&1024&&(d0=!0);break;case 6:if(mr(h,l),gr(l),y&4){if(l.stateNode===null)throw Error(n(162));y=l.memoizedProps,p=l.stateNode;try{p.nodeValue=y}catch(me){Jt(l,l.return,me)}}break;case 3:if(cy=null,w=as,as=ly(h.containerInfo),mr(h,l),as=w,gr(l),y&4&&p!==null&&p.memoizedState.isDehydrated)try{vf(h.containerInfo)}catch(me){Jt(l,l.return,me)}d0&&(d0=!1,r_(l));break;case 4:y=as,as=ly(l.stateNode.containerInfo),mr(h,l),gr(l),as=y;break;case 12:mr(h,l),gr(l);break;case 13:mr(h,l),gr(l),l.child.flags&8192&&l.memoizedState!==null!=(p!==null&&p.memoizedState!==null)&&(b0=ot()),y&4&&(y=l.updateQueue,y!==null&&(l.updateQueue=null,h0(l,y)));break;case 22:w=l.memoizedState!==null;var Y=p!==null&&p.memoizedState!==null,he=ui,xe=_a;if(ui=he||w,_a=xe||Y,mr(h,l),_a=xe,ui=he,gr(l),y&8192)e:for(h=l.stateNode,h._visibility=w?h._visibility&-2:h._visibility|1,w&&(p===null||Y||ui||_a||vl(l)),p=null,h=l;;){if(h.tag===5||h.tag===26){if(p===null){Y=p=h;try{if(I=Y.stateNode,w)$=I.style,typeof $.setProperty=="function"?$.setProperty("display","none","important"):$.display="none";else{z=Y.stateNode;var Se=Y.memoizedProps.style,fe=Se!=null&&Se.hasOwnProperty("display")?Se.display:null;z.style.display=fe==null||typeof fe=="boolean"?"":(""+fe).trim()}}catch(me){Jt(Y,Y.return,me)}}}else if(h.tag===6){if(p===null){Y=h;try{Y.stateNode.nodeValue=w?"":Y.memoizedProps}catch(me){Jt(Y,Y.return,me)}}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===l)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===l)break e;for(;h.sibling===null;){if(h.return===null||h.return===l)break e;p===h&&(p=null),h=h.return}p===h&&(p=null),h.sibling.return=h.return,h=h.sibling}y&4&&(y=l.updateQueue,y!==null&&(p=y.retryQueue,p!==null&&(y.retryQueue=null,h0(l,p))));break;case 19:mr(h,l),gr(l),y&4&&(y=l.updateQueue,y!==null&&(l.updateQueue=null,h0(l,y)));break;case 30:break;case 21:break;default:mr(h,l),gr(l)}}function gr(l){var h=l.flags;if(h&2){try{for(var p,y=l.return;y!==null;){if(YT(y)){p=y;break}y=y.return}if(p==null)throw Error(n(160));switch(p.tag){case 27:var w=p.stateNode,I=u0(l);Xg(l,I,w);break;case 5:var $=p.stateNode;p.flags&32&&(Qs($,""),p.flags&=-33);var z=u0(l);Xg(l,z,$);break;case 3:case 4:var Y=p.stateNode.containerInfo,he=u0(l);c0(l,he,Y);break;default:throw Error(n(161))}}catch(xe){Jt(l,l.return,xe)}l.flags&=-3}h&4096&&(l.flags&=-4097)}function r_(l){if(l.subtreeFlags&1024)for(l=l.child;l!==null;){var h=l;r_(h),h.tag===5&&h.flags&1024&&h.stateNode.reset(),l=l.sibling}}function Hi(l,h){if(h.subtreeFlags&8772)for(h=h.child;h!==null;)JT(l,h.alternate,h),h=h.sibling}function vl(l){for(l=l.child;l!==null;){var h=l;switch(h.tag){case 0:case 11:case 14:case 15:Gi(4,h,h.return),vl(h);break;case 1:Ns(h,h.return);var p=h.stateNode;typeof p.componentWillUnmount=="function"&&KT(h,h.return,p),vl(h);break;case 27:df(h.stateNode);case 26:case 5:Ns(h,h.return),vl(h);break;case 22:h.memoizedState===null&&vl(h);break;case 30:vl(h);break;default:vl(h)}l=l.sibling}}function qi(l,h,p){for(p=p&&(h.subtreeFlags&8772)!==0,h=h.child;h!==null;){var y=h.alternate,w=l,I=h,$=I.flags;switch(I.tag){case 0:case 11:case 15:qi(w,I,p),ef(4,I);break;case 1:if(qi(w,I,p),y=I,w=y.stateNode,typeof w.componentDidMount=="function")try{w.componentDidMount()}catch(he){Jt(y,y.return,he)}if(y=I,w=y.updateQueue,w!==null){var z=y.stateNode;try{var Y=w.shared.hiddenCallbacks;if(Y!==null)for(w.shared.hiddenCallbacks=null,w=0;w<Y.length;w++)DN(Y[w],z)}catch(he){Jt(y,y.return,he)}}p&&$&64&&jT(I),tf(I,I.return);break;case 27:ZT(I);case 26:case 5:qi(w,I,p),p&&y===null&&$&4&&XT(I),tf(I,I.return);break;case 12:qi(w,I,p);break;case 13:qi(w,I,p),p&&$&4&&a_(w,I);break;case 22:I.memoizedState===null&&qi(w,I,p),tf(I,I.return);break;case 30:break;default:qi(w,I,p)}h=h.sibling}}function p0(l,h){var p=null;l!==null&&l.memoizedState!==null&&l.memoizedState.cachePool!==null&&(p=l.memoizedState.cachePool.pool),l=null,h.memoizedState!==null&&h.memoizedState.cachePool!==null&&(l=h.memoizedState.cachePool.pool),l!==p&&(l!=null&&l.refCount++,p!=null&&Up(p))}function f0(l,h){l=null,h.alternate!==null&&(l=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==l&&(h.refCount++,l!=null&&Up(l))}function Ts(l,h,p,y){if(h.subtreeFlags&10256)for(h=h.child;h!==null;)s_(l,h,p,y),h=h.sibling}function s_(l,h,p,y){var w=h.flags;switch(h.tag){case 0:case 11:case 15:Ts(l,h,p,y),w&2048&&ef(9,h);break;case 1:Ts(l,h,p,y);break;case 3:Ts(l,h,p,y),w&2048&&(l=null,h.alternate!==null&&(l=h.alternate.memoizedState.cache),h=h.memoizedState.cache,h!==l&&(h.refCount++,l!=null&&Up(l)));break;case 12:if(w&2048){Ts(l,h,p,y),l=h.stateNode;try{var I=h.memoizedProps,$=I.id,z=I.onPostCommit;typeof z=="function"&&z($,h.alternate===null?"mount":"update",l.passiveEffectDuration,-0)}catch(Y){Jt(h,h.return,Y)}}else Ts(l,h,p,y);break;case 13:Ts(l,h,p,y);break;case 23:break;case 22:I=h.stateNode,$=h.alternate,h.memoizedState!==null?I._visibility&2?Ts(l,h,p,y):af(l,h):I._visibility&2?Ts(l,h,p,y):(I._visibility|=2,sd(l,h,p,y,(h.subtreeFlags&10256)!==0)),w&2048&&p0($,h);break;case 24:Ts(l,h,p,y),w&2048&&f0(h.alternate,h);break;default:Ts(l,h,p,y)}}function sd(l,h,p,y,w){for(w=w&&(h.subtreeFlags&10256)!==0,h=h.child;h!==null;){var I=l,$=h,z=p,Y=y,he=$.flags;switch($.tag){case 0:case 11:case 15:sd(I,$,z,Y,w),ef(8,$);break;case 23:break;case 22:var xe=$.stateNode;$.memoizedState!==null?xe._visibility&2?sd(I,$,z,Y,w):af(I,$):(xe._visibility|=2,sd(I,$,z,Y,w)),w&&he&2048&&p0($.alternate,$);break;case 24:sd(I,$,z,Y,w),w&&he&2048&&f0($.alternate,$);break;default:sd(I,$,z,Y,w)}h=h.sibling}}function af(l,h){if(h.subtreeFlags&10256)for(h=h.child;h!==null;){var p=l,y=h,w=y.flags;switch(y.tag){case 22:af(p,y),w&2048&&p0(y.alternate,y);break;case 24:af(p,y),w&2048&&f0(y.alternate,y);break;default:af(p,y)}h=h.sibling}}var nf=8192;function id(l){if(l.subtreeFlags&nf)for(l=l.child;l!==null;)i_(l),l=l.sibling}function i_(l){switch(l.tag){case 26:id(l),l.flags&nf&&l.memoizedState!==null&&aU(as,l.memoizedState,l.memoizedProps);break;case 5:id(l);break;case 3:case 4:var h=as;as=ly(l.stateNode.containerInfo),id(l),as=h;break;case 22:l.memoizedState===null&&(h=l.alternate,h!==null&&h.memoizedState!==null?(h=nf,nf=16777216,id(l),nf=h):id(l));break;default:id(l)}}function o_(l){var h=l.alternate;if(h!==null&&(l=h.child,l!==null)){h.child=null;do h=l.sibling,l.sibling=null,l=h;while(l!==null)}}function rf(l){var h=l.deletions;if((l.flags&16)!==0){if(h!==null)for(var p=0;p<h.length;p++){var y=h[p];on=y,u_(y,l)}o_(l)}if(l.subtreeFlags&10256)for(l=l.child;l!==null;)l_(l),l=l.sibling}function l_(l){switch(l.tag){case 0:case 11:case 15:rf(l),l.flags&2048&&Gi(9,l,l.return);break;case 3:rf(l);break;case 12:rf(l);break;case 22:var h=l.stateNode;l.memoizedState!==null&&h._visibility&2&&(l.return===null||l.return.tag!==13)?(h._visibility&=-3,Yg(l)):rf(l);break;default:rf(l)}}function Yg(l){var h=l.deletions;if((l.flags&16)!==0){if(h!==null)for(var p=0;p<h.length;p++){var y=h[p];on=y,u_(y,l)}o_(l)}for(l=l.child;l!==null;){switch(h=l,h.tag){case 0:case 11:case 15:Gi(8,h,h.return),Yg(h);break;case 22:p=h.stateNode,p._visibility&2&&(p._visibility&=-3,Yg(h));break;default:Yg(h)}l=l.sibling}}function u_(l,h){for(;on!==null;){var p=on;switch(p.tag){case 0:case 11:case 15:Gi(8,p,h);break;case 23:case 22:if(p.memoizedState!==null&&p.memoizedState.cachePool!==null){var y=p.memoizedState.cachePool.pool;y!=null&&y.refCount++}break;case 24:Up(p.memoizedState.cache)}if(y=p.child,y!==null)y.return=p,on=y;else e:for(p=l;on!==null;){y=on;var w=y.sibling,I=y.return;if(e_(y),y===p){on=null;break e}if(w!==null){w.return=I,on=w;break e}on=I}}}var b4={getCacheForType:function(l){var h=kn(Ha),p=h.data.get(l);return p===void 0&&(p=l(),h.data.set(l,p)),p}},v4=typeof WeakMap=="function"?WeakMap:Map,Ut=0,sa=null,wt=null,_t=0,Pt=0,yr=null,ji=!1,od=!1,m0=!1,di=0,ka=0,Ki=0,xl=0,g0=0,zr=0,ld=0,sf=null,Jn=null,y0=!1,b0=0,Zg=1/0,Qg=null,Xi=null,mn=0,Yi=null,ud=null,cd=0,v0=0,x0=null,c_=null,of=0,w0=null;function br(){if((Ut&2)!==0&&_t!==0)return _t&-_t;if(W.T!==null){var l=Zc;return l!==0?l:C0()}return Ve()}function d_(){zr===0&&(zr=(_t&536870912)===0||Dt?el():536870912);var l=Or.current;return l!==null&&(l.flags|=32),zr}function vr(l,h,p){(l===sa&&(Pt===2||Pt===9)||l.cancelPendingCommit!==null)&&(dd(l,0),Zi(l,_t,zr,!1)),vs(l,p),((Ut&2)===0||l!==sa)&&(l===sa&&((Ut&2)===0&&(xl|=p),ka===4&&Zi(l,_t,zr,!1)),_s(l))}function h_(l,h,p){if((Ut&6)!==0)throw Error(n(327));var y=!p&&(h&124)===0&&(h&l.expiredLanes)===0||ys(l,h),w=y?k4(l,h):I0(l,h,!0),I=y;do{if(w===0){od&&!y&&Zi(l,h,0,!1);break}else{if(p=l.current.alternate,I&&!x4(p)){w=I0(l,h,!1),I=!1;continue}if(w===2){if(I=h,l.errorRecoveryDisabledLanes&I)var $=0;else $=l.pendingLanes&-536870913,$=$!==0?$:$&536870912?536870912:0;if($!==0){h=$;e:{var z=l;w=sf;var Y=z.current.memoizedState.isDehydrated;if(Y&&(dd(z,$).flags|=256),$=I0(z,$,!1),$!==2){if(m0&&!Y){z.errorRecoveryDisabledLanes|=I,xl|=I,w=4;break e}I=Jn,Jn=w,I!==null&&(Jn===null?Jn=I:Jn.push.apply(Jn,I))}w=$}if(I=!1,w!==2)continue}}if(w===1){dd(l,0),Zi(l,h,0,!0);break}e:{switch(y=l,I=w,I){case 0:case 1:throw Error(n(345));case 4:if((h&4194048)!==h)break;case 6:Zi(y,h,zr,!ji);break e;case 2:Jn=null;break;case 3:case 5:break;default:throw Error(n(329))}if((h&62914560)===h&&(w=b0+300-ot(),10<w)){if(Zi(y,h,zr,!ji),Ks(y,0,!0)!==0)break e;y.timeoutHandle=P_(p_.bind(null,y,p,Jn,Qg,y0,h,zr,xl,ld,ji,I,2,-0,0),w);break e}p_(y,p,Jn,Qg,y0,h,zr,xl,ld,ji,I,0,-0,0)}}break}while(!0);_s(l)}function p_(l,h,p,y,w,I,$,z,Y,he,xe,Se,fe,me){if(l.timeoutHandle=-1,Se=h.subtreeFlags,(Se&8192||(Se&16785408)===16785408)&&(ff={stylesheets:null,count:0,unsuspend:tU},i_(h),Se=nU(),Se!==null)){l.cancelPendingCommit=Se(x_.bind(null,l,h,I,p,y,w,$,z,Y,xe,1,fe,me)),Zi(l,I,$,!he);return}x_(l,h,I,p,y,w,$,z,Y)}function x4(l){for(var h=l;;){var p=h.tag;if((p===0||p===11||p===15)&&h.flags&16384&&(p=h.updateQueue,p!==null&&(p=p.stores,p!==null)))for(var y=0;y<p.length;y++){var w=p[y],I=w.getSnapshot;w=w.value;try{if(!pr(I(),w))return!1}catch{return!1}}if(p=h.child,h.subtreeFlags&16384&&p!==null)p.return=h,h=p;else{if(h===l)break;for(;h.sibling===null;){if(h.return===null||h.return===l)return!0;h=h.return}h.sibling.return=h.return,h=h.sibling}}return!0}function Zi(l,h,p,y){h&=~g0,h&=~xl,l.suspendedLanes|=h,l.pingedLanes&=~h,y&&(l.warmLanes|=h),y=l.expirationTimes;for(var w=h;0<w;){var I=31-va(w),$=1<<I;y[I]=-1,w&=~$}p!==0&&xs(l,p,h)}function Jg(){return(Ut&6)===0?(lf(0),!1):!0}function k0(){if(wt!==null){if(Pt===0)var l=wt.return;else l=wt,ni=fl=null,Bx(l),nd=null,Zp=0,l=wt;for(;l!==null;)qT(l.alternate,l),l=l.return;wt=null}}function dd(l,h){var p=l.timeoutHandle;p!==-1&&(l.timeoutHandle=-1,L4(p)),p=l.cancelPendingCommit,p!==null&&(l.cancelPendingCommit=null,p()),k0(),sa=l,wt=p=ei(l.current,null),_t=h,Pt=0,yr=null,ji=!1,od=ys(l,h),m0=!1,ld=zr=g0=xl=Ki=ka=0,Jn=sf=null,y0=!1,(h&8)!==0&&(h|=h&32);var y=l.entangledLanes;if(y!==0)for(l=l.entanglements,y&=h;0<y;){var w=31-va(y),I=1<<w;h|=l[w],y&=~I}return di=h,wg(),p}function f_(l,h){yt=null,W.H=Ug,h===Wp||h===Ag?(h=$N(),Pt=3):h===CN?(h=$N(),Pt=4):Pt=h===RT?8:h!==null&&typeof h=="object"&&typeof h.then=="function"?6:1,yr=h,wt===null&&(ka=1,Hg(l,Rr(h,l.current)))}function m_(){var l=W.H;return W.H=Ug,l===null?Ug:l}function g_(){var l=W.A;return W.A=b4,l}function S0(){ka=4,ji||(_t&4194048)!==_t&&Or.current!==null||(od=!0),(Ki&134217727)===0&&(xl&134217727)===0||sa===null||Zi(sa,_t,zr,!1)}function I0(l,h,p){var y=Ut;Ut|=2;var w=m_(),I=g_();(sa!==l||_t!==h)&&(Qg=null,dd(l,h)),h=!1;var $=ka;e:do try{if(Pt!==0&&wt!==null){var z=wt,Y=yr;switch(Pt){case 8:k0(),$=6;break e;case 3:case 2:case 9:case 6:Or.current===null&&(h=!0);var he=Pt;if(Pt=0,yr=null,hd(l,z,Y,he),p&&od){$=0;break e}break;default:he=Pt,Pt=0,yr=null,hd(l,z,Y,he)}}w4(),$=ka;break}catch(xe){f_(l,xe)}while(!0);return h&&l.shellSuspendCounter++,ni=fl=null,Ut=y,W.H=w,W.A=I,wt===null&&(sa=null,_t=0,wg()),$}function w4(){for(;wt!==null;)y_(wt)}function k4(l,h){var p=Ut;Ut|=2;var y=m_(),w=g_();sa!==l||_t!==h?(Qg=null,Zg=ot()+500,dd(l,h)):od=ys(l,h);e:do try{if(Pt!==0&&wt!==null){h=wt;var I=yr;t:switch(Pt){case 1:Pt=0,yr=null,hd(l,h,I,1);break;case 2:case 9:if(EN(I)){Pt=0,yr=null,b_(h);break}h=function(){Pt!==2&&Pt!==9||sa!==l||(Pt=7),_s(l)},I.then(h,h);break e;case 3:Pt=7;break e;case 4:Pt=5;break e;case 7:EN(I)?(Pt=0,yr=null,b_(h)):(Pt=0,yr=null,hd(l,h,I,7));break;case 5:var $=null;switch(wt.tag){case 26:$=wt.memoizedState;case 5:case 27:var z=wt;if(!$||J_($)){Pt=0,yr=null;var Y=z.sibling;if(Y!==null)wt=Y;else{var he=z.return;he!==null?(wt=he,ey(he)):wt=null}break t}}Pt=0,yr=null,hd(l,h,I,5);break;case 6:Pt=0,yr=null,hd(l,h,I,6);break;case 8:k0(),ka=6;break e;default:throw Error(n(462))}}S4();break}catch(xe){f_(l,xe)}while(!0);return ni=fl=null,W.H=y,W.A=w,Ut=p,wt!==null?0:(sa=null,_t=0,wg(),ka)}function S4(){for(;wt!==null&&!xt();)y_(wt)}function y_(l){var h=GT(l.alternate,l,di);l.memoizedProps=l.pendingProps,h===null?ey(l):wt=h}function b_(l){var h=l,p=h.alternate;switch(h.tag){case 15:case 0:h=LT(p,h,h.pendingProps,h.type,void 0,_t);break;case 11:h=LT(p,h,h.pendingProps,h.type.render,h.ref,_t);break;case 5:Bx(h);default:qT(p,h),h=wt=vN(h,di),h=GT(p,h,di)}l.memoizedProps=l.pendingProps,h===null?ey(l):wt=h}function hd(l,h,p,y){ni=fl=null,Bx(h),nd=null,Zp=0;var w=h.return;try{if(h4(l,w,h,p,_t)){ka=1,Hg(l,Rr(p,l.current)),wt=null;return}}catch(I){if(w!==null)throw wt=w,I;ka=1,Hg(l,Rr(p,l.current)),wt=null;return}h.flags&32768?(Dt||y===1?l=!0:od||(_t&536870912)!==0?l=!1:(ji=l=!0,(y===2||y===9||y===3||y===6)&&(y=Or.current,y!==null&&y.tag===13&&(y.flags|=16384))),v_(h,l)):ey(h)}function ey(l){var h=l;do{if((h.flags&32768)!==0){v_(h,ji);return}l=h.return;var p=f4(h.alternate,h,di);if(p!==null){wt=p;return}if(h=h.sibling,h!==null){wt=h;return}wt=h=l}while(h!==null);ka===0&&(ka=5)}function v_(l,h){do{var p=m4(l.alternate,l);if(p!==null){p.flags&=32767,wt=p;return}if(p=l.return,p!==null&&(p.flags|=32768,p.subtreeFlags=0,p.deletions=null),!h&&(l=l.sibling,l!==null)){wt=l;return}wt=l=p}while(l!==null);ka=6,wt=null}function x_(l,h,p,y,w,I,$,z,Y){l.cancelPendingCommit=null;do ty();while(mn!==0);if((Ut&6)!==0)throw Error(n(327));if(h!==null){if(h===l.current)throw Error(n(177));if(I=h.lanes|h.childLanes,I|=fx,Xs(l,p,I,$,z,Y),l===sa&&(wt=sa=null,_t=0),ud=h,Yi=l,cd=p,v0=I,x0=w,c_=y,(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?(l.callbackNode=null,l.callbackPriority=0,_4(Fa,function(){return N_(),null})):(l.callbackNode=null,l.callbackPriority=0),y=(h.flags&13878)!==0,(h.subtreeFlags&13878)!==0||y){y=W.T,W.T=null,w=X.p,X.p=2,$=Ut,Ut|=4;try{g4(l,h,p)}finally{Ut=$,X.p=w,W.T=y}}mn=1,w_(),k_(),S_()}}function w_(){if(mn===1){mn=0;var l=Yi,h=ud,p=(h.flags&13878)!==0;if((h.subtreeFlags&13878)!==0||p){p=W.T,W.T=null;var y=X.p;X.p=2;var w=Ut;Ut|=4;try{n_(h,l);var I=O0,$=uN(l.containerInfo),z=I.focusedElem,Y=I.selectionRange;if($!==z&&z&&z.ownerDocument&&lN(z.ownerDocument.documentElement,z)){if(Y!==null&&ux(z)){var he=Y.start,xe=Y.end;if(xe===void 0&&(xe=he),"selectionStart"in z)z.selectionStart=he,z.selectionEnd=Math.min(xe,z.value.length);else{var Se=z.ownerDocument||document,fe=Se&&Se.defaultView||window;if(fe.getSelection){var me=fe.getSelection(),et=z.textContent.length,Xe=Math.min(Y.start,et),Zt=Y.end===void 0?Xe:Math.min(Y.end,et);!me.extend&&Xe>Zt&&($=Zt,Zt=Xe,Xe=$);var oe=oN(z,Xe),re=oN(z,Zt);if(oe&&re&&(me.rangeCount!==1||me.anchorNode!==oe.node||me.anchorOffset!==oe.offset||me.focusNode!==re.node||me.focusOffset!==re.offset)){var de=Se.createRange();de.setStart(oe.node,oe.offset),me.removeAllRanges(),Xe>Zt?(me.addRange(de),me.extend(re.node,re.offset)):(de.setEnd(re.node,re.offset),me.addRange(de))}}}}for(Se=[],me=z;me=me.parentNode;)me.nodeType===1&&Se.push({element:me,left:me.scrollLeft,top:me.scrollTop});for(typeof z.focus=="function"&&z.focus(),z=0;z<Se.length;z++){var we=Se[z];we.element.scrollLeft=we.left,we.element.scrollTop=we.top}}py=!!F0,O0=F0=null}finally{Ut=w,X.p=y,W.T=p}}l.current=h,mn=2}}function k_(){if(mn===2){mn=0;var l=Yi,h=ud,p=(h.flags&8772)!==0;if((h.subtreeFlags&8772)!==0||p){p=W.T,W.T=null;var y=X.p;X.p=2;var w=Ut;Ut|=4;try{JT(l,h.alternate,h)}finally{Ut=w,X.p=y,W.T=p}}mn=3}}function S_(){if(mn===4||mn===3){mn=0,tt();var l=Yi,h=ud,p=cd,y=c_;(h.subtreeFlags&10256)!==0||(h.flags&10256)!==0?mn=5:(mn=0,ud=Yi=null,I_(l,l.pendingLanes));var w=l.pendingLanes;if(w===0&&(Xi=null),_e(p),h=h.stateNode,$t&&typeof $t.onCommitFiberRoot=="function")try{$t.onCommitFiberRoot(Na,h,void 0,(h.current.flags&128)===128)}catch{}if(y!==null){h=W.T,w=X.p,X.p=2,W.T=null;try{for(var I=l.onRecoverableError,$=0;$<y.length;$++){var z=y[$];I(z.value,{componentStack:z.stack})}}finally{W.T=h,X.p=w}}(cd&3)!==0&&ty(),_s(l),w=l.pendingLanes,(p&4194090)!==0&&(w&42)!==0?l===w0?of++:(of=0,w0=l):of=0,lf(0)}}function I_(l,h){(l.pooledCacheLanes&=h)===0&&(h=l.pooledCache,h!=null&&(l.pooledCache=null,Up(h)))}function ty(l){return w_(),k_(),S_(),N_()}function N_(){if(mn!==5)return!1;var l=Yi,h=v0;v0=0;var p=_e(cd),y=W.T,w=X.p;try{X.p=32>p?32:p,W.T=null,p=x0,x0=null;var I=Yi,$=cd;if(mn=0,ud=Yi=null,cd=0,(Ut&6)!==0)throw Error(n(331));var z=Ut;if(Ut|=4,l_(I.current),s_(I,I.current,$,p),Ut=z,lf(0,!1),$t&&typeof $t.onPostCommitFiberRoot=="function")try{$t.onPostCommitFiberRoot(Na,I)}catch{}return!0}finally{X.p=w,W.T=y,I_(l,h)}}function T_(l,h,p){h=Rr(p,h),h=Jx(l.stateNode,h,2),l=Ui(l,h,2),l!==null&&(vs(l,2),_s(l))}function Jt(l,h,p){if(l.tag===3)T_(l,l,p);else for(;h!==null;){if(h.tag===3){T_(h,l,p);break}else if(h.tag===1){var y=h.stateNode;if(typeof h.type.getDerivedStateFromError=="function"||typeof y.componentDidCatch=="function"&&(Xi===null||!Xi.has(y))){l=Rr(p,l),p=AT(2),y=Ui(h,p,2),y!==null&&($T(p,y,h,l),vs(y,2),_s(y));break}}h=h.return}}function N0(l,h,p){var y=l.pingCache;if(y===null){y=l.pingCache=new v4;var w=new Set;y.set(h,w)}else w=y.get(h),w===void 0&&(w=new Set,y.set(h,w));w.has(p)||(m0=!0,w.add(p),l=I4.bind(null,l,h,p),h.then(l,l))}function I4(l,h,p){var y=l.pingCache;y!==null&&y.delete(h),l.pingedLanes|=l.suspendedLanes&p,l.warmLanes&=~p,sa===l&&(_t&p)===p&&(ka===4||ka===3&&(_t&62914560)===_t&&300>ot()-b0?(Ut&2)===0&&dd(l,0):g0|=p,ld===_t&&(ld=0)),_s(l)}function __(l,h){h===0&&(h=Er()),l=jc(l,h),l!==null&&(vs(l,h),_s(l))}function N4(l){var h=l.memoizedState,p=0;h!==null&&(p=h.retryLane),__(l,p)}function T4(l,h){var p=0;switch(l.tag){case 13:var y=l.stateNode,w=l.memoizedState;w!==null&&(p=w.retryLane);break;case 19:y=l.stateNode;break;case 22:y=l.stateNode._retryCache;break;default:throw Error(n(314))}y!==null&&y.delete(h),__(l,p)}function _4(l,h){return At(l,h)}var ay=null,pd=null,T0=!1,ny=!1,_0=!1,wl=0;function _s(l){l!==pd&&l.next===null&&(pd===null?ay=pd=l:pd=pd.next=l),ny=!0,T0||(T0=!0,E4())}function lf(l,h){if(!_0&&ny){_0=!0;do for(var p=!1,y=ay;y!==null;){if(l!==0){var w=y.pendingLanes;if(w===0)var I=0;else{var $=y.suspendedLanes,z=y.pingedLanes;I=(1<<31-va(42|l)+1)-1,I&=w&~($&~z),I=I&201326741?I&201326741|1:I?I|2:0}I!==0&&(p=!0,$_(y,I))}else I=_t,I=Ks(y,y===sa?I:0,y.cancelPendingCommit!==null||y.timeoutHandle!==-1),(I&3)===0||ys(y,I)||(p=!0,$_(y,I));y=y.next}while(p);_0=!1}}function C4(){C_()}function C_(){ny=T0=!1;var l=0;wl!==0&&(z4()&&(l=wl),wl=0);for(var h=ot(),p=null,y=ay;y!==null;){var w=y.next,I=E_(y,h);I===0?(y.next=null,p===null?ay=w:p.next=w,w===null&&(pd=p)):(p=y,(l!==0||(I&3)!==0)&&(ny=!0)),y=w}lf(l)}function E_(l,h){for(var p=l.suspendedLanes,y=l.pingedLanes,w=l.expirationTimes,I=l.pendingLanes&-62914561;0<I;){var $=31-va(I),z=1<<$,Y=w[$];Y===-1?((z&p)===0||(z&y)!==0)&&(w[$]=Oc(z,h)):Y<=h&&(l.expiredLanes|=z),I&=~z}if(h=sa,p=_t,p=Ks(l,l===h?p:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),y=l.callbackNode,p===0||l===h&&(Pt===2||Pt===9)||l.cancelPendingCommit!==null)return y!==null&&y!==null&&pt(y),l.callbackNode=null,l.callbackPriority=0;if((p&3)===0||ys(l,p)){if(h=p&-p,h===l.callbackPriority)return h;switch(y!==null&&pt(y),_e(p)){case 2:case 8:p=na;break;case 32:p=Fa;break;case 268435456:p=nn;break;default:p=Fa}return y=A_.bind(null,l),p=At(p,y),l.callbackPriority=h,l.callbackNode=p,h}return y!==null&&y!==null&&pt(y),l.callbackPriority=2,l.callbackNode=null,2}function A_(l,h){if(mn!==0&&mn!==5)return l.callbackNode=null,l.callbackPriority=0,null;var p=l.callbackNode;if(ty()&&l.callbackNode!==p)return null;var y=_t;return y=Ks(l,l===sa?y:0,l.cancelPendingCommit!==null||l.timeoutHandle!==-1),y===0?null:(h_(l,y,h),E_(l,ot()),l.callbackNode!=null&&l.callbackNode===p?A_.bind(null,l):null)}function $_(l,h){if(ty())return null;h_(l,h,!0)}function E4(){B4(function(){(Ut&6)!==0?At(pn,C4):C_()})}function C0(){return wl===0&&(wl=el()),wl}function R_(l){return l==null||typeof l=="symbol"||typeof l=="boolean"?null:typeof l=="function"?l:Js(""+l)}function D_(l,h){var p=h.ownerDocument.createElement("input");return p.name=h.name,p.value=h.value,l.id&&p.setAttribute("form",l.id),h.parentNode.insertBefore(p,h),l=new FormData(l),p.parentNode.removeChild(p),l}function A4(l,h,p,y,w){if(h==="submit"&&p&&p.stateNode===w){var I=R_((w[qe]||null).action),$=y.submitter;$&&(h=(h=$[qe]||null)?R_(h.formAction):$.getAttribute("formAction"),h!==null&&(I=h,$=null));var z=new il("action","action",null,y,w);l.push({event:z,listeners:[{instance:null,listener:function(){if(y.defaultPrevented){if(wl!==0){var Y=$?D_(w,$):new FormData(w);Kx(p,{pending:!0,data:Y,method:w.method,action:I},null,Y)}}else typeof I=="function"&&(z.preventDefault(),Y=$?D_(w,$):new FormData(w),Kx(p,{pending:!0,data:Y,method:w.method,action:I},I,Y))},currentTarget:w}]})}}for(var E0=0;E0<px.length;E0++){var A0=px[E0],$4=A0.toLowerCase(),R4=A0[0].toUpperCase()+A0.slice(1);ts($4,"on"+R4)}ts(hN,"onAnimationEnd"),ts(pN,"onAnimationIteration"),ts(fN,"onAnimationStart"),ts("dblclick","onDoubleClick"),ts("focusin","onFocus"),ts("focusout","onBlur"),ts(XB,"onTransitionRun"),ts(YB,"onTransitionStart"),ts(ZB,"onTransitionCancel"),ts(mN,"onTransitionEnd"),Ar("onMouseEnter",["mouseout","mouseover"]),Ar("onMouseLeave",["mouseout","mouseover"]),Ar("onPointerEnter",["pointerout","pointerover"]),Ar("onPointerLeave",["pointerout","pointerover"]),Ys("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Ys("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Ys("onBeforeInput",["compositionend","keypress","textInput","paste"]),Ys("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Ys("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Ys("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var uf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),D4=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(uf));function M_(l,h){h=(h&4)!==0;for(var p=0;p<l.length;p++){var y=l[p],w=y.event;y=y.listeners;e:{var I=void 0;if(h)for(var $=y.length-1;0<=$;$--){var z=y[$],Y=z.instance,he=z.currentTarget;if(z=z.listener,Y!==I&&w.isPropagationStopped())break e;I=z,w.currentTarget=he;try{I(w)}catch(xe){Gg(xe)}w.currentTarget=null,I=Y}else for($=0;$<y.length;$++){if(z=y[$],Y=z.instance,he=z.currentTarget,z=z.listener,Y!==I&&w.isPropagationStopped())break e;I=z,w.currentTarget=he;try{I(w)}catch(xe){Gg(xe)}w.currentTarget=null,I=Y}}}}function kt(l,h){var p=h[ia];p===void 0&&(p=h[ia]=new Set);var y=l+"__bubble";p.has(y)||(F_(h,l,2,!1),p.add(y))}function $0(l,h,p){var y=0;h&&(y|=4),F_(p,l,y,h)}var ry="_reactListening"+Math.random().toString(36).slice(2);function R0(l){if(!l[ry]){l[ry]=!0,pg.forEach(function(p){p!=="selectionchange"&&(D4.has(p)||$0(p,!1,l),$0(p,!0,l))});var h=l.nodeType===9?l:l.ownerDocument;h===null||h[ry]||(h[ry]=!0,$0("selectionchange",!1,h))}}function F_(l,h,p,y){switch(sC(h)){case 2:var w=iU;break;case 8:w=oU;break;default:w=q0}p=w.bind(null,h,p,l),w=void 0,!at||h!=="touchstart"&&h!=="touchmove"&&h!=="wheel"||(w=!0),y?w!==void 0?l.addEventListener(h,p,{capture:!0,passive:w}):l.addEventListener(h,p,!0):w!==void 0?l.addEventListener(h,p,{passive:w}):l.addEventListener(h,p,!1)}function D0(l,h,p,y,w){var I=y;if((h&1)===0&&(h&2)===0&&y!==null)e:for(;;){if(y===null)return;var $=y.tag;if($===3||$===4){var z=y.stateNode.containerInfo;if(z===w)break;if($===4)for($=y.return;$!==null;){var Y=$.tag;if((Y===3||Y===4)&&$.stateNode.containerInfo===w)return;$=$.return}for(;z!==null;){if($=fa(z),$===null)return;if(Y=$.tag,Y===5||Y===6||Y===26||Y===27){y=I=$;continue e}z=z.parentNode}}y=y.return}Ce(function(){var he=I,xe=Mi(p),Se=[];e:{var fe=gN.get(l);if(fe!==void 0){var me=il,et=l;switch(l){case"keypress":if(sl(p)===0)break e;case"keydown":case"keyup":me=_B;break;case"focusin":et="focus",me=rx;break;case"focusout":et="blur",me=rx;break;case"beforeblur":case"afterblur":me=rx;break;case"click":if(p.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":me=HI;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":me=mB;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":me=AB;break;case hN:case pN:case fN:me=bB;break;case mN:me=RB;break;case"scroll":case"scrollend":me=pB;break;case"wheel":me=MB;break;case"copy":case"cut":case"paste":me=xB;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":me=jI;break;case"toggle":case"beforetoggle":me=OB}var Xe=(h&4)!==0,Zt=!Xe&&(l==="scroll"||l==="scrollend"),oe=Xe?fe!==null?fe+"Capture":null:fe;Xe=[];for(var re=he,de;re!==null;){var we=re;if(de=we.stateNode,we=we.tag,we!==5&&we!==26&&we!==27||de===null||oe===null||(we=Ge(re,oe),we!=null&&Xe.push(cf(re,we,de))),Zt)break;re=re.return}0<Xe.length&&(fe=new me(fe,et,null,p,xe),Se.push({event:fe,listeners:Xe}))}}if((h&7)===0){e:{if(fe=l==="mouseover"||l==="pointerover",me=l==="mouseout"||l==="pointerout",fe&&p!==Wc&&(et=p.relatedTarget||p.fromElement)&&(fa(et)||et[Ye]))break e;if((me||fe)&&(fe=xe.window===xe?xe:(fe=xe.ownerDocument)?fe.defaultView||fe.parentWindow:window,me?(et=p.relatedTarget||p.toElement,me=he,et=et?fa(et):null,et!==null&&(Zt=s(et),Xe=et.tag,et!==Zt||Xe!==5&&Xe!==27&&Xe!==6)&&(et=null)):(me=null,et=he),me!==et)){if(Xe=HI,we="onMouseLeave",oe="onMouseEnter",re="mouse",(l==="pointerout"||l==="pointerover")&&(Xe=jI,we="onPointerLeave",oe="onPointerEnter",re="pointer"),Zt=me==null?fe:ws(me),de=et==null?fe:ws(et),fe=new Xe(we,re+"leave",me,p,xe),fe.target=Zt,fe.relatedTarget=de,we=null,fa(xe)===he&&(Xe=new Xe(oe,re+"enter",et,p,xe),Xe.target=de,Xe.relatedTarget=Zt,we=Xe),Zt=we,me&&et)t:{for(Xe=me,oe=et,re=0,de=Xe;de;de=fd(de))re++;for(de=0,we=oe;we;we=fd(we))de++;for(;0<re-de;)Xe=fd(Xe),re--;for(;0<de-re;)oe=fd(oe),de--;for(;re--;){if(Xe===oe||oe!==null&&Xe===oe.alternate)break t;Xe=fd(Xe),oe=fd(oe)}Xe=null}else Xe=null;me!==null&&O_(Se,fe,me,Xe,!1),et!==null&&Zt!==null&&O_(Se,Zt,et,Xe,!0)}}e:{if(fe=he?ws(he):window,me=fe.nodeName&&fe.nodeName.toLowerCase(),me==="select"||me==="input"&&fe.type==="file")var Ue=tN;else if(JI(fe))if(aN)Ue=qB;else{Ue=GB;var vt=VB}else me=fe.nodeName,!me||me.toLowerCase()!=="input"||fe.type!=="checkbox"&&fe.type!=="radio"?he&&rl(he.elementType)&&(Ue=tN):Ue=HB;if(Ue&&(Ue=Ue(l,he))){eN(Se,Ue,p,xe);break e}vt&&vt(l,fe,he),l==="focusout"&&he&&fe.type==="number"&&he.memoizedProps.value!=null&&Bc(fe,"number",fe.value)}switch(vt=he?ws(he):window,l){case"focusin":(JI(vt)||vt.contentEditable==="true")&&(Gc=vt,cx=he,Fp=null);break;case"focusout":Fp=cx=Gc=null;break;case"mousedown":dx=!0;break;case"contextmenu":case"mouseup":case"dragend":dx=!1,cN(Se,p,xe);break;case"selectionchange":if(KB)break;case"keydown":case"keyup":cN(Se,p,xe)}var He;if(ix)e:{switch(l){case"compositionstart":var Ze="onCompositionStart";break e;case"compositionend":Ze="onCompositionEnd";break e;case"compositionupdate":Ze="onCompositionUpdate";break e}Ze=void 0}else Vc?ZI(l,p)&&(Ze="onCompositionEnd"):l==="keydown"&&p.keyCode===229&&(Ze="onCompositionStart");Ze&&(KI&&p.locale!=="ko"&&(Vc||Ze!=="onCompositionStart"?Ze==="onCompositionEnd"&&Vc&&(He=$r()):(Oe=xe,jt="value"in Oe?Oe.value:Oe.textContent,Vc=!0)),vt=sy(he,Ze),0<vt.length&&(Ze=new qI(Ze,l,null,p,xe),Se.push({event:Ze,listeners:vt}),He?Ze.data=He:(He=QI(p),He!==null&&(Ze.data=He)))),(He=LB?BB(l,p):UB(l,p))&&(Ze=sy(he,"onBeforeInput"),0<Ze.length&&(vt=new qI("onBeforeInput","beforeinput",null,p,xe),Se.push({event:vt,listeners:Ze}),vt.data=He)),A4(Se,l,he,p,xe)}M_(Se,h)})}function cf(l,h,p){return{instance:l,listener:h,currentTarget:p}}function sy(l,h){for(var p=h+"Capture",y=[];l!==null;){var w=l,I=w.stateNode;if(w=w.tag,w!==5&&w!==26&&w!==27||I===null||(w=Ge(l,p),w!=null&&y.unshift(cf(l,w,I)),w=Ge(l,h),w!=null&&y.push(cf(l,w,I))),l.tag===3)return y;l=l.return}return[]}function fd(l){if(l===null)return null;do l=l.return;while(l&&l.tag!==5&&l.tag!==27);return l||null}function O_(l,h,p,y,w){for(var I=h._reactName,$=[];p!==null&&p!==y;){var z=p,Y=z.alternate,he=z.stateNode;if(z=z.tag,Y!==null&&Y===y)break;z!==5&&z!==26&&z!==27||he===null||(Y=he,w?(he=Ge(p,I),he!=null&&$.unshift(cf(p,he,Y))):w||(he=Ge(p,I),he!=null&&$.push(cf(p,he,Y)))),p=p.return}$.length!==0&&l.push({event:h,listeners:$})}var M4=/\r\n?/g,F4=/\u0000|\uFFFD/g;function z_(l){return(typeof l=="string"?l:""+l).replace(M4,`
`).replace(F4,"")}function L_(l,h){return h=z_(h),z_(l)===h}function iy(){}function Yt(l,h,p,y,w,I){switch(p){case"children":typeof y=="string"?h==="body"||h==="textarea"&&y===""||Qs(l,y):(typeof y=="number"||typeof y=="bigint")&&h!=="body"&&Qs(l,""+y);break;case"className":zc(l,"class",y);break;case"tabIndex":zc(l,"tabindex",y);break;case"dir":case"role":case"viewBox":case"width":case"height":zc(l,p,y);break;case"style":Cp(l,y,I);break;case"data":if(h!=="object"){zc(l,"data",y);break}case"src":case"href":if(y===""&&(h!=="a"||p!=="href")){l.removeAttribute(p);break}if(y==null||typeof y=="function"||typeof y=="symbol"||typeof y=="boolean"){l.removeAttribute(p);break}y=Js(""+y),l.setAttribute(p,y);break;case"action":case"formAction":if(typeof y=="function"){l.setAttribute(p,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof I=="function"&&(p==="formAction"?(h!=="input"&&Yt(l,h,"name",w.name,w,null),Yt(l,h,"formEncType",w.formEncType,w,null),Yt(l,h,"formMethod",w.formMethod,w,null),Yt(l,h,"formTarget",w.formTarget,w,null)):(Yt(l,h,"encType",w.encType,w,null),Yt(l,h,"method",w.method,w,null),Yt(l,h,"target",w.target,w,null)));if(y==null||typeof y=="symbol"||typeof y=="boolean"){l.removeAttribute(p);break}y=Js(""+y),l.setAttribute(p,y);break;case"onClick":y!=null&&(l.onclick=iy);break;case"onScroll":y!=null&&kt("scroll",l);break;case"onScrollEnd":y!=null&&kt("scrollend",l);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(n(61));if(p=y.__html,p!=null){if(w.children!=null)throw Error(n(60));l.innerHTML=p}}break;case"multiple":l.multiple=y&&typeof y!="function"&&typeof y!="symbol";break;case"muted":l.muted=y&&typeof y!="function"&&typeof y!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(y==null||typeof y=="function"||typeof y=="boolean"||typeof y=="symbol"){l.removeAttribute("xlink:href");break}p=Js(""+y),l.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",p);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":y!=null&&typeof y!="function"&&typeof y!="symbol"?l.setAttribute(p,""+y):l.removeAttribute(p);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":y&&typeof y!="function"&&typeof y!="symbol"?l.setAttribute(p,""):l.removeAttribute(p);break;case"capture":case"download":y===!0?l.setAttribute(p,""):y!==!1&&y!=null&&typeof y!="function"&&typeof y!="symbol"?l.setAttribute(p,y):l.removeAttribute(p);break;case"cols":case"rows":case"size":case"span":y!=null&&typeof y!="function"&&typeof y!="symbol"&&!isNaN(y)&&1<=y?l.setAttribute(p,y):l.removeAttribute(p);break;case"rowSpan":case"start":y==null||typeof y=="function"||typeof y=="symbol"||isNaN(y)?l.removeAttribute(p):l.setAttribute(p,y);break;case"popover":kt("beforetoggle",l),kt("toggle",l),Di(l,"popover",y);break;case"xlinkActuate":Qr(l,"http://www.w3.org/1999/xlink","xlink:actuate",y);break;case"xlinkArcrole":Qr(l,"http://www.w3.org/1999/xlink","xlink:arcrole",y);break;case"xlinkRole":Qr(l,"http://www.w3.org/1999/xlink","xlink:role",y);break;case"xlinkShow":Qr(l,"http://www.w3.org/1999/xlink","xlink:show",y);break;case"xlinkTitle":Qr(l,"http://www.w3.org/1999/xlink","xlink:title",y);break;case"xlinkType":Qr(l,"http://www.w3.org/1999/xlink","xlink:type",y);break;case"xmlBase":Qr(l,"http://www.w3.org/XML/1998/namespace","xml:base",y);break;case"xmlLang":Qr(l,"http://www.w3.org/XML/1998/namespace","xml:lang",y);break;case"xmlSpace":Qr(l,"http://www.w3.org/XML/1998/namespace","xml:space",y);break;case"is":Di(l,"is",y);break;case"innerText":case"textContent":break;default:(!(2<p.length)||p[0]!=="o"&&p[0]!=="O"||p[1]!=="n"&&p[1]!=="N")&&(p=Uc.get(p)||p,Di(l,p,y))}}function M0(l,h,p,y,w,I){switch(p){case"style":Cp(l,y,I);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(n(61));if(p=y.__html,p!=null){if(w.children!=null)throw Error(n(60));l.innerHTML=p}}break;case"children":typeof y=="string"?Qs(l,y):(typeof y=="number"||typeof y=="bigint")&&Qs(l,""+y);break;case"onScroll":y!=null&&kt("scroll",l);break;case"onScrollEnd":y!=null&&kt("scrollend",l);break;case"onClick":y!=null&&(l.onclick=iy);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!fg.hasOwnProperty(p))e:{if(p[0]==="o"&&p[1]==="n"&&(w=p.endsWith("Capture"),h=p.slice(2,w?p.length-7:void 0),I=l[qe]||null,I=I!=null?I[p]:null,typeof I=="function"&&l.removeEventListener(h,I,w),typeof y=="function")){typeof I!="function"&&I!==null&&(p in l?l[p]=null:l.hasAttribute(p)&&l.removeAttribute(p)),l.addEventListener(h,y,w);break e}p in l?l[p]=y:y===!0?l.setAttribute(p,""):Di(l,p,y)}}}function gn(l,h,p){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":kt("error",l),kt("load",l);var y=!1,w=!1,I;for(I in p)if(p.hasOwnProperty(I)){var $=p[I];if($!=null)switch(I){case"src":y=!0;break;case"srcSet":w=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(n(137,h));default:Yt(l,h,I,$,p,null)}}w&&Yt(l,h,"srcSet",p.srcSet,p,null),y&&Yt(l,h,"src",p.src,p,null);return;case"input":kt("invalid",l);var z=I=$=w=null,Y=null,he=null;for(y in p)if(p.hasOwnProperty(y)){var xe=p[y];if(xe!=null)switch(y){case"name":w=xe;break;case"type":$=xe;break;case"checked":Y=xe;break;case"defaultChecked":he=xe;break;case"value":I=xe;break;case"defaultValue":z=xe;break;case"children":case"dangerouslySetInnerHTML":if(xe!=null)throw Error(n(137,h));break;default:Yt(l,h,y,xe,p,null)}}yg(l,I,z,Y,he,$,w,!1),Lc(l);return;case"select":kt("invalid",l),y=$=I=null;for(w in p)if(p.hasOwnProperty(w)&&(z=p[w],z!=null))switch(w){case"value":I=z;break;case"defaultValue":$=z;break;case"multiple":y=z;default:Yt(l,h,w,z,p,null)}h=I,p=$,l.multiple=!!y,h!=null?Jr(l,!!y,h,!1):p!=null&&Jr(l,!!y,p,!0);return;case"textarea":kt("invalid",l),I=w=y=null;for($ in p)if(p.hasOwnProperty($)&&(z=p[$],z!=null))switch($){case"value":y=z;break;case"defaultValue":w=z;break;case"children":I=z;break;case"dangerouslySetInnerHTML":if(z!=null)throw Error(n(91));break;default:Yt(l,h,$,z,p,null)}Np(l,y,w,I),Lc(l);return;case"option":for(Y in p)if(p.hasOwnProperty(Y)&&(y=p[Y],y!=null))switch(Y){case"selected":l.selected=y&&typeof y!="function"&&typeof y!="symbol";break;default:Yt(l,h,Y,y,p,null)}return;case"dialog":kt("beforetoggle",l),kt("toggle",l),kt("cancel",l),kt("close",l);break;case"iframe":case"object":kt("load",l);break;case"video":case"audio":for(y=0;y<uf.length;y++)kt(uf[y],l);break;case"image":kt("error",l),kt("load",l);break;case"details":kt("toggle",l);break;case"embed":case"source":case"link":kt("error",l),kt("load",l);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(he in p)if(p.hasOwnProperty(he)&&(y=p[he],y!=null))switch(he){case"children":case"dangerouslySetInnerHTML":throw Error(n(137,h));default:Yt(l,h,he,y,p,null)}return;default:if(rl(h)){for(xe in p)p.hasOwnProperty(xe)&&(y=p[xe],y!==void 0&&M0(l,h,xe,y,p,void 0));return}}for(z in p)p.hasOwnProperty(z)&&(y=p[z],y!=null&&Yt(l,h,z,y,p,null))}function O4(l,h,p,y){switch(h){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var w=null,I=null,$=null,z=null,Y=null,he=null,xe=null;for(me in p){var Se=p[me];if(p.hasOwnProperty(me)&&Se!=null)switch(me){case"checked":break;case"value":break;case"defaultValue":Y=Se;default:y.hasOwnProperty(me)||Yt(l,h,me,null,y,Se)}}for(var fe in y){var me=y[fe];if(Se=p[fe],y.hasOwnProperty(fe)&&(me!=null||Se!=null))switch(fe){case"type":I=me;break;case"name":w=me;break;case"checked":he=me;break;case"defaultChecked":xe=me;break;case"value":$=me;break;case"defaultValue":z=me;break;case"children":case"dangerouslySetInnerHTML":if(me!=null)throw Error(n(137,h));break;default:me!==Se&&Yt(l,h,fe,me,y,Se)}}Sp(l,$,z,Y,he,xe,I,w);return;case"select":me=$=z=fe=null;for(I in p)if(Y=p[I],p.hasOwnProperty(I)&&Y!=null)switch(I){case"value":break;case"multiple":me=Y;default:y.hasOwnProperty(I)||Yt(l,h,I,null,y,Y)}for(w in y)if(I=y[w],Y=p[w],y.hasOwnProperty(w)&&(I!=null||Y!=null))switch(w){case"value":fe=I;break;case"defaultValue":z=I;break;case"multiple":$=I;default:I!==Y&&Yt(l,h,w,I,y,Y)}h=z,p=$,y=me,fe!=null?Jr(l,!!p,fe,!1):!!y!=!!p&&(h!=null?Jr(l,!!p,h,!0):Jr(l,!!p,p?[]:"",!1));return;case"textarea":me=fe=null;for(z in p)if(w=p[z],p.hasOwnProperty(z)&&w!=null&&!y.hasOwnProperty(z))switch(z){case"value":break;case"children":break;default:Yt(l,h,z,null,y,w)}for($ in y)if(w=y[$],I=p[$],y.hasOwnProperty($)&&(w!=null||I!=null))switch($){case"value":fe=w;break;case"defaultValue":me=w;break;case"children":break;case"dangerouslySetInnerHTML":if(w!=null)throw Error(n(91));break;default:w!==I&&Yt(l,h,$,w,y,I)}Ip(l,fe,me);return;case"option":for(var et in p)if(fe=p[et],p.hasOwnProperty(et)&&fe!=null&&!y.hasOwnProperty(et))switch(et){case"selected":l.selected=!1;break;default:Yt(l,h,et,null,y,fe)}for(Y in y)if(fe=y[Y],me=p[Y],y.hasOwnProperty(Y)&&fe!==me&&(fe!=null||me!=null))switch(Y){case"selected":l.selected=fe&&typeof fe!="function"&&typeof fe!="symbol";break;default:Yt(l,h,Y,fe,y,me)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Xe in p)fe=p[Xe],p.hasOwnProperty(Xe)&&fe!=null&&!y.hasOwnProperty(Xe)&&Yt(l,h,Xe,null,y,fe);for(he in y)if(fe=y[he],me=p[he],y.hasOwnProperty(he)&&fe!==me&&(fe!=null||me!=null))switch(he){case"children":case"dangerouslySetInnerHTML":if(fe!=null)throw Error(n(137,h));break;default:Yt(l,h,he,fe,y,me)}return;default:if(rl(h)){for(var Zt in p)fe=p[Zt],p.hasOwnProperty(Zt)&&fe!==void 0&&!y.hasOwnProperty(Zt)&&M0(l,h,Zt,void 0,y,fe);for(xe in y)fe=y[xe],me=p[xe],!y.hasOwnProperty(xe)||fe===me||fe===void 0&&me===void 0||M0(l,h,xe,fe,y,me);return}}for(var oe in p)fe=p[oe],p.hasOwnProperty(oe)&&fe!=null&&!y.hasOwnProperty(oe)&&Yt(l,h,oe,null,y,fe);for(Se in y)fe=y[Se],me=p[Se],!y.hasOwnProperty(Se)||fe===me||fe==null&&me==null||Yt(l,h,Se,fe,y,me)}var F0=null,O0=null;function oy(l){return l.nodeType===9?l:l.ownerDocument}function B_(l){switch(l){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function U_(l,h){if(l===0)switch(h){case"svg":return 1;case"math":return 2;default:return 0}return l===1&&h==="foreignObject"?0:l}function z0(l,h){return l==="textarea"||l==="noscript"||typeof h.children=="string"||typeof h.children=="number"||typeof h.children=="bigint"||typeof h.dangerouslySetInnerHTML=="object"&&h.dangerouslySetInnerHTML!==null&&h.dangerouslySetInnerHTML.__html!=null}var L0=null;function z4(){var l=window.event;return l&&l.type==="popstate"?l===L0?!1:(L0=l,!0):(L0=null,!1)}var P_=typeof setTimeout=="function"?setTimeout:void 0,L4=typeof clearTimeout=="function"?clearTimeout:void 0,W_=typeof Promise=="function"?Promise:void 0,B4=typeof queueMicrotask=="function"?queueMicrotask:typeof W_<"u"?function(l){return W_.resolve(null).then(l).catch(U4)}:P_;function U4(l){setTimeout(function(){throw l})}function Qi(l){return l==="head"}function V_(l,h){var p=h,y=0,w=0;do{var I=p.nextSibling;if(l.removeChild(p),I&&I.nodeType===8)if(p=I.data,p==="/$"){if(0<y&&8>y){p=y;var $=l.ownerDocument;if(p&1&&df($.documentElement),p&2&&df($.body),p&4)for(p=$.head,df(p),$=p.firstChild;$;){var z=$.nextSibling,Y=$.nodeName;$[Zr]||Y==="SCRIPT"||Y==="STYLE"||Y==="LINK"&&$.rel.toLowerCase()==="stylesheet"||p.removeChild($),$=z}}if(w===0){l.removeChild(I),vf(h);return}w--}else p==="$"||p==="$?"||p==="$!"?w++:y=p.charCodeAt(0)-48;else y=0;p=I}while(p);vf(h)}function B0(l){var h=l.firstChild;for(h&&h.nodeType===10&&(h=h.nextSibling);h;){var p=h;switch(h=h.nextSibling,p.nodeName){case"HTML":case"HEAD":case"BODY":B0(p),$i(p);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(p.rel.toLowerCase()==="stylesheet")continue}l.removeChild(p)}}function P4(l,h,p,y){for(;l.nodeType===1;){var w=p;if(l.nodeName.toLowerCase()!==h.toLowerCase()){if(!y&&(l.nodeName!=="INPUT"||l.type!=="hidden"))break}else if(y){if(!l[Zr])switch(h){case"meta":if(!l.hasAttribute("itemprop"))break;return l;case"link":if(I=l.getAttribute("rel"),I==="stylesheet"&&l.hasAttribute("data-precedence"))break;if(I!==w.rel||l.getAttribute("href")!==(w.href==null||w.href===""?null:w.href)||l.getAttribute("crossorigin")!==(w.crossOrigin==null?null:w.crossOrigin)||l.getAttribute("title")!==(w.title==null?null:w.title))break;return l;case"style":if(l.hasAttribute("data-precedence"))break;return l;case"script":if(I=l.getAttribute("src"),(I!==(w.src==null?null:w.src)||l.getAttribute("type")!==(w.type==null?null:w.type)||l.getAttribute("crossorigin")!==(w.crossOrigin==null?null:w.crossOrigin))&&I&&l.hasAttribute("async")&&!l.hasAttribute("itemprop"))break;return l;default:return l}}else if(h==="input"&&l.type==="hidden"){var I=w.name==null?null:""+w.name;if(w.type==="hidden"&&l.getAttribute("name")===I)return l}else return l;if(l=ns(l.nextSibling),l===null)break}return null}function W4(l,h,p){if(h==="")return null;for(;l.nodeType!==3;)if((l.nodeType!==1||l.nodeName!=="INPUT"||l.type!=="hidden")&&!p||(l=ns(l.nextSibling),l===null))return null;return l}function U0(l){return l.data==="$!"||l.data==="$?"&&l.ownerDocument.readyState==="complete"}function V4(l,h){var p=l.ownerDocument;if(l.data!=="$?"||p.readyState==="complete")h();else{var y=function(){h(),p.removeEventListener("DOMContentLoaded",y)};p.addEventListener("DOMContentLoaded",y),l._reactRetry=y}}function ns(l){for(;l!=null;l=l.nextSibling){var h=l.nodeType;if(h===1||h===3)break;if(h===8){if(h=l.data,h==="$"||h==="$!"||h==="$?"||h==="F!"||h==="F")break;if(h==="/$")return null}}return l}var P0=null;function G_(l){l=l.previousSibling;for(var h=0;l;){if(l.nodeType===8){var p=l.data;if(p==="$"||p==="$!"||p==="$?"){if(h===0)return l;h--}else p==="/$"&&h++}l=l.previousSibling}return null}function H_(l,h,p){switch(h=oy(p),l){case"html":if(l=h.documentElement,!l)throw Error(n(452));return l;case"head":if(l=h.head,!l)throw Error(n(453));return l;case"body":if(l=h.body,!l)throw Error(n(454));return l;default:throw Error(n(451))}}function df(l){for(var h=l.attributes;h.length;)l.removeAttributeNode(h[0]);$i(l)}var Lr=new Map,q_=new Set;function ly(l){return typeof l.getRootNode=="function"?l.getRootNode():l.nodeType===9?l:l.ownerDocument}var hi=X.d;X.d={f:G4,r:H4,D:q4,C:j4,L:K4,m:X4,X:Z4,S:Y4,M:Q4};function G4(){var l=hi.f(),h=Jg();return l||h}function H4(l){var h=zn(l);h!==null&&h.tag===5&&h.type==="form"?hT(h):hi.r(l)}var md=typeof document>"u"?null:document;function j_(l,h,p){var y=md;if(y&&typeof h=="string"&&h){var w=Xn(h);w='link[rel="'+l+'"][href="'+w+'"]',typeof p=="string"&&(w+='[crossorigin="'+p+'"]'),q_.has(w)||(q_.add(w),l={rel:l,crossOrigin:p,href:h},y.querySelector(w)===null&&(h=y.createElement("link"),gn(h,"link",l),xa(h),y.head.appendChild(h)))}}function q4(l){hi.D(l),j_("dns-prefetch",l,null)}function j4(l,h){hi.C(l,h),j_("preconnect",l,h)}function K4(l,h,p){hi.L(l,h,p);var y=md;if(y&&l&&h){var w='link[rel="preload"][as="'+Xn(h)+'"]';h==="image"&&p&&p.imageSrcSet?(w+='[imagesrcset="'+Xn(p.imageSrcSet)+'"]',typeof p.imageSizes=="string"&&(w+='[imagesizes="'+Xn(p.imageSizes)+'"]')):w+='[href="'+Xn(l)+'"]';var I=w;switch(h){case"style":I=gd(l);break;case"script":I=yd(l)}Lr.has(I)||(l=c({rel:"preload",href:h==="image"&&p&&p.imageSrcSet?void 0:l,as:h},p),Lr.set(I,l),y.querySelector(w)!==null||h==="style"&&y.querySelector(hf(I))||h==="script"&&y.querySelector(pf(I))||(h=y.createElement("link"),gn(h,"link",l),xa(h),y.head.appendChild(h)))}}function X4(l,h){hi.m(l,h);var p=md;if(p&&l){var y=h&&typeof h.as=="string"?h.as:"script",w='link[rel="modulepreload"][as="'+Xn(y)+'"][href="'+Xn(l)+'"]',I=w;switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":I=yd(l)}if(!Lr.has(I)&&(l=c({rel:"modulepreload",href:l},h),Lr.set(I,l),p.querySelector(w)===null)){switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(p.querySelector(pf(I)))return}y=p.createElement("link"),gn(y,"link",l),xa(y),p.head.appendChild(y)}}}function Y4(l,h,p){hi.S(l,h,p);var y=md;if(y&&l){var w=Ri(y).hoistableStyles,I=gd(l);h=h||"default";var $=w.get(I);if(!$){var z={loading:0,preload:null};if($=y.querySelector(hf(I)))z.loading=5;else{l=c({rel:"stylesheet",href:l,"data-precedence":h},p),(p=Lr.get(I))&&W0(l,p);var Y=$=y.createElement("link");xa(Y),gn(Y,"link",l),Y._p=new Promise(function(he,xe){Y.onload=he,Y.onerror=xe}),Y.addEventListener("load",function(){z.loading|=1}),Y.addEventListener("error",function(){z.loading|=2}),z.loading|=4,uy($,h,y)}$={type:"stylesheet",instance:$,count:1,state:z},w.set(I,$)}}}function Z4(l,h){hi.X(l,h);var p=md;if(p&&l){var y=Ri(p).hoistableScripts,w=yd(l),I=y.get(w);I||(I=p.querySelector(pf(w)),I||(l=c({src:l,async:!0},h),(h=Lr.get(w))&&V0(l,h),I=p.createElement("script"),xa(I),gn(I,"link",l),p.head.appendChild(I)),I={type:"script",instance:I,count:1,state:null},y.set(w,I))}}function Q4(l,h){hi.M(l,h);var p=md;if(p&&l){var y=Ri(p).hoistableScripts,w=yd(l),I=y.get(w);I||(I=p.querySelector(pf(w)),I||(l=c({src:l,async:!0,type:"module"},h),(h=Lr.get(w))&&V0(l,h),I=p.createElement("script"),xa(I),gn(I,"link",l),p.head.appendChild(I)),I={type:"script",instance:I,count:1,state:null},y.set(w,I))}}function K_(l,h,p,y){var w=(w=Ie.current)?ly(w):null;if(!w)throw Error(n(446));switch(l){case"meta":case"title":return null;case"style":return typeof p.precedence=="string"&&typeof p.href=="string"?(h=gd(p.href),p=Ri(w).hoistableStyles,y=p.get(h),y||(y={type:"style",instance:null,count:0,state:null},p.set(h,y)),y):{type:"void",instance:null,count:0,state:null};case"link":if(p.rel==="stylesheet"&&typeof p.href=="string"&&typeof p.precedence=="string"){l=gd(p.href);var I=Ri(w).hoistableStyles,$=I.get(l);if($||(w=w.ownerDocument||w,$={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},I.set(l,$),(I=w.querySelector(hf(l)))&&!I._p&&($.instance=I,$.state.loading=5),Lr.has(l)||(p={rel:"preload",as:"style",href:p.href,crossOrigin:p.crossOrigin,integrity:p.integrity,media:p.media,hrefLang:p.hrefLang,referrerPolicy:p.referrerPolicy},Lr.set(l,p),I||J4(w,l,p,$.state))),h&&y===null)throw Error(n(528,""));return $}if(h&&y!==null)throw Error(n(529,""));return null;case"script":return h=p.async,p=p.src,typeof p=="string"&&h&&typeof h!="function"&&typeof h!="symbol"?(h=yd(p),p=Ri(w).hoistableScripts,y=p.get(h),y||(y={type:"script",instance:null,count:0,state:null},p.set(h,y)),y):{type:"void",instance:null,count:0,state:null};default:throw Error(n(444,l))}}function gd(l){return'href="'+Xn(l)+'"'}function hf(l){return'link[rel="stylesheet"]['+l+"]"}function X_(l){return c({},l,{"data-precedence":l.precedence,precedence:null})}function J4(l,h,p,y){l.querySelector('link[rel="preload"][as="style"]['+h+"]")?y.loading=1:(h=l.createElement("link"),y.preload=h,h.addEventListener("load",function(){return y.loading|=1}),h.addEventListener("error",function(){return y.loading|=2}),gn(h,"link",p),xa(h),l.head.appendChild(h))}function yd(l){return'[src="'+Xn(l)+'"]'}function pf(l){return"script[async]"+l}function Y_(l,h,p){if(h.count++,h.instance===null)switch(h.type){case"style":var y=l.querySelector('style[data-href~="'+Xn(p.href)+'"]');if(y)return h.instance=y,xa(y),y;var w=c({},p,{"data-href":p.href,"data-precedence":p.precedence,href:null,precedence:null});return y=(l.ownerDocument||l).createElement("style"),xa(y),gn(y,"style",w),uy(y,p.precedence,l),h.instance=y;case"stylesheet":w=gd(p.href);var I=l.querySelector(hf(w));if(I)return h.state.loading|=4,h.instance=I,xa(I),I;y=X_(p),(w=Lr.get(w))&&W0(y,w),I=(l.ownerDocument||l).createElement("link"),xa(I);var $=I;return $._p=new Promise(function(z,Y){$.onload=z,$.onerror=Y}),gn(I,"link",y),h.state.loading|=4,uy(I,p.precedence,l),h.instance=I;case"script":return I=yd(p.src),(w=l.querySelector(pf(I)))?(h.instance=w,xa(w),w):(y=p,(w=Lr.get(I))&&(y=c({},p),V0(y,w)),l=l.ownerDocument||l,w=l.createElement("script"),xa(w),gn(w,"link",y),l.head.appendChild(w),h.instance=w);case"void":return null;default:throw Error(n(443,h.type))}else h.type==="stylesheet"&&(h.state.loading&4)===0&&(y=h.instance,h.state.loading|=4,uy(y,p.precedence,l));return h.instance}function uy(l,h,p){for(var y=p.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),w=y.length?y[y.length-1]:null,I=w,$=0;$<y.length;$++){var z=y[$];if(z.dataset.precedence===h)I=z;else if(I!==w)break}I?I.parentNode.insertBefore(l,I.nextSibling):(h=p.nodeType===9?p.head:p,h.insertBefore(l,h.firstChild))}function W0(l,h){l.crossOrigin==null&&(l.crossOrigin=h.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=h.referrerPolicy),l.title==null&&(l.title=h.title)}function V0(l,h){l.crossOrigin==null&&(l.crossOrigin=h.crossOrigin),l.referrerPolicy==null&&(l.referrerPolicy=h.referrerPolicy),l.integrity==null&&(l.integrity=h.integrity)}var cy=null;function Z_(l,h,p){if(cy===null){var y=new Map,w=cy=new Map;w.set(p,y)}else w=cy,y=w.get(p),y||(y=new Map,w.set(p,y));if(y.has(l))return y;for(y.set(l,null),p=p.getElementsByTagName(l),w=0;w<p.length;w++){var I=p[w];if(!(I[Zr]||I[dt]||l==="link"&&I.getAttribute("rel")==="stylesheet")&&I.namespaceURI!=="http://www.w3.org/2000/svg"){var $=I.getAttribute(h)||"";$=l+$;var z=y.get($);z?z.push(I):y.set($,[I])}}return y}function Q_(l,h,p){l=l.ownerDocument||l,l.head.insertBefore(p,h==="title"?l.querySelector("head > title"):null)}function eU(l,h,p){if(p===1||h.itemProp!=null)return!1;switch(l){case"meta":case"title":return!0;case"style":if(typeof h.precedence!="string"||typeof h.href!="string"||h.href==="")break;return!0;case"link":if(typeof h.rel!="string"||typeof h.href!="string"||h.href===""||h.onLoad||h.onError)break;switch(h.rel){case"stylesheet":return l=h.disabled,typeof h.precedence=="string"&&l==null;default:return!0}case"script":if(h.async&&typeof h.async!="function"&&typeof h.async!="symbol"&&!h.onLoad&&!h.onError&&h.src&&typeof h.src=="string")return!0}return!1}function J_(l){return!(l.type==="stylesheet"&&(l.state.loading&3)===0)}var ff=null;function tU(){}function aU(l,h,p){if(ff===null)throw Error(n(475));var y=ff;if(h.type==="stylesheet"&&(typeof p.media!="string"||matchMedia(p.media).matches!==!1)&&(h.state.loading&4)===0){if(h.instance===null){var w=gd(p.href),I=l.querySelector(hf(w));if(I){l=I._p,l!==null&&typeof l=="object"&&typeof l.then=="function"&&(y.count++,y=dy.bind(y),l.then(y,y)),h.state.loading|=4,h.instance=I,xa(I);return}I=l.ownerDocument||l,p=X_(p),(w=Lr.get(w))&&W0(p,w),I=I.createElement("link"),xa(I);var $=I;$._p=new Promise(function(z,Y){$.onload=z,$.onerror=Y}),gn(I,"link",p),h.instance=I}y.stylesheets===null&&(y.stylesheets=new Map),y.stylesheets.set(h,l),(l=h.state.preload)&&(h.state.loading&3)===0&&(y.count++,h=dy.bind(y),l.addEventListener("load",h),l.addEventListener("error",h))}}function nU(){if(ff===null)throw Error(n(475));var l=ff;return l.stylesheets&&l.count===0&&G0(l,l.stylesheets),0<l.count?function(h){var p=setTimeout(function(){if(l.stylesheets&&G0(l,l.stylesheets),l.unsuspend){var y=l.unsuspend;l.unsuspend=null,y()}},6e4);return l.unsuspend=h,function(){l.unsuspend=null,clearTimeout(p)}}:null}function dy(){if(this.count--,this.count===0){if(this.stylesheets)G0(this,this.stylesheets);else if(this.unsuspend){var l=this.unsuspend;this.unsuspend=null,l()}}}var hy=null;function G0(l,h){l.stylesheets=null,l.unsuspend!==null&&(l.count++,hy=new Map,h.forEach(rU,l),hy=null,dy.call(l))}function rU(l,h){if(!(h.state.loading&4)){var p=hy.get(l);if(p)var y=p.get(null);else{p=new Map,hy.set(l,p);for(var w=l.querySelectorAll("link[data-precedence],style[data-precedence]"),I=0;I<w.length;I++){var $=w[I];($.nodeName==="LINK"||$.getAttribute("media")!=="not all")&&(p.set($.dataset.precedence,$),y=$)}y&&p.set(null,y)}w=h.instance,$=w.getAttribute("data-precedence"),I=p.get($)||y,I===y&&p.set(null,w),p.set($,w),this.count++,y=dy.bind(this),w.addEventListener("load",y),w.addEventListener("error",y),I?I.parentNode.insertBefore(w,I.nextSibling):(l=l.nodeType===9?l.head:l,l.insertBefore(w,l.firstChild)),h.state.loading|=4}}var mf={$$typeof:N,Provider:null,Consumer:null,_currentValue:Q,_currentValue2:Q,_threadCount:0};function sU(l,h,p,y,w,I,$,z){this.tag=1,this.containerInfo=l,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=bs(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=bs(0),this.hiddenUpdates=bs(null),this.identifierPrefix=y,this.onUncaughtError=w,this.onCaughtError=I,this.onRecoverableError=$,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=z,this.incompleteTransitions=new Map}function eC(l,h,p,y,w,I,$,z,Y,he,xe,Se){return l=new sU(l,h,p,$,z,Y,he,Se),h=1,I===!0&&(h|=24),I=fr(3,null,null,h),l.current=I,I.stateNode=l,h=Nx(),h.refCount++,l.pooledCache=h,h.refCount++,I.memoizedState={element:y,isDehydrated:p,cache:h},Ex(I),l}function tC(l){return l?(l=Kc,l):Kc}function aC(l,h,p,y,w,I){w=tC(w),y.context===null?y.context=w:y.pendingContext=w,y=Bi(h),y.payload={element:p},I=I===void 0?null:I,I!==null&&(y.callback=I),p=Ui(l,y,h),p!==null&&(vr(p,l,h),Gp(p,l,h))}function nC(l,h){if(l=l.memoizedState,l!==null&&l.dehydrated!==null){var p=l.retryLane;l.retryLane=p!==0&&p<h?p:h}}function H0(l,h){nC(l,h),(l=l.alternate)&&nC(l,h)}function rC(l){if(l.tag===13){var h=jc(l,67108864);h!==null&&vr(h,l,67108864),H0(l,67108864)}}var py=!0;function iU(l,h,p,y){var w=W.T;W.T=null;var I=X.p;try{X.p=2,q0(l,h,p,y)}finally{X.p=I,W.T=w}}function oU(l,h,p,y){var w=W.T;W.T=null;var I=X.p;try{X.p=8,q0(l,h,p,y)}finally{X.p=I,W.T=w}}function q0(l,h,p,y){if(py){var w=j0(y);if(w===null)D0(l,h,y,fy,p),iC(l,y);else if(uU(w,l,h,p,y))y.stopPropagation();else if(iC(l,y),h&4&&-1<lU.indexOf(l)){for(;w!==null;){var I=zn(w);if(I!==null)switch(I.tag){case 3:if(I=I.stateNode,I.current.memoizedState.isDehydrated){var $=ra(I.pendingLanes);if($!==0){var z=I;for(z.pendingLanes|=2,z.entangledLanes|=2;$;){var Y=1<<31-va($);z.entanglements[1]|=Y,$&=~Y}_s(I),(Ut&6)===0&&(Zg=ot()+500,lf(0))}}break;case 13:z=jc(I,2),z!==null&&vr(z,I,2),Jg(),H0(I,2)}if(I=j0(y),I===null&&D0(l,h,y,fy,p),I===w)break;w=I}w!==null&&y.stopPropagation()}else D0(l,h,y,null,p)}}function j0(l){return l=Mi(l),K0(l)}var fy=null;function K0(l){if(fy=null,l=fa(l),l!==null){var h=s(l);if(h===null)l=null;else{var p=h.tag;if(p===13){if(l=i(h),l!==null)return l;l=null}else if(p===3){if(h.stateNode.current.memoizedState.isDehydrated)return h.tag===3?h.stateNode.containerInfo:null;l=null}else h!==l&&(l=null)}}return fy=l,null}function sC(l){switch(l){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Bt()){case pn:return 2;case na:return 8;case Fa:case Oa:return 32;case nn:return 268435456;default:return 32}default:return 32}}var X0=!1,Ji=null,eo=null,to=null,gf=new Map,yf=new Map,ao=[],lU="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function iC(l,h){switch(l){case"focusin":case"focusout":Ji=null;break;case"dragenter":case"dragleave":eo=null;break;case"mouseover":case"mouseout":to=null;break;case"pointerover":case"pointerout":gf.delete(h.pointerId);break;case"gotpointercapture":case"lostpointercapture":yf.delete(h.pointerId)}}function bf(l,h,p,y,w,I){return l===null||l.nativeEvent!==I?(l={blockedOn:h,domEventName:p,eventSystemFlags:y,nativeEvent:I,targetContainers:[w]},h!==null&&(h=zn(h),h!==null&&rC(h)),l):(l.eventSystemFlags|=y,h=l.targetContainers,w!==null&&h.indexOf(w)===-1&&h.push(w),l)}function uU(l,h,p,y,w){switch(h){case"focusin":return Ji=bf(Ji,l,h,p,y,w),!0;case"dragenter":return eo=bf(eo,l,h,p,y,w),!0;case"mouseover":return to=bf(to,l,h,p,y,w),!0;case"pointerover":var I=w.pointerId;return gf.set(I,bf(gf.get(I)||null,l,h,p,y,w)),!0;case"gotpointercapture":return I=w.pointerId,yf.set(I,bf(yf.get(I)||null,l,h,p,y,w)),!0}return!1}function oC(l){var h=fa(l.target);if(h!==null){var p=s(h);if(p!==null){if(h=p.tag,h===13){if(h=i(p),h!==null){l.blockedOn=h,De(l.priority,function(){if(p.tag===13){var y=br();y=ye(y);var w=jc(p,y);w!==null&&vr(w,p,y),H0(p,y)}});return}}else if(h===3&&p.stateNode.current.memoizedState.isDehydrated){l.blockedOn=p.tag===3?p.stateNode.containerInfo:null;return}}}l.blockedOn=null}function my(l){if(l.blockedOn!==null)return!1;for(var h=l.targetContainers;0<h.length;){var p=j0(l.nativeEvent);if(p===null){p=l.nativeEvent;var y=new p.constructor(p.type,p);Wc=y,p.target.dispatchEvent(y),Wc=null}else return h=zn(p),h!==null&&rC(h),l.blockedOn=p,!1;h.shift()}return!0}function lC(l,h,p){my(l)&&p.delete(h)}function cU(){X0=!1,Ji!==null&&my(Ji)&&(Ji=null),eo!==null&&my(eo)&&(eo=null),to!==null&&my(to)&&(to=null),gf.forEach(lC),yf.forEach(lC)}function gy(l,h){l.blockedOn===h&&(l.blockedOn=null,X0||(X0=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,cU)))}var yy=null;function uC(l){yy!==l&&(yy=l,e.unstable_scheduleCallback(e.unstable_NormalPriority,function(){yy===l&&(yy=null);for(var h=0;h<l.length;h+=3){var p=l[h],y=l[h+1],w=l[h+2];if(typeof y!="function"){if(K0(y||p)===null)continue;break}var I=zn(p);I!==null&&(l.splice(h,3),h-=3,Kx(I,{pending:!0,data:w,method:p.method,action:y},y,w))}}))}function vf(l){function h(Y){return gy(Y,l)}Ji!==null&&gy(Ji,l),eo!==null&&gy(eo,l),to!==null&&gy(to,l),gf.forEach(h),yf.forEach(h);for(var p=0;p<ao.length;p++){var y=ao[p];y.blockedOn===l&&(y.blockedOn=null)}for(;0<ao.length&&(p=ao[0],p.blockedOn===null);)oC(p),p.blockedOn===null&&ao.shift();if(p=(l.ownerDocument||l).$$reactFormReplay,p!=null)for(y=0;y<p.length;y+=3){var w=p[y],I=p[y+1],$=w[qe]||null;if(typeof I=="function")$||uC(p);else if($){var z=null;if(I&&I.hasAttribute("formAction")){if(w=I,$=I[qe]||null)z=$.formAction;else if(K0(w)!==null)continue}else z=$.action;typeof z=="function"?p[y+1]=z:(p.splice(y,3),y-=3),uC(p)}}}function Y0(l){this._internalRoot=l}by.prototype.render=Y0.prototype.render=function(l){var h=this._internalRoot;if(h===null)throw Error(n(409));var p=h.current,y=br();aC(p,y,l,h,null,null)},by.prototype.unmount=Y0.prototype.unmount=function(){var l=this._internalRoot;if(l!==null){this._internalRoot=null;var h=l.containerInfo;aC(l.current,2,null,l,null,null),Jg(),h[Ye]=null}};function by(l){this._internalRoot=l}by.prototype.unstable_scheduleHydration=function(l){if(l){var h=Ve();l={blockedOn:null,target:l,priority:h};for(var p=0;p<ao.length&&h!==0&&h<ao[p].priority;p++);ao.splice(p,0,l),p===0&&oC(l)}};var cC=t.version;if(cC!=="19.1.0")throw Error(n(527,cC,"19.1.0"));X.findDOMNode=function(l){var h=l._reactInternals;if(h===void 0)throw typeof l.render=="function"?Error(n(188)):(l=Object.keys(l).join(","),Error(n(268,l)));return l=u(h),l=l!==null?d(l):null,l=l===null?null:l.stateNode,l};var dU={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:W,reconcilerVersion:"19.1.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var vy=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vy.isDisabled&&vy.supportsFiber)try{Na=vy.inject(dU),$t=vy}catch{}}return wf.createRoot=function(l,h){if(!r(l))throw Error(n(299));var p=!1,y="",w=TT,I=_T,$=CT,z=null;return h!=null&&(h.unstable_strictMode===!0&&(p=!0),h.identifierPrefix!==void 0&&(y=h.identifierPrefix),h.onUncaughtError!==void 0&&(w=h.onUncaughtError),h.onCaughtError!==void 0&&(I=h.onCaughtError),h.onRecoverableError!==void 0&&($=h.onRecoverableError),h.unstable_transitionCallbacks!==void 0&&(z=h.unstable_transitionCallbacks)),h=eC(l,1,!1,null,null,p,y,w,I,$,z,null),l[Ye]=h.current,R0(l),new Y0(h)},wf.hydrateRoot=function(l,h,p){if(!r(l))throw Error(n(299));var y=!1,w="",I=TT,$=_T,z=CT,Y=null,he=null;return p!=null&&(p.unstable_strictMode===!0&&(y=!0),p.identifierPrefix!==void 0&&(w=p.identifierPrefix),p.onUncaughtError!==void 0&&(I=p.onUncaughtError),p.onCaughtError!==void 0&&($=p.onCaughtError),p.onRecoverableError!==void 0&&(z=p.onRecoverableError),p.unstable_transitionCallbacks!==void 0&&(Y=p.unstable_transitionCallbacks),p.formState!==void 0&&(he=p.formState)),h=eC(l,1,!0,h,p??null,y,w,I,$,z,Y,he),h.context=tC(null),p=h.current,y=br(),y=ye(y),w=Bi(y),w.callback=null,Ui(p,w,y),p=y,h.current.lanes=p,vs(h,p),_s(h),l[Ye]=h.current,R0(l),new by(h)},wf.version="19.1.0",wf}var xC;function wU(){if(xC)return J0.exports;xC=1;function e(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}return e(),J0.exports=xU(),J0.exports}var kU=wU();function wC({text:e,btnClasses:t,onClick:a}){return it.jsx("button",{onClick:a,className:` min-w-[140px] px-4 py-2 text-sm font-semibold rounded-md ${t}`,children:e})}var SU=Object.defineProperty,IU=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,a)=>(typeof require<"u"?require:t)[a]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),$1=(e,t)=>{for(var a in t)SU(e,a,{get:t[a],enumerable:!0})},NU={};$1(NU,{Abs:()=>Kd,Acos:()=>iu,Acosh:()=>ou,AdadeltaOptimizer:()=>Zk,AdagradOptimizer:()=>Qk,AdamOptimizer:()=>Jk,AdamaxOptimizer:()=>eS,Add:()=>Oo,AddN:()=>lu,All:()=>Xd,Any:()=>Yd,ArgMax:()=>Zd,ArgMin:()=>Qd,Asin:()=>uu,Asinh:()=>cu,Atan:()=>du,Atan2:()=>pu,Atanh:()=>hu,AvgPool:()=>fu,AvgPool3D:()=>Jd,AvgPool3DGrad:()=>dm,AvgPoolGrad:()=>cm,BackendWasm:()=>bL,BatchMatMul:()=>mu,BatchToSpaceND:()=>eh,Bincount:()=>th,BitwiseAnd:()=>ah,BroadcastArgs:()=>hm,BroadcastTo:()=>IA,Callback:()=>yM,CallbackList:()=>cD,Cast:()=>gu,Ceil:()=>yu,ClipByValue:()=>zo,Complex:()=>Tb,ComplexAbs:()=>pm,Concat:()=>nh,Conv2D:()=>bu,Conv2DBackpropFilter:()=>_b,Conv2DBackpropInput:()=>vu,Conv3D:()=>xu,Conv3DBackpropFilterV2:()=>rh,Conv3DBackpropInputV2:()=>sh,Cos:()=>wu,Cosh:()=>ku,CropAndResize:()=>oh,Cumprod:()=>ih,Cumsum:()=>Su,CustomCallback:()=>hD,DataStorage:()=>Sb,DenseBincount:()=>fm,DepthToSpace:()=>lh,DepthwiseConv2dNative:()=>Iu,DepthwiseConv2dNativeBackpropFilter:()=>Cb,DepthwiseConv2dNativeBackpropInput:()=>Eb,Diag:()=>mm,Dilation2D:()=>Nu,Dilation2DBackpropFilter:()=>$d,Dilation2DBackpropInput:()=>Ad,Draw:()=>Ab,ENV:()=>O1,EarlyStopping:()=>bM,Einsum:()=>$b,Elu:()=>_u,EluGrad:()=>uh,Environment:()=>kA,Equal:()=>ch,Erf:()=>Cu,Exp:()=>Eu,ExpandDims:()=>dh,Expm1:()=>Au,FFT:()=>Rb,Fill:()=>gm,FlipLeftRight:()=>hh,Floor:()=>$u,FloorDiv:()=>Ru,FromPixels:()=>Xy,FusedBatchNorm:()=>Du,FusedConv2D:()=>Ul,FusedDepthwiseConv2D:()=>Pl,GPGPUContext:()=>Gy,GatherNd:()=>fh,GatherV2:()=>ph,GraphModel:()=>U2,Greater:()=>mh,GreaterEqual:()=>Mu,History:()=>dD,IFFT:()=>Db,Identity:()=>Fu,Imag:()=>Mb,InputSpec:()=>Ea,IsFinite:()=>Ou,IsInf:()=>zu,IsNan:()=>Lu,KernelBackend:()=>lm,LRN:()=>Wu,LRNGrad:()=>kh,LayerVariable:()=>aD,LayersModel:()=>bi,LeakyRelu:()=>Bu,Less:()=>gh,LessEqual:()=>yh,LinSpace:()=>bh,Log:()=>Uu,Log1p:()=>Pu,LogSoftmax:()=>TA,LogicalAnd:()=>vh,LogicalNot:()=>xh,LogicalOr:()=>wh,LogicalXor:()=>NA,LowerBound:()=>gP,MathBackendCPU:()=>V2,MathBackendWebGL:()=>yI,MatrixBandPart:()=>yP,Max:()=>Vu,MaxPool:()=>Hu,MaxPool3D:()=>Sh,MaxPool3DGrad:()=>bm,MaxPoolGrad:()=>ym,MaxPoolWithArgmax:()=>vm,Maximum:()=>Gu,Mean:()=>qu,Min:()=>ju,Minimum:()=>Ku,MirrorPad:()=>Xu,Mod:()=>Yu,MomentumOptimizer:()=>tS,Multinomial:()=>Ih,Multiply:()=>Zu,Neg:()=>Nh,NonMaxSuppressionV3:()=>_h,NonMaxSuppressionV4:()=>Ch,NonMaxSuppressionV5:()=>Eh,NotEqual:()=>Th,OP_SCOPE_SUFFIX:()=>P1,OneHot:()=>Qu,OnesLike:()=>Ah,Optimizer:()=>Ci,OptimizerConstructors:()=>FR,Pack:()=>$h,PadV2:()=>Ju,Pool:()=>bP,Pow:()=>ec,Prelu:()=>tc,Prod:()=>ac,RMSPropOptimizer:()=>aS,RNN:()=>Ei,RaggedGather:()=>Fb,RaggedRange:()=>Ob,RaggedTensorToTensor:()=>zb,Range:()=>xm,Rank:()=>Iw,Real:()=>Lb,RealDiv:()=>Tu,Reciprocal:()=>nc,Reduction:()=>Nn,Relu:()=>rc,Relu6:()=>oc,Reshape:()=>Rh,ResizeBilinear:()=>ic,ResizeBilinearGrad:()=>Mh,ResizeNearestNeighbor:()=>sc,ResizeNearestNeighborGrad:()=>Dh,Reverse:()=>lc,RotateWithOffset:()=>Xh,Round:()=>uc,Rsqrt:()=>cc,SGDOptimizer:()=>xv,ScatterNd:()=>Fh,SearchSorted:()=>zh,Select:()=>Lh,Selu:()=>dc,Sequential:()=>Dv,Sigmoid:()=>mc,Sign:()=>fc,Sin:()=>hc,Sinh:()=>pc,Slice:()=>Bh,Softmax:()=>vc,Softplus:()=>gc,SpaceToBatchND:()=>Uh,SparseFillEmptyRows:()=>wm,SparseReshape:()=>Wh,SparseSegmentMean:()=>km,SparseSegmentSum:()=>Sm,SparseToDense:()=>Vh,SplitV:()=>Ph,Sqrt:()=>yc,Square:()=>Im,SquaredDifference:()=>xc,StaticRegexReplace:()=>Nm,Step:()=>Bo,StridedSlice:()=>Gh,StringNGrams:()=>Tm,StringSplit:()=>_m,StringToHashBucketFast:()=>Cm,Sub:()=>wc,Sum:()=>bc,SymbolicTensor:()=>ps,Tan:()=>kc,Tanh:()=>Sc,Tensor:()=>ht,TensorBuffer:()=>Aa,TensorScatterUpdate:()=>Oh,Tile:()=>Lo,TopK:()=>Hh,Transform:()=>qh,Transpose:()=>yi,Unique:()=>Em,Unpack:()=>jh,UnsortedSegmentSum:()=>Am,UpperBound:()=>vP,Variable:()=>Wl,ZerosLike:()=>Kh,_FusedMatMul:()=>Bl,abs:()=>Ca,acos:()=>q1,acosh:()=>j1,add:()=>ge,addN:()=>e$,all:()=>Vb,any:()=>jf,argMax:()=>ql,argMin:()=>K1,asin:()=>X1,asinh:()=>Y1,atan:()=>Z1,atan2:()=>Q1,atanh:()=>J1,avgPool:()=>Ni,avgPool3d:()=>tk,backend:()=>W1,backend_util:()=>D,basicLSTMCell:()=>r$,batchNorm:()=>Ic,batchNorm2d:()=>ak,batchNorm3d:()=>nk,batchNorm4d:()=>rk,batchToSpaceND:()=>zm,bincount:()=>sk,bitwiseAnd:()=>s$,booleanMaskAsync:()=>K$,broadcastArgs:()=>i$,broadcastTo:()=>Ml,broadcast_util:()=>Yh,browser:()=>Ym,buffer:()=>ct,callbacks:()=>fZ,cast:()=>Te,ceil:()=>ik,clipByValue:()=>yn,clone:()=>zs,complex:()=>wi,concat:()=>Gt,concat1d:()=>ok,concat2d:()=>lk,concat3d:()=>uk,concat4d:()=>ck,constraints:()=>iD,conv1d:()=>Gb,conv2d:()=>Cn,conv2dTranspose:()=>Hb,conv3d:()=>hk,conv3dTranspose:()=>pk,copyRegisteredKernels:()=>SP,cos:()=>Lm,cosh:()=>qb,cosineWindow:()=>mv,cumprod:()=>Yf,cumsum:()=>jb,customGrad:()=>Ws,data:()=>WM,denseBincount:()=>Qy,deprecationWarn:()=>UA,depthToSpace:()=>fk,depthwiseConv2d:()=>Nc,deregisterOp:()=>yZ,device_util:()=>Mm,diag:()=>l$,dilation2d:()=>mk,disableDeprecationWarnings:()=>JP,dispose:()=>nt,disposeVariables:()=>eW,div:()=>Fe,divNoNan:()=>gk,dot:()=>yk,dropout:()=>qk,einsum:()=>Cl,elu:()=>Zh,enableDebugMode:()=>QP,enableProdMode:()=>ZP,enclosingPowerOfTwo:()=>jk,engine:()=>Pr,ensureShape:()=>c$,env:()=>ie,equal:()=>or,erf:()=>Kb,euclideanNorm:()=>xk,exp:()=>bn,expandDims:()=>Za,expm1:()=>wk,eye:()=>Xb,fft:()=>Km,fill:()=>ir,findBackend:()=>iW,findBackendFactory:()=>oW,floor:()=>Jh,floorDiv:()=>Wb,forceHalfFloat:()=>h3,fused:()=>Bd,gather:()=>ep,gatherND:()=>Q$,gather_util:()=>sS,getBackend:()=>PA,getGradient:()=>kw,getKernel:()=>Gf,getKernelsForBackend:()=>Yy,getThreadsCount:()=>w1e,gpgpu_util:()=>VO,grad:()=>BG,grads:()=>UG,greater:()=>Dn,greaterEqual:()=>Ti,ifft:()=>Ld,imag:()=>Bm,image:()=>xr,inTopKAsync:()=>J$,initializers:()=>oD,input:()=>TD,io:()=>dn,irfft:()=>lv,isFinite:()=>kk,isInf:()=>Sk,isNaN:()=>Ik,keep:()=>Ba,kernel_impls:()=>qs,layers:()=>lD,leakyRelu:()=>Um,less:()=>Md,lessEqual:()=>Po,linalg:()=>Yk,linspace:()=>m$,loadGraphModel:()=>SQ,loadGraphModelSync:()=>IQ,loadLayersModel:()=>u9,localResponseNormalization:()=>Nk,log:()=>lr,log1p:()=>Pm,logSigmoid:()=>Tk,logSoftmax:()=>Zb,logSumExp:()=>Wm,logicalAnd:()=>Gr,logicalNot:()=>Vm,logicalOr:()=>Qb,logicalXor:()=>_k,losses:()=>dR,lowerBound:()=>y$,matMul:()=>lt,math:()=>kR,max:()=>Ir,maxPool:()=>Ka,maxPool3d:()=>Ck,maxPoolWithArgmax:()=>b$,maximum:()=>Hs,mean:()=>ca,memory:()=>$w,meshgrid:()=>v$,metrics:()=>fM,min:()=>Dd,minimum:()=>To,mirrorPad:()=>Ek,mod:()=>Ak,model:()=>h9,models:()=>mM,moments:()=>Gm,movingAverage:()=>X$,mul:()=>Z,multiRNNCell:()=>x$,multinomial:()=>w$,neg:()=>ta,nextFrame:()=>iS,norm:()=>Qh,notEqual:()=>Xl,oneHot:()=>Fd,ones:()=>Pn,onesLike:()=>ur,op:()=>K,outerProduct:()=>k$,pad:()=>ms,pad1d:()=>S$,pad2d:()=>I$,pad3d:()=>N$,pad4d:()=>T$,pool:()=>$k,pow:()=>Ps,prelu:()=>qm,print:()=>H1,prod:()=>Rk,profile:()=>tW,raggedGather:()=>_$,raggedRange:()=>C$,raggedTensorToTensor:()=>E$,rand:()=>A$,randomGamma:()=>M$,randomNormal:()=>ev,randomStandardNormal:()=>F$,randomUniform:()=>Wo,randomUniformInt:()=>O$,range:()=>Yl,ready:()=>rW,real:()=>Od,reciprocal:()=>zk,registerBackend:()=>Pb,registerCallbackConstructor:()=>f9,registerGradient:()=>_A,registerKernel:()=>$m,registerOp:()=>gZ,regularizers:()=>gM,relu:()=>Ot,relu6:()=>tv,removeBackend:()=>sW,reshape:()=>te,reverse:()=>_r,reverse1d:()=>z$,reverse2d:()=>L$,reverse3d:()=>B$,reverse4d:()=>U$,rfft:()=>Xm,round:()=>av,rsqrt:()=>nv,scalar:()=>We,scatterND:()=>Y$,scatter_util:()=>dv,searchSorted:()=>Jb,selu:()=>rv,separableConv2d:()=>tp,sequential:()=>p9,serialization:()=>ke,setBackend:()=>nW,setPlatform:()=>lW,setThreadsCount:()=>x1e,setWasmPath:()=>b1e,setWasmPaths:()=>v1e,setWebGLContext:()=>pO,setdiff1dAsync:()=>P$,shared:()=>G2,sigmoid:()=>Vr,sign:()=>Lk,signal:()=>cR,sin:()=>sv,sinh:()=>iv,slice:()=>bt,slice1d:()=>jm,slice2d:()=>ov,slice3d:()=>ap,slice4d:()=>zd,slice_util:()=>Pa,softmax:()=>Vo,softplus:()=>Tc,spaceToBatchND:()=>Hm,sparse:()=>hR,sparseToDense:()=>Z$,spectral:()=>uR,split:()=>Wn,sqrt:()=>en,square:()=>Vt,squaredDifference:()=>uv,squeeze:()=>Go,stack:()=>$a,step:()=>_c,stridedSlice:()=>Bk,string:()=>pR,sub:()=>$e,sum:()=>ze,sumOutType:()=>Ub,tan:()=>Uk,tanh:()=>No,tensor:()=>_n,tensor1d:()=>Mt,tensor2d:()=>Ls,tensor3d:()=>cv,tensor4d:()=>_o,tensor5d:()=>W$,tensor6d:()=>V$,tensorScatterUpdate:()=>H$,tensor_util:()=>ls,test_util:()=>$$,tidy:()=>ae,tile:()=>sr,time:()=>aW,topk:()=>Wk,train:()=>Nl,transpose:()=>ut,truncatedNormal:()=>pv,unique:()=>Vk,unregisterGradient:()=>kP,unregisterKernel:()=>wP,unsortedSegmentSum:()=>fv,unstack:()=>ya,upcastType:()=>Nr,upperBound:()=>q$,util:()=>C,valueAndGrad:()=>PG,valueAndGrads:()=>WG,variable:()=>Gk,variableGrads:()=>g$,version:()=>C1e,version_converter:()=>TQ,version_core:()=>hj,version_cpu:()=>_ee,version_layers:()=>ES,version_wasm:()=>k1e,version_webgl:()=>gle,webgl:()=>yle,webgl_util:()=>hO,where:()=>Ja,whereAsync:()=>Hk,zeros:()=>da,zerosLike:()=>St});var TU=Object.create,R1=Object.defineProperty,_U=Object.getOwnPropertyDescriptor,CU=Object.getOwnPropertyNames,EU=Object.getPrototypeOf,AU=Object.prototype.hasOwnProperty,Da=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),rt=(e,t)=>{for(var a in t)R1(e,a,{get:t[a],enumerable:!0})},$U=(e,t,a,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of CU(t))!AU.call(e,r)&&r!==a&&R1(e,r,{get:()=>t[r],enumerable:!(n=_U(t,r))||n.enumerable});return e},Fo=(e,t,a)=>(a=e!=null?TU(EU(e)):{},$U(!e||!e.__esModule?R1(a,"default",{value:e,enumerable:!0}):a,e)),RU=Da((e,t)=>{t.exports=n;var a=null;try{a=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function n(A,G,J){this.low=A|0,this.high=G|0,this.unsigned=!!J}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0});function r(A){return(A&&A.__isLong__)===!0}n.isLong=r;var s={},i={};function o(A,G){var J,ee,W;return G?(A>>>=0,(W=0<=A&&A<256)&&(ee=i[A],ee)?ee:(J=d(A,(A|0)<0?-1:0,!0),W&&(i[A]=J),J)):(A|=0,(W=-128<=A&&A<128)&&(ee=s[A],ee)?ee:(J=d(A,A<0?-1:0,!1),W&&(s[A]=J),J))}n.fromInt=o;function u(A,G){if(isNaN(A))return G?T:N;if(G){if(A<0)return T;if(A>=x)return B}else{if(A<=-9223372036854776e3)return V;if(A+1>=k)return F}return A<0?u(-A,G).neg():d(A%v|0,A/v|0,G)}n.fromNumber=u;function d(A,G,J){return new n(A,G,J)}n.fromBits=d;var c=Math.pow;function f(A,G,J){if(A.length===0)throw Error("empty string");if(A==="NaN"||A==="Infinity"||A==="+Infinity"||A==="-Infinity")return N;if(typeof G=="number"?(J=G,G=!1):G=!!G,J=J||10,J<2||36<J)throw RangeError("radix");var ee;if((ee=A.indexOf("-"))>0)throw Error("interior hyphen");if(ee===0)return f(A.substring(1),G,J).neg();for(var W=u(c(J,8)),X=N,Q=0;Q<A.length;Q+=8){var ce=Math.min(8,A.length-Q),L=parseInt(A.substring(Q,Q+ce),J);if(ce<8){var q=u(c(J,ce));X=X.mul(q).add(u(L))}else X=X.mul(W),X=X.add(u(L))}return X.unsigned=G,X}n.fromString=f;function m(A,G){return typeof A=="number"?u(A,G):typeof A=="string"?f(A,G):d(A.low,A.high,typeof G=="boolean"?G:A.unsigned)}n.fromValue=m;var g=65536,b=1<<24,v=g*g,x=v*v,k=x/2,S=o(b),N=o(0);n.ZERO=N;var T=o(0,!0);n.UZERO=T;var _=o(1);n.ONE=_;var R=o(1,!0);n.UONE=R;var M=o(-1);n.NEG_ONE=M;var F=d(-1,2147483647,!1);n.MAX_VALUE=F;var B=d(-1,-1,!0);n.MAX_UNSIGNED_VALUE=B;var V=d(0,-2147483648,!1);n.MIN_VALUE=V;var P=n.prototype;P.toInt=function(){return this.unsigned?this.low>>>0:this.low},P.toNumber=function(){return this.unsigned?(this.high>>>0)*v+(this.low>>>0):this.high*v+(this.low>>>0)},P.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(V)){var G=u(A),J=this.div(G),ee=J.mul(G).sub(this);return J.toString(A)+ee.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var W=u(c(A,6),this.unsigned),X=this,Q="";;){var ce=X.div(W),L=X.sub(ce.mul(W)).toInt()>>>0,q=L.toString(A);if(X=ce,X.isZero())return q+Q;for(;q.length<6;)q="0"+q;Q=""+q+Q}},P.getHighBits=function(){return this.high},P.getHighBitsUnsigned=function(){return this.high>>>0},P.getLowBits=function(){return this.low},P.getLowBitsUnsigned=function(){return this.low>>>0},P.getNumBitsAbs=function(){if(this.isNegative())return this.eq(V)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,G=31;G>0&&!(A&1<<G);G--);return this.high!=0?G+33:G+1},P.isZero=function(){return this.high===0&&this.low===0},P.eqz=P.isZero,P.isNegative=function(){return!this.unsigned&&this.high<0},P.isPositive=function(){return this.unsigned||this.high>=0},P.isOdd=function(){return(this.low&1)===1},P.isEven=function(){return(this.low&1)===0},P.equals=function(A){return r(A)||(A=m(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},P.eq=P.equals,P.notEquals=function(A){return!this.eq(A)},P.neq=P.notEquals,P.ne=P.notEquals,P.lessThan=function(A){return this.comp(A)<0},P.lt=P.lessThan,P.lessThanOrEqual=function(A){return this.comp(A)<=0},P.lte=P.lessThanOrEqual,P.le=P.lessThanOrEqual,P.greaterThan=function(A){return this.comp(A)>0},P.gt=P.greaterThan,P.greaterThanOrEqual=function(A){return this.comp(A)>=0},P.gte=P.greaterThanOrEqual,P.ge=P.greaterThanOrEqual,P.compare=function(A){if(r(A)||(A=m(A)),this.eq(A))return 0;var G=this.isNegative(),J=A.isNegative();return G&&!J?-1:!G&&J?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},P.comp=P.compare,P.negate=function(){return!this.unsigned&&this.eq(V)?V:this.not().add(_)},P.neg=P.negate,P.add=function(A){r(A)||(A=m(A));var G=this.high>>>16,J=this.high&65535,ee=this.low>>>16,W=this.low&65535,X=A.high>>>16,Q=A.high&65535,ce=A.low>>>16,L=A.low&65535,q=0,le=0,se=0,pe=0;return pe+=W+L,se+=pe>>>16,pe&=65535,se+=ee+ce,le+=se>>>16,se&=65535,le+=J+Q,q+=le>>>16,le&=65535,q+=G+X,q&=65535,d(se<<16|pe,q<<16|le,this.unsigned)},P.subtract=function(A){return r(A)||(A=m(A)),this.add(A.neg())},P.sub=P.subtract,P.multiply=function(A){if(this.isZero())return N;if(r(A)||(A=m(A)),a){var G=a.mul(this.low,this.high,A.low,A.high);return d(G,a.get_high(),this.unsigned)}if(A.isZero())return N;if(this.eq(V))return A.isOdd()?V:N;if(A.eq(V))return this.isOdd()?V:N;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(S)&&A.lt(S))return u(this.toNumber()*A.toNumber(),this.unsigned);var J=this.high>>>16,ee=this.high&65535,W=this.low>>>16,X=this.low&65535,Q=A.high>>>16,ce=A.high&65535,L=A.low>>>16,q=A.low&65535,le=0,se=0,pe=0,ve=0;return ve+=X*q,pe+=ve>>>16,ve&=65535,pe+=W*q,se+=pe>>>16,pe&=65535,pe+=X*L,se+=pe>>>16,pe&=65535,se+=ee*q,le+=se>>>16,se&=65535,se+=W*L,le+=se>>>16,se&=65535,se+=X*ce,le+=se>>>16,se&=65535,le+=J*q+ee*L+W*ce+X*Q,le&=65535,d(pe<<16|ve,le<<16|se,this.unsigned)},P.mul=P.multiply,P.divide=function(A){if(r(A)||(A=m(A)),A.isZero())throw Error("division by zero");if(a){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var G=(this.unsigned?a.div_u:a.div_s)(this.low,this.high,A.low,A.high);return d(G,a.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?T:N;var J,ee,W;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return T;if(A.gt(this.shru(1)))return R;W=T}else{if(this.eq(V)){if(A.eq(_)||A.eq(M))return V;if(A.eq(V))return _;var X=this.shr(1);return J=X.div(A).shl(1),J.eq(N)?A.isNegative()?_:M:(ee=this.sub(A.mul(J)),W=J.add(ee.div(A)),W)}else if(A.eq(V))return this.unsigned?T:N;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();W=N}for(ee=this;ee.gte(A);){J=Math.max(1,Math.floor(ee.toNumber()/A.toNumber()));for(var Q=Math.ceil(Math.log(J)/Math.LN2),ce=Q<=48?1:c(2,Q-48),L=u(J),q=L.mul(A);q.isNegative()||q.gt(ee);)J-=ce,L=u(J,this.unsigned),q=L.mul(A);L.isZero()&&(L=_),W=W.add(L),ee=ee.sub(q)}return W},P.div=P.divide,P.modulo=function(A){if(r(A)||(A=m(A)),a){var G=(this.unsigned?a.rem_u:a.rem_s)(this.low,this.high,A.low,A.high);return d(G,a.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},P.mod=P.modulo,P.rem=P.modulo,P.not=function(){return d(~this.low,~this.high,this.unsigned)},P.and=function(A){return r(A)||(A=m(A)),d(this.low&A.low,this.high&A.high,this.unsigned)},P.or=function(A){return r(A)||(A=m(A)),d(this.low|A.low,this.high|A.high,this.unsigned)},P.xor=function(A){return r(A)||(A=m(A)),d(this.low^A.low,this.high^A.high,this.unsigned)},P.shiftLeft=function(A){return r(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?d(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):d(0,this.low<<A-32,this.unsigned)},P.shl=P.shiftLeft,P.shiftRight=function(A){return r(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?d(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):d(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},P.shr=P.shiftRight,P.shiftRightUnsigned=function(A){if(r(A)&&(A=A.toInt()),A&=63,A===0)return this;var G=this.high;if(A<32){var J=this.low;return d(J>>>A|G<<32-A,G>>>A,this.unsigned)}else return A===32?d(G,0,this.unsigned):d(G>>>A-32,0,this.unsigned)},P.shru=P.shiftRightUnsigned,P.shr_u=P.shiftRightUnsigned,P.toSigned=function(){return this.unsigned?d(this.low,this.high,!1):this},P.toUnsigned=function(){return this.unsigned?this:d(this.low,this.high,!0)},P.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},P.toBytesLE=function(){var A=this.high,G=this.low;return[G&255,G>>>8&255,G>>>16&255,G>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},P.toBytesBE=function(){var A=this.high,G=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,G>>>24,G>>>16&255,G>>>8&255,G&255]},n.fromBytes=function(A,G,J){return J?n.fromBytesLE(A,G):n.fromBytesBE(A,G)},n.fromBytesLE=function(A,G){return new n(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,G)},n.fromBytesBE=function(A,G){return new n(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],G)}}),DU=Da(()=>{}),MU=Da(()=>{}),FU=Da((e,t)=>{(function(a,n,r){function s(d){var c=this,f=u();c.next=function(){var m=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=m-(c.c=m|0)},c.c=1,c.s0=f(" "),c.s1=f(" "),c.s2=f(" "),c.s0-=f(d),c.s0<0&&(c.s0+=1),c.s1-=f(d),c.s1<0&&(c.s1+=1),c.s2-=f(d),c.s2<0&&(c.s2+=1),f=null}function i(d,c){return c.c=d.c,c.s0=d.s0,c.s1=d.s1,c.s2=d.s2,c}function o(d,c){var f=new s(d),m=c&&c.state,g=f.next;return g.int32=function(){return f.next()*4294967296|0},g.double=function(){return g()+(g()*2097152|0)*11102230246251565e-32},g.quick=g,m&&(typeof m=="object"&&i(m,f),g.state=function(){return i(f,{})}),g}function u(){var d=4022871197,c=function(f){f=String(f);for(var m=0;m<f.length;m++){d+=f.charCodeAt(m);var g=.02519603282416938*d;d=g>>>0,g-=d,g*=d,d=g>>>0,g-=d,d+=g*4294967296}return(d>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),OU=Da((e,t)=>{(function(a,n,r){function s(u){var d=this,c="";d.x=0,d.y=0,d.z=0,d.w=0,d.next=function(){var m=d.x^d.x<<11;return d.x=d.y,d.y=d.z,d.z=d.w,d.w^=d.w>>>19^m^m>>>8},u===(u|0)?d.x=u:c+=u;for(var f=0;f<c.length+64;f++)d.x^=c.charCodeAt(f)|0,d.next()}function i(u,d){return d.x=u.x,d.y=u.y,d.z=u.z,d.w=u.w,d}function o(u,d){var c=new s(u),f=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,f&&(typeof f=="object"&&i(f,c),m.state=function(){return i(c,{})}),m}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),zU=Da((e,t)=>{(function(a,n,r){function s(u){var d=this,c="";d.next=function(){var m=d.x^d.x>>>2;return d.x=d.y,d.y=d.z,d.z=d.w,d.w=d.v,(d.d=d.d+362437|0)+(d.v=d.v^d.v<<4^(m^m<<1))|0},d.x=0,d.y=0,d.z=0,d.w=0,d.v=0,u===(u|0)?d.x=u:c+=u;for(var f=0;f<c.length+64;f++)d.x^=c.charCodeAt(f)|0,f==c.length&&(d.d=d.x<<10^d.x>>>4),d.next()}function i(u,d){return d.x=u.x,d.y=u.y,d.z=u.z,d.w=u.w,d.v=u.v,d.d=u.d,d}function o(u,d){var c=new s(u),f=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,f&&(typeof f=="object"&&i(f,c),m.state=function(){return i(c,{})}),m}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),LU=Da((e,t)=>{(function(a,n,r){function s(u){var d=this;d.next=function(){var f=d.x,m=d.i,g,b;return g=f[m],g^=g>>>7,b=g^g<<24,g=f[m+1&7],b^=g^g>>>10,g=f[m+3&7],b^=g^g>>>3,g=f[m+4&7],b^=g^g<<7,g=f[m+7&7],g=g^g<<13,b^=g^g<<9,f[m]=b,d.i=m+1&7,b};function c(f,m){var g,b=[];if(m===(m|0))b[0]=m;else for(m=""+m,g=0;g<m.length;++g)b[g&7]=b[g&7]<<15^m.charCodeAt(g)+b[g+1&7]<<13;for(;b.length<8;)b.push(0);for(g=0;g<8&&b[g]===0;++g);for(g==8?b[7]=-1:b[g],f.x=b,f.i=0,g=256;g>0;--g)f.next()}c(d,u)}function i(u,d){return d.x=u.x.slice(),d.i=u.i,d}function o(u,d){u==null&&(u=+new Date);var c=new s(u),f=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,f&&(f.x&&i(f,c),m.state=function(){return i(c,{})}),m}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),BU=Da((e,t)=>{(function(a,n,r){function s(u){var d=this;d.next=function(){var f=d.w,m=d.X,g=d.i,b,v;return d.w=f=f+1640531527|0,v=m[g+34&127],b=m[g=g+1&127],v^=v<<13,b^=b<<17,v^=v>>>15,b^=b>>>12,v=m[g]=v^b,d.i=g,v+(f^f>>>16)|0};function c(f,m){var g,b,v,x,k,S=[],N=128;for(m===(m|0)?(b=m,m=null):(m=m+"\0",b=0,N=Math.max(N,m.length)),v=0,x=-32;x<N;++x)m&&(b^=m.charCodeAt((x+32)%m.length)),x===0&&(k=b),b^=b<<10,b^=b>>>15,b^=b<<4,b^=b>>>13,x>=0&&(k=k+1640531527|0,g=S[x&127]^=b+k,v=g==0?v+1:0);for(v>=128&&(S[(m&&m.length||0)&127]=-1),v=127,x=4*128;x>0;--x)b=S[v+34&127],g=S[v=v+1&127],b^=b<<13,g^=g<<17,b^=b>>>15,g^=g>>>12,S[v]=b^g;f.w=k,f.X=S,f.i=v}c(d,u)}function i(u,d){return d.i=u.i,d.w=u.w,d.X=u.X.slice(),d}function o(u,d){u==null&&(u=+new Date);var c=new s(u),f=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,f&&(f.X&&i(f,c),m.state=function(){return i(c,{})}),m}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),UU=Da((e,t)=>{(function(a,n,r){function s(u){var d=this,c="";d.next=function(){var m=d.b,g=d.c,b=d.d,v=d.a;return m=m<<25^m>>>7^g,g=g-b|0,b=b<<24^b>>>8^v,v=v-m|0,d.b=m=m<<20^m>>>12^g,d.c=g=g-b|0,d.d=b<<16^g>>>16^v,d.a=v-m|0},d.a=0,d.b=0,d.c=-1640531527,d.d=1367130551,u===Math.floor(u)?(d.a=u/4294967296|0,d.b=u|0):c+=u;for(var f=0;f<c.length+20;f++)d.b^=c.charCodeAt(f)|0,d.next()}function i(u,d){return d.a=u.a,d.b=u.b,d.c=u.c,d.d=u.d,d}function o(u,d){var c=new s(u),f=d&&d.state,m=function(){return(c.next()>>>0)/4294967296};return m.double=function(){do var g=c.next()>>>11,b=(c.next()>>>0)/4294967296,v=(g+b)/(1<<21);while(v===0);return v},m.int32=c.next,m.quick=m,f&&(typeof f=="object"&&i(f,c),m.state=function(){return i(c,{})}),m}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),PU=Da(()=>{}),WU=Da((e,t)=>{(function(a,n,r){var s=256,i=6,o=52,u="random",d=r.pow(s,i),c=r.pow(2,o),f=c*2,m=s-1,g;function b(_,R,M){var F=[];R=R==!0?{entropy:!0}:R||{};var B=S(k(R.entropy?[_,T(n)]:_??N(),3),F),V=new v(F),P=function(){for(var A=V.g(i),G=d,J=0;A<c;)A=(A+J)*s,G*=s,J=V.g(1);for(;A>=f;)A/=2,G/=2,J>>>=1;return(A+J)/G};return P.int32=function(){return V.g(4)|0},P.quick=function(){return V.g(4)/4294967296},P.double=P,S(T(V.S),n),(R.pass||M||function(A,G,J,ee){return ee&&(ee.S&&x(ee,V),A.state=function(){return x(V,{})}),J?(r[u]=A,G):A})(P,B,"global"in R?R.global:this==r,R.state)}function v(_){var R,M=_.length,F=this,B=0,V=F.i=F.j=0,P=F.S=[];for(M||(_=[M++]);B<s;)P[B]=B++;for(B=0;B<s;B++)P[B]=P[V=m&V+_[B%M]+(R=P[B])],P[V]=R;(F.g=function(A){for(var G,J=0,ee=F.i,W=F.j,X=F.S;A--;)G=X[ee=m&ee+1],J=J*s+X[m&(X[ee]=X[W=m&W+G])+(X[W]=G)];return F.i=ee,F.j=W,J})(s)}function x(_,R){return R.i=_.i,R.j=_.j,R.S=_.S.slice(),R}function k(_,R){var M=[],F=typeof _,B;if(R&&F=="object")for(B in _)try{M.push(k(_[B],R-1))}catch{}return M.length?M:F=="string"?_:_+"\0"}function S(_,R){for(var M=_+"",F,B=0;B<M.length;)R[m&B]=m&(F^=R[m&B]*19)+M.charCodeAt(B++);return T(R)}function N(){try{var _;return g&&(_=g.randomBytes)?_=_(s):(_=new Uint8Array(s),(a.crypto||a.msCrypto).getRandomValues(_)),T(_)}catch{var R=a.navigator,M=R&&R.plugins;return[+new Date,a,M,a.screen,T(n)]}}function T(_){return String.fromCharCode.apply(0,_)}if(S(r.random(),n),typeof t=="object"&&t.exports){t.exports=b;try{g=PU()}catch{}}else typeof define=="function"&&define.amd?define(function(){return b}):r["seed"+u]=b})(typeof self<"u"?self:e,[],Math)}),kb=Da((e,t)=>{var a=FU(),n=OU(),r=zU(),s=LU(),i=BU(),o=UU(),u=WU();u.alea=a,u.xor128=n,u.xorwow=r,u.xorshift7=s,u.xor4096=i,u.tychei=o,t.exports=u}),cA=Da(()=>{}),D1=Da(()=>{}),dA=Da(()=>{}),VU=Da(()=>{}),GU=Da(()=>{}),HU=Da(()=>{}),qU=Da((e,t)=>{var a=(()=>{var n=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(n=n||__filename),function(r){r=r||{};function s(){return Q.buffer!=Ne&&pt(Q.buffer),Le}function i(){return Q.buffer!=Ne&&pt(Q.buffer),je}function o(){return Q.buffer!=Ne&&pt(Q.buffer),Je}function u(){return Q.buffer!=Ne&&pt(Q.buffer),st}function d(){return Q.buffer!=Ne&&pt(Q.buffer),At}var c=typeof r<"u"?r:{},f,m;c.ready=new Promise(function(H,ue){f=H,m=ue});var g;typeof process<"u"&&process.listeners&&(g={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var b=Object.assign({},c),v=(H,ue)=>{throw ue},x=typeof window=="object",k=typeof importScripts=="function",S=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",N=c.ENVIRONMENT_IS_PTHREAD||!1,T="";function _(H){return c.locateFile?c.locateFile(H,T):T+H}var R,M,F;function B(H){H instanceof Er||ee("exiting due to exception: "+H)}if(S){var V=D1(),P=dA();k?T=P.dirname(T)+"/":T=__dirname+"/",R=(ue,Ce)=>(ue=hr(ue)?new URL(ue):P.normalize(ue),V.readFileSync(ue,Ce?void 0:"utf8")),F=ue=>{var Ce=R(ue,!0);return Ce.buffer||(Ce=new Uint8Array(Ce)),Ce},M=(ue,Ce,Ge)=>{ue=hr(ue)?new URL(ue):P.normalize(ue),V.readFile(ue,function(Ke,at){Ke?Ge(Ke):Ce(at.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(ue){if(!(ue instanceof Er))throw ue}),process.on("unhandledRejection",function(ue){throw ue}),v=(ue,Ce)=>{if(na())throw process.exitCode=ue,Ce;B(Ce),process.exit(ue)},c.inspect=function(){return"[Emscripten Module object]"};let H;try{H=VU()}catch(ue){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),ue}global.Worker=H.Worker}else(x||k)&&(k?T=self.location.href:typeof document<"u"&&document.currentScript&&(T=document.currentScript.src),typeof n<"u"&&n&&(T=n),T.indexOf("blob:")!==0?T=T.substr(0,T.replace(/[?#].*/,"").lastIndexOf("/")+1):T="",S||(R=H=>{var ue=new XMLHttpRequest;return ue.open("GET",H,!1),ue.send(null),ue.responseText},k&&(F=H=>{var ue=new XMLHttpRequest;return ue.open("GET",H,!1),ue.responseType="arraybuffer",ue.send(null),new Uint8Array(ue.response)}),M=(H,ue,Ce)=>{var Ge=new XMLHttpRequest;Ge.open("GET",H,!0),Ge.responseType="arraybuffer",Ge.onload=()=>{if(Ge.status==200||Ge.status==0&&Ge.response){ue(Ge.response);return}Ce()},Ge.onerror=Ce,Ge.send(null)}));S&&typeof performance>"u"&&(global.performance=GU().performance);var A=console.log.bind(console),G=console.warn.bind(console);S&&(A=H=>V.writeSync(1,H+`
`),G=H=>V.writeSync(2,H+`
`));var J=c.print||A,ee=c.printErr||G;Object.assign(c,b),b=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&(v=c.quit);var W;c.wasmBinary&&(W=c.wasmBinary);var X=c.noExitRuntime||!0;typeof WebAssembly!="object"&&Xr("no native wasm support detected");var Q,ce,L=!1,q;function le(H,ue){H||Xr(ue)}var se=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function pe(H,ue,Ce){ue>>>=0;for(var Ge=ue+Ce,Ke=ue;H[Ke]&&!(Ke>=Ge);)++Ke;if(Ke-ue>16&&H.buffer&&se)return se.decode(H.buffer instanceof SharedArrayBuffer?H.slice(ue,Ke):H.subarray(ue,Ke));for(var at="";ue<Ke;){var Me=H[ue++];if(!(Me&128)){at+=String.fromCharCode(Me);continue}var Oe=H[ue++]&63;if((Me&224)==192){at+=String.fromCharCode((Me&31)<<6|Oe);continue}var jt=H[ue++]&63;if((Me&240)==224?Me=(Me&15)<<12|Oe<<6|jt:Me=(Me&7)<<18|Oe<<12|jt<<6|H[ue++]&63,Me<65536)at+=String.fromCharCode(Me);else{var rn=Me-65536;at+=String.fromCharCode(55296|rn>>10,56320|rn&1023)}}return at}function ve(H,ue){return H>>>=0,H?pe(i(),H,ue):""}function Ie(H,ue,Ce,Ge){if(Ce>>>=0,!(Ge>0))return 0;for(var Ke=Ce,at=Ce+Ge-1,Me=0;Me<H.length;++Me){var Oe=H.charCodeAt(Me);if(Oe>=55296&&Oe<=57343){var jt=H.charCodeAt(++Me);Oe=65536+((Oe&1023)<<10)|jt&1023}if(Oe<=127){if(Ce>=at)break;ue[Ce++>>>0]=Oe}else if(Oe<=2047){if(Ce+1>=at)break;ue[Ce++>>>0]=192|Oe>>6,ue[Ce++>>>0]=128|Oe&63}else if(Oe<=65535){if(Ce+2>=at)break;ue[Ce++>>>0]=224|Oe>>12,ue[Ce++>>>0]=128|Oe>>6&63,ue[Ce++>>>0]=128|Oe&63}else{if(Ce+3>=at)break;ue[Ce++>>>0]=240|Oe>>18,ue[Ce++>>>0]=128|Oe>>12&63,ue[Ce++>>>0]=128|Oe>>6&63,ue[Ce++>>>0]=128|Oe&63}}return ue[Ce>>>0]=0,Ce-Ke}function Re(H,ue,Ce){return Ie(H,i(),ue,Ce)}var Ne,Le,je,Je,st,At;N&&(Ne=c.buffer);function pt(H){Ne=H,c.HEAP8=Le=new Int8Array(H),c.HEAP16=new Int16Array(H),c.HEAP32=Je=new Int32Array(H),c.HEAPU8=je=new Uint8Array(H),c.HEAPU16=new Uint16Array(H),c.HEAPU32=st=new Uint32Array(H),c.HEAPF32=new Float32Array(H),c.HEAPF64=At=new Float64Array(H)}var xt=c.INITIAL_MEMORY||16777216;if(N)Q=c.wasmMemory,Ne=c.buffer;else if(c.wasmMemory)Q=c.wasmMemory;else if(Q=new WebAssembly.Memory({initial:xt/65536,maximum:65536,shared:!0}),!(Q.buffer instanceof SharedArrayBuffer))throw ee("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),S&&ee("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Q&&(Ne=Q.buffer),xt=Ne.byteLength,pt(Ne);var tt,ot=[],Bt=[],pn=[];function na(){return X}function Fa(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)Kn(c.preRun.shift());It(ot)}function Oa(){!N&&It(Bt)}function nn(){if(!N){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)Na(c.postRun.shift());It(pn)}}function Kn(H){ot.unshift(H)}function wn(H){Bt.unshift(H)}function Na(H){pn.unshift(H)}var $t=0,ba=null;function va(H){$t++,c.monitorRunDependencies&&c.monitorRunDependencies($t)}function Qo(H){if($t--,c.monitorRunDependencies&&c.monitorRunDependencies($t),$t==0&&ba){var ue=ba;ba=null,ue()}}function Xr(H){c.onAbort&&c.onAbort(H),H="Aborted("+H+")",ee(H),L=!0,q=1,H+=". Build with -sASSERTIONS for more info.";var ue=new WebAssembly.RuntimeError(H);throw m(ue),ue}var Jo="data:application/octet-stream;base64,";function Fn(H){return H.startsWith(Jo)}function hr(H){return H.startsWith("file://")}var ra;ra="tfjs-backend-wasm-threaded-simd.wasm",Fn(ra)||(ra=_(ra));function Ks(H){try{if(H==ra&&W)return new Uint8Array(W);if(F)return F(H);throw"both async and sync fetching of the wasm failed"}catch(ue){Xr(ue)}}function ys(){if(!W&&(x||k)){if(typeof fetch=="function"&&!hr(ra))return fetch(ra,{credentials:"same-origin"}).then(function(H){if(!H.ok)throw"failed to load wasm binary file at '"+ra+"'";return H.arrayBuffer()}).catch(function(){return Ks(ra)});if(M)return new Promise(function(H,ue){M(ra,function(Ce){H(new Uint8Array(Ce))},ue)})}return Promise.resolve().then(function(){return Ks(ra)})}function Oc(){var H={env:Bc,wasi_snapshot_preview1:Bc};function ue(Me,Oe){var jt=Me.exports;if(c.asm=jt,Yr(c.asm._emscripten_tls_init),tt=c.asm.__indirect_function_table,wn(c.asm.__wasm_call_ctors),ce=Oe,!N){var rn=De.unusedWorkers.length;De.unusedWorkers.forEach(function($r){De.loadWasmModuleToWorker($r,function(){--rn||Qo()})})}}N||va();function Ce(Me){ue(Me.instance,Me.module)}function Ge(Me){return ys().then(function(Oe){return WebAssembly.instantiate(Oe,H)}).then(function(Oe){return Oe}).then(Me,function(Oe){ee("failed to asynchronously prepare wasm: "+Oe),Xr(Oe)})}function Ke(){return!W&&typeof WebAssembly.instantiateStreaming=="function"&&!Fn(ra)&&!hr(ra)&&!S&&typeof fetch=="function"?fetch(ra,{credentials:"same-origin"}).then(function(Me){var Oe=WebAssembly.instantiateStreaming(Me,H);return Oe.then(Ce,function(jt){return ee("wasm streaming compile failed: "+jt),ee("falling back to ArrayBuffer instantiation"),Ge(Ce)})}):Ge(Ce)}if(c.instantiateWasm)try{var at=c.instantiateWasm(H,ue);return at}catch(Me){ee("Module.instantiateWasm callback failed with error: "+Me),m(Me)}return Ke().catch(m),{}}var el={};function Er(H){this.name="ExitStatus",this.message="Program terminated with exit("+H+")",this.status=H}function bs(H){var ue=De.pthreads[H];delete De.pthreads[H],ue.terminate(),Tp(H),De.runningWorkers.splice(De.runningWorkers.indexOf(ue),1),ue.pthread_ptr=0}function vs(H){var ue=De.pthreads[H];ue.postMessage({cmd:"cancel"})}function Xs(H){var ue=De.pthreads[H];le(ue),De.returnWorkerToPool(ue)}function xs(H){var ue=De.getNewWorker();if(!ue)return 6;De.runningWorkers.push(ue),De.pthreads[H.pthread_ptr]=ue,ue.pthread_ptr=H.pthread_ptr;var Ce={cmd:"run",start_routine:H.startRoutine,arg:H.arg,pthread_ptr:H.pthread_ptr};return ue.runPthread=()=>{S&&ue.ref(),ue.postMessage(Ce,H.transferList),delete ue.runPthread},ue.loaded&&ue.runPthread(),0}function tl(H){if(N)return Zs(1,1,H);q=H,na()||(De.terminateAllThreads(),c.onExit&&c.onExit(H),L=!0),v(H,new Er(H))}function ye(H,ue){if(q=H,!ue&&N)throw qe(H),"unwind";tl(H)}var _e=ye;function Ve(H){if(H instanceof Er||H=="unwind")return q;v(1,H)}var De={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){N?De.initWorker():De.initMainThread()},initMainThread:function(){for(var H=8;H--;)De.allocateUnusedWorker()},initWorker:function(){X=!1},setExitStatus:function(H){q=H},terminateAllThreads:function(){for(var H of Object.values(De.pthreads))De.returnWorkerToPool(H);for(var H of De.unusedWorkers)H.terminate();De.unusedWorkers=[]},returnWorkerToPool:function(H){var ue=H.pthread_ptr;delete De.pthreads[ue],De.unusedWorkers.push(H),De.runningWorkers.splice(De.runningWorkers.indexOf(H),1),H.pthread_ptr=0,S&&H.unref(),Tp(ue)},receiveObjectTransfer:function(H){},threadInitTLS:function(){De.tlsInitFunctions.forEach(H=>H())},loadWasmModuleToWorker:function(H,ue){H.onmessage=at=>{var Me=at.data,Oe=Me.cmd;if(H.pthread_ptr&&(De.currentProxiedOperationCallerThread=H.pthread_ptr),Me.targetThread&&Me.targetThread!=Jr()){var jt=De.pthreads[Me.targetThread];jt?jt.postMessage(Me,Me.transferList):ee('Internal error! Worker sent a message "'+Oe+'" to target pthread '+Me.targetThread+", but that thread no longer exists!"),De.currentProxiedOperationCallerThread=void 0;return}Oe==="processProxyingQueue"?xa(Me.queue):Oe==="spawnThread"?xs(Me):Oe==="cleanupThread"?Xs(Me.thread):Oe==="killThread"?bs(Me.thread):Oe==="cancelThread"?vs(Me.thread):Oe==="loaded"?(H.loaded=!0,S&&H.unref(),ue&&ue(H),H.runPthread&&H.runPthread()):Oe==="print"?J("Thread "+Me.threadId+": "+Me.text):Oe==="printErr"?ee("Thread "+Me.threadId+": "+Me.text):Oe==="alert"?alert("Thread "+Me.threadId+": "+Me.text):Me.target==="setimmediate"?H.postMessage(Me):Oe==="callHandler"?c[Me.handler](...Me.args):Oe&&ee("worker sent an unknown command "+Oe),De.currentProxiedOperationCallerThread=void 0},H.onerror=at=>{var Me="worker sent an error!";throw ee(Me+" "+at.filename+":"+at.lineno+": "+at.message),at},S&&(H.on("message",function(at){H.onmessage({data:at})}),H.on("error",function(at){H.onerror(at)}),H.on("detachedExit",function(){}));var Ce=[],Ge=["onExit","onAbort","print","printErr"];for(var Ke of Ge)c.hasOwnProperty(Ke)&&Ce.push(Ke);H.postMessage({cmd:"load",handlers:Ce,urlOrBlob:c.mainScriptUrlOrBlob||n,wasmMemory:Q,wasmModule:ce})},allocateUnusedWorker:function(){var H,ue=_("tfjs-backend-wasm-threaded-simd.worker.js");H=new Worker(ue),De.unusedWorkers.push(H)},getNewWorker:function(){return De.unusedWorkers.length==0&&(De.allocateUnusedWorker(),De.loadWasmModuleToWorker(De.unusedWorkers[0])),De.unusedWorkers.pop()}};c.PThread=De;function It(H){for(;H.length>0;)H.shift()(c)}function dt(){var H=Jr(),ue=o()[H+52>>>2],Ce=o()[H+56>>>2],Ge=ue-Ce;Cp(ue,Ge),Uc(ue)}c.establishStackSpace=dt;function qe(H){if(N)return Zs(2,0,H);try{_e(H)}catch(ue){Ve(ue)}}var Ye=[];function ia(H){var ue=Ye[H];return ue||(H>=Ye.length&&(Ye.length=H+1),Ye[H]=ue=tt.get(H)),ue}function On(H,ue){var Ce=ia(H)(ue);na()?De.setExitStatus(Ce):_p(Ce)}c.invokeEntryPoint=On;function Yr(H){De.tlsInitFunctions.push(H)}function al(H){Ip(H,!k,1,!x),De.threadInitTLS()}function Zr(H){N?postMessage({cmd:"cleanupThread",thread:H}):Xs(H)}function $i(H,ue,Ce,Ge){return N?Zs(3,1,H,ue,Ce,Ge):fa(H,ue,Ce,Ge)}function fa(H,ue,Ce,Ge){if(typeof SharedArrayBuffer>"u")return ee("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Ke=[],at=0;if(N&&(Ke.length===0||at))return $i(H,ue,Ce,Ge);var Me={startRoutine:Ce,pthread_ptr:H,arg:Ge,transferList:Ke};return N?(Me.cmd="spawnThread",postMessage(Me,Ke),0):xs(Me)}function zn(){return 65536}var ws=!0;function Ri(){return ws}function xa(H){Atomics.store(o(),H>>2,1),Jr()&&Qs(H),Atomics.compareExchange(o(),H>>2,1,0)}c.executeNotifiedProxyingQueue=xa;function pg(H,ue,Ce,Ge){if(H==ue)setTimeout(()=>xa(Ge));else if(N)postMessage({targetThread:H,cmd:"processProxyingQueue",queue:Ge});else{var Ke=De.pthreads[H];if(!Ke)return;Ke.postMessage({cmd:"processProxyingQueue",queue:Ge})}return 1}function fg(H,ue,Ce){return-1}function Ys(){Xr("")}function Ar(H){Ar.shown||(Ar.shown={}),Ar.shown[H]||(Ar.shown[H]=1,S&&(H="warning: "+H),ee(H))}function Zv(){S||k||Ar("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function mg(){return Date.now()}function yp(){return 4294901760}function Qv(){return yp()}var Di;S?Di=()=>{var H=process.hrtime();return H[0]*1e3+H[1]/1e6}:Di=()=>performance.timeOrigin+performance.now();function zc(H,ue,Ce){i().copyWithin(H>>>0,ue>>>0,ue+Ce>>>0)}function Qr(){return S?HU().cpus().length:navigator.hardwareConcurrency}function bp(H){var ue=rl(),Ce=H();return Uc(ue),Ce}function Zs(H,ue){var Ce=arguments.length-2,Ge=arguments;return bp(()=>{for(var Ke=Ce,at=Pc(Ke*8),Me=at>>3,Oe=0;Oe<Ce;Oe++){var jt=Ge[2+Oe];d()[Me+Oe>>>0]=jt}return Np(H,Ke,at,ue)})}var ks=[];function vp(H,ue,Ce){ks.length=ue;for(var Ge=Ce>>3,Ke=0;Ke<ue;Ke++)ks[Ke]=d()[Ge+Ke>>>0];var at=H<0,Me=at?el[-H-1]:yg[H];return Me.apply(null,ks)}function xp(H){try{return Q.grow(H-Ne.byteLength+65535>>>16),pt(Q.buffer),1}catch{}}function Jv(H){var ue=i().length;if(H=H>>>0,H<=ue)return!1;var Ce=yp();if(H>Ce)return!1;let Ge=(jt,rn)=>jt+(rn-jt%rn)%rn;for(var Ke=1;Ke<=4;Ke*=2){var at=ue*(1+.2/Ke);at=Math.min(at,H+100663296);var Me=Math.min(Ce,Ge(Math.max(H,at),65536)),Oe=xp(Me);if(Oe)return!0}return!1}function gg(){throw"unwind"}function Ln(H){return N?Zs(4,1,H):52}function wp(H,ue,Ce,Ge,Ke){return N?Zs(5,1,H,ue,Ce,Ge,Ke):70}var ex=[null,[],[]];function Lc(H,ue){var Ce=ex[H];ue===0||ue===10?((H===1?J:ee)(pe(Ce,0)),Ce.length=0):Ce.push(ue)}function kp(H,ue,Ce,Ge){if(N)return Zs(6,1,H,ue,Ce,Ge);for(var Ke=0,at=0;at<Ce;at++){var Me=u()[ue>>>2],Oe=u()[ue+4>>>2];ue+=8;for(var jt=0;jt<Oe;jt++)Lc(H,i()[Me+jt>>>0]);Ke+=Oe}return u()[Ge>>>2]=Ke,0}function nl(H){var ue=c["_"+H];return ue}function tx(H,ue){s().set(H,ue>>>0)}function Xn(H,ue,Ce,Ge,Ke){var at={string:Kt=>{var Yn=0;if(Kt!=null&&Kt!==0){var il=(Kt.length<<2)+1;Yn=Pc(il),Re(Kt,Yn,il)}return Yn},array:Kt=>{var Yn=Pc(Kt.length);return tx(Kt,Yn),Yn}};function Me(Kt){return ue==="string"?ve(Kt):ue==="boolean"?!!Kt:Kt}var Oe=nl(H),jt=[],rn=0;if(Ge)for(var $r=0;$r<Ge.length;$r++){var sl=at[Ce[$r]];sl?(rn===0&&(rn=rl()),jt[$r]=sl(Ge[$r])):jt[$r]=Ge[$r]}var Oi=Oe.apply(null,jt);function bg(Kt){return rn!==0&&Uc(rn),Me(Kt)}return Oi=bg(Oi),Oi}function Sp(H,ue,Ce,Ge){Ce=Ce||[];var Ke=Ce.every(Me=>Me==="number"||Me==="boolean"),at=ue!=="string";return at&&Ke&&!Ge?nl(H):function(){return Xn(H,ue,Ce,arguments)}}De.init();var yg=[null,tl,qe,$i,Ln,wp,kp],Bc={__emscripten_init_main_thread_js:al,__emscripten_thread_cleanup:Zr,__pthread_create_js:fa,_emscripten_default_pthread_stack_size:zn,_emscripten_get_now_is_monotonic:Ri,_emscripten_notify_task_queue:pg,_emscripten_set_offscreencanvas_size:fg,abort:Ys,emscripten_check_blocking_allowed:Zv,emscripten_date_now:mg,emscripten_get_heap_max:Qv,emscripten_get_now:Di,emscripten_memcpy_big:zc,emscripten_num_logical_cores:Qr,emscripten_receive_on_main_thread_js:vp,emscripten_resize_heap:Jv,emscripten_unwind_to_js_event_loop:gg,exit:_e,fd_close:Ln,fd_seek:wp,fd_write:kp,memory:Q||c.wasmMemory};Oc(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)};var Jr=c._pthread_self=function(){return(Jr=c._pthread_self=c.asm.pthread_self).apply(null,arguments)};c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)};var Ip=c.__emscripten_thread_init=function(){return(Ip=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Np=c._emscripten_run_in_main_runtime_thread_js=function(){return(Np=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var Qs=c.__emscripten_proxy_execute_task_queue=function(){return(Qs=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},Tp=c.__emscripten_thread_free_data=function(){return(Tp=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},_p=c.__emscripten_thread_exit=function(){return(_p=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},Cp=c._emscripten_stack_set_limits=function(){return(Cp=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},rl=c.stackSave=function(){return(rl=c.stackSave=c.asm.stackSave).apply(null,arguments)},Uc=c.stackRestore=function(){return(Uc=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},Pc=c.stackAlloc=function(){return(Pc=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.keepRuntimeAlive=na,c.wasmMemory=Q,c.cwrap=Sp,c.ExitStatus=Er,c.PThread=De;var Js;ba=function H(){Js||Wc(),Js||(ba=H)};function Wc(H){if($t>0)return;if(N){f(c),Oa(),startWorker(c);return}if(Fa(),$t>0)return;function ue(){Js||(Js=!0,c.calledRun=!0,!L&&(Oa(),f(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),nn()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),ue()},1)):ue()}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();Wc();var Mi;g&&(Mi={uncaughtException:process.listeners("uncaughtException").filter(function(H){return!g.uncaughtException.indexOf(H)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(H){return!g.unhandledRejection.indexOf(H)>-1})});var es;if(typeof WasmBackendModule<"u")es=WasmBackendModule;else if(typeof r<"u")es=r;else throw new Error("Could not find wasm module in post.js");if(Mi){var Fi=es._dispose;es._dispose=function(){Fi(),Mi.uncaughtException.forEach(function(H){process.removeListener("uncaughtException",H)}),Mi.unhandledRejection.forEach(function(H){process.removeListener("unhandledRejection",H)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=a:typeof define=="function"&&define.amd?define([],function(){return a}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=a)}),jU=Da((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),KU=Da((e,t)=>{var a=(()=>{var n=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(n=n||__filename),function(r){r=r||{};var s=typeof r<"u"?r:{},i,o;s.ready=new Promise(function(ye,_e){i=ye,o=_e});var u;typeof process<"u"&&process.listeners&&(u={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d=Object.assign({},s),c=typeof window=="object",f=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="";function b(ye){return s.locateFile?s.locateFile(ye,g):g+ye}var v,x,k;if(m){var S=D1(),N=dA();f?g=N.dirname(g)+"/":g=__dirname+"/",v=(ye,_e)=>(ye=xt(ye)?new URL(ye):N.normalize(ye),S.readFileSync(ye,_e?void 0:"utf8")),k=ye=>{var _e=v(ye,!0);return _e.buffer||(_e=new Uint8Array(_e)),_e},x=(ye,_e,Ve)=>{ye=xt(ye)?new URL(ye):N.normalize(ye),S.readFile(ye,function(De,It){De?Ve(De):_e(It.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(ye){if(!(ye instanceof na))throw ye}),process.on("unhandledRejection",function(ye){throw ye}),s.inspect=function(){return"[Emscripten Module object]"}}else(c||f)&&(f?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),n&&(g=n),g.indexOf("blob:")!==0?g=g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):g="",v=ye=>{var _e=new XMLHttpRequest;return _e.open("GET",ye,!1),_e.send(null),_e.responseText},f&&(k=ye=>{var _e=new XMLHttpRequest;return _e.open("GET",ye,!1),_e.responseType="arraybuffer",_e.send(null),new Uint8Array(_e.response)}),x=(ye,_e,Ve)=>{var De=new XMLHttpRequest;De.open("GET",ye,!0),De.responseType="arraybuffer",De.onload=()=>{if(De.status==200||De.status==0&&De.response){_e(De.response);return}Ve()},De.onerror=Ve,De.send(null)});var T=s.print||console.log.bind(console),_=s.printErr||console.warn.bind(console);Object.assign(s,d),d=null,s.arguments&&s.arguments,s.thisProgram&&s.thisProgram,s.quit&&s.quit;var R;s.wasmBinary&&(R=s.wasmBinary),s.noExitRuntime,typeof WebAssembly!="object"&&st("no native wasm support detected");var M,F=!1,B=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function V(ye,_e,Ve){_e>>>=0;for(var De=_e+Ve,It=_e;ye[It]&&!(It>=De);)++It;if(It-_e>16&&ye.buffer&&B)return B.decode(ye.subarray(_e,It));for(var dt="";_e<It;){var qe=ye[_e++];if(!(qe&128)){dt+=String.fromCharCode(qe);continue}var Ye=ye[_e++]&63;if((qe&224)==192){dt+=String.fromCharCode((qe&31)<<6|Ye);continue}var ia=ye[_e++]&63;if((qe&240)==224?qe=(qe&15)<<12|Ye<<6|ia:qe=(qe&7)<<18|Ye<<12|ia<<6|ye[_e++]&63,qe<65536)dt+=String.fromCharCode(qe);else{var On=qe-65536;dt+=String.fromCharCode(55296|On>>10,56320|On&1023)}}return dt}function P(ye,_e){return ye>>>=0,ye?V(W,ye,_e):""}function A(ye,_e,Ve,De){if(Ve>>>=0,!(De>0))return 0;for(var It=Ve,dt=Ve+De-1,qe=0;qe<ye.length;++qe){var Ye=ye.charCodeAt(qe);if(Ye>=55296&&Ye<=57343){var ia=ye.charCodeAt(++qe);Ye=65536+((Ye&1023)<<10)|ia&1023}if(Ye<=127){if(Ve>=dt)break;_e[Ve++>>>0]=Ye}else if(Ye<=2047){if(Ve+1>=dt)break;_e[Ve++>>>0]=192|Ye>>6,_e[Ve++>>>0]=128|Ye&63}else if(Ye<=65535){if(Ve+2>=dt)break;_e[Ve++>>>0]=224|Ye>>12,_e[Ve++>>>0]=128|Ye>>6&63,_e[Ve++>>>0]=128|Ye&63}else{if(Ve+3>=dt)break;_e[Ve++>>>0]=240|Ye>>18,_e[Ve++>>>0]=128|Ye>>12&63,_e[Ve++>>>0]=128|Ye>>6&63,_e[Ve++>>>0]=128|Ye&63}}return _e[Ve>>>0]=0,Ve-It}function G(ye,_e,Ve){return A(ye,W,_e,Ve)}var J,ee,W,X;function Q(ye){J=ye,s.HEAP8=ee=new Int8Array(ye),s.HEAP16=new Int16Array(ye),s.HEAP32=new Int32Array(ye),s.HEAPU8=W=new Uint8Array(ye),s.HEAPU16=new Uint16Array(ye),s.HEAPU32=X=new Uint32Array(ye),s.HEAPF32=new Float32Array(ye),s.HEAPF64=new Float64Array(ye)}s.INITIAL_MEMORY;var ce=[],L=[],q=[];function le(){if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)ve(s.preRun.shift());Fa(ce)}function se(){Fa(L)}function pe(){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;)Re(s.postRun.shift());Fa(q)}function ve(ye){ce.unshift(ye)}function Ie(ye){L.unshift(ye)}function Re(ye){q.unshift(ye)}var Ne=0,Le=null;function je(ye){Ne++,s.monitorRunDependencies&&s.monitorRunDependencies(Ne)}function Je(ye){if(Ne--,s.monitorRunDependencies&&s.monitorRunDependencies(Ne),Ne==0&&Le){var _e=Le;Le=null,_e()}}function st(ye){s.onAbort&&s.onAbort(ye),ye="Aborted("+ye+")",_(ye),F=!0,ye+=". Build with -sASSERTIONS for more info.";var _e=new WebAssembly.RuntimeError(ye);throw o(_e),_e}var At="data:application/octet-stream;base64,";function pt(ye){return ye.startsWith(At)}function xt(ye){return ye.startsWith("file://")}var tt;tt="tfjs-backend-wasm.wasm",pt(tt)||(tt=b(tt));function ot(ye){try{if(ye==tt&&R)return new Uint8Array(R);if(k)return k(ye);throw"both async and sync fetching of the wasm failed"}catch(_e){st(_e)}}function Bt(){if(!R&&(c||f)){if(typeof fetch=="function"&&!xt(tt))return fetch(tt,{credentials:"same-origin"}).then(function(ye){if(!ye.ok)throw"failed to load wasm binary file at '"+tt+"'";return ye.arrayBuffer()}).catch(function(){return ot(tt)});if(x)return new Promise(function(ye,_e){x(tt,function(Ve){ye(new Uint8Array(Ve))},_e)})}return Promise.resolve().then(function(){return ot(tt)})}function pn(){var ye={env:ys,wasi_snapshot_preview1:ys};function _e(qe,Ye){var ia=qe.exports;s.asm=ia,M=s.asm.memory,Q(M.buffer),s.asm.__indirect_function_table,Ie(s.asm.__wasm_call_ctors),Je()}je();function Ve(qe){_e(qe.instance)}function De(qe){return Bt().then(function(Ye){return WebAssembly.instantiate(Ye,ye)}).then(function(Ye){return Ye}).then(qe,function(Ye){_("failed to asynchronously prepare wasm: "+Ye),st(Ye)})}function It(){return!R&&typeof WebAssembly.instantiateStreaming=="function"&&!pt(tt)&&!xt(tt)&&!m&&typeof fetch=="function"?fetch(tt,{credentials:"same-origin"}).then(function(qe){var Ye=WebAssembly.instantiateStreaming(qe,ye);return Ye.then(Ve,function(ia){return _("wasm streaming compile failed: "+ia),_("falling back to ArrayBuffer instantiation"),De(Ve)})}):De(Ve)}if(s.instantiateWasm)try{var dt=s.instantiateWasm(ye,_e);return dt}catch(qe){_("Module.instantiateWasm callback failed with error: "+qe),o(qe)}return It().catch(o),{}}function na(ye){this.name="ExitStatus",this.message="Program terminated with exit("+ye+")",this.status=ye}function Fa(ye){for(;ye.length>0;)ye.shift()(s)}function Oa(){st("")}function nn(){return 4294901760}function Kn(){return nn()}function wn(ye,_e,Ve){W.copyWithin(ye>>>0,_e>>>0,_e+Ve>>>0)}function Na(ye){try{return M.grow(ye-J.byteLength+65535>>>16),Q(M.buffer),1}catch{}}function $t(ye){var _e=W.length;ye=ye>>>0;var Ve=nn();if(ye>Ve)return!1;let De=(ia,On)=>ia+(On-ia%On)%On;for(var It=1;It<=4;It*=2){var dt=_e*(1+.2/It);dt=Math.min(dt,ye+100663296);var qe=Math.min(Ve,De(Math.max(ye,dt),65536)),Ye=Na(qe);if(Ye)return!0}return!1}function ba(ye){return 52}function va(ye,_e,Ve,De,It){return 70}var Qo=[null,[],[]];function Xr(ye,_e){var Ve=Qo[ye];_e===0||_e===10?((ye===1?T:_)(V(Ve,0)),Ve.length=0):Ve.push(_e)}function Jo(ye,_e,Ve,De){for(var It=0,dt=0;dt<Ve;dt++){var qe=X[_e>>>2],Ye=X[_e+4>>>2];_e+=8;for(var ia=0;ia<Ye;ia++)Xr(ye,W[qe+ia>>>0]);It+=Ye}return X[De>>>2]=It,0}function Fn(ye){var _e=s["_"+ye];return _e}function hr(ye,_e){ee.set(ye,_e>>>0)}function ra(ye,_e,Ve,De,It){var dt={string:fa=>{var zn=0;if(fa!=null&&fa!==0){var ws=(fa.length<<2)+1;zn=Er(ws),G(fa,zn,ws)}return zn},array:fa=>{var zn=Er(fa.length);return hr(fa,zn),zn}};function qe(fa){return _e==="string"?P(fa):_e==="boolean"?!!fa:fa}var Ye=Fn(ye),ia=[],On=0;if(De)for(var Yr=0;Yr<De.length;Yr++){var al=dt[Ve[Yr]];al?(On===0&&(On=Oc()),ia[Yr]=al(De[Yr])):ia[Yr]=De[Yr]}var Zr=Ye.apply(null,ia);function $i(fa){return On!==0&&el(On),qe(fa)}return Zr=$i(Zr),Zr}function Ks(ye,_e,Ve,De){Ve=Ve||[];var It=Ve.every(qe=>qe==="number"||qe==="boolean"),dt=_e!=="string";return dt&&It&&!De?Fn(ye):function(){return ra(ye,_e,Ve,arguments)}}var ys={abort:Oa,emscripten_get_heap_max:Kn,emscripten_memcpy_big:wn,emscripten_resize_heap:$t,fd_close:ba,fd_seek:va,fd_write:Jo};pn(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Acos=function(){return(s._Acos=s.asm.Acos).apply(null,arguments)},s._Acosh=function(){return(s._Acosh=s.asm.Acosh).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._ArgMin=function(){return(s._ArgMin=s.asm.ArgMin).apply(null,arguments)},s._Asin=function(){return(s._Asin=s.asm.Asin).apply(null,arguments)},s._Asinh=function(){return(s._Asinh=s.asm.Asinh).apply(null,arguments)},s._Atan=function(){return(s._Atan=s.asm.Atan).apply(null,arguments)},s._Atan2=function(){return(s._Atan2=s.asm.Atan2).apply(null,arguments)},s._Atanh=function(){return(s._Atanh=s.asm.Atanh).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._AvgPool3D=function(){return(s._AvgPool3D=s.asm.AvgPool3D).apply(null,arguments)},s._AvgPool3DGrad=function(){return(s._AvgPool3DGrad=s.asm.AvgPool3DGrad).apply(null,arguments)},s._AvgPoolGrad=function(){return(s._AvgPoolGrad=s.asm.AvgPoolGrad).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Bincount=function(){return(s._Bincount=s.asm.Bincount).apply(null,arguments)},s._BitwiseAnd=function(){return(s._BitwiseAnd=s.asm.BitwiseAnd).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Conv3D=function(){return(s._Conv3D=s.asm.Conv3D).apply(null,arguments)},s._Conv3DBackpropFilterV2=function(){return(s._Conv3DBackpropFilterV2=s.asm.Conv3DBackpropFilterV2).apply(null,arguments)},s._Conv3DBackpropInputV2=function(){return(s._Conv3DBackpropInputV2=s.asm.Conv3DBackpropInputV2).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DenseBincount=function(){return(s._DenseBincount=s.asm.DenseBincount).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Diag=function(){return(s._Diag=s.asm.Diag).apply(null,arguments)},s._Dilation2D=function(){return(s._Dilation2D=s.asm.Dilation2D).apply(null,arguments)},s._Dilation2DBackpropFilter=function(){return(s._Dilation2DBackpropFilter=s.asm.Dilation2DBackpropFilter).apply(null,arguments)},s._Dilation2DBackpropInput=function(){return(s._Dilation2DBackpropInput=s.asm.Dilation2DBackpropInput).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._EluGrad=function(){return(s._EluGrad=s.asm.EluGrad).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Erf=function(){return(s._Erf=s.asm.Erf).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._Expm1=function(){return(s._Expm1=s.asm.Expm1).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._IsFinite=function(){return(s._IsFinite=s.asm.IsFinite).apply(null,arguments)},s._IsInf=function(){return(s._IsInf=s.asm.IsInf).apply(null,arguments)},s._IsNan=function(){return(s._IsNan=s.asm.IsNan).apply(null,arguments)},s._LRN=function(){return(s._LRN=s.asm.LRN).apply(null,arguments)},s._LRNGrad=function(){return(s._LRNGrad=s.asm.LRNGrad).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._LinSpace=function(){return(s._LinSpace=s.asm.LinSpace).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._Log1p=function(){return(s._Log1p=s.asm.Log1p).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._LogicalNot=function(){return(s._LogicalNot=s.asm.LogicalNot).apply(null,arguments)},s._LogicalOr=function(){return(s._LogicalOr=s.asm.LogicalOr).apply(null,arguments)},s._LogicalXor=function(){return(s._LogicalXor=s.asm.LogicalXor).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._MaxPool3D=function(){return(s._MaxPool3D=s.asm.MaxPool3D).apply(null,arguments)},s._MaxPool3DGrad=function(){return(s._MaxPool3DGrad=s.asm.MaxPool3DGrad).apply(null,arguments)},s._MaxPoolGrad=function(){return(s._MaxPoolGrad=s.asm.MaxPoolGrad).apply(null,arguments)},s._MaxPoolWithArgmax=function(){return(s._MaxPoolWithArgmax=s.asm.MaxPoolWithArgmax).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Mod=function(){return(s._Mod=s.asm.Mod).apply(null,arguments)},s._Multinomial=function(){return(s._Multinomial=s.asm.Multinomial).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Reciprocal=function(){return(s._Reciprocal=s.asm.Reciprocal).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._ResizeBilinearGrad=function(){return(s._ResizeBilinearGrad=s.asm.ResizeBilinearGrad).apply(null,arguments)},s._ResizeNearestNeighbor=function(){return(s._ResizeNearestNeighbor=s.asm.ResizeNearestNeighbor).apply(null,arguments)},s._ResizeNearestNeighborGrad=function(){return(s._ResizeNearestNeighborGrad=s.asm.ResizeNearestNeighborGrad).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SearchSorted=function(){return(s._SearchSorted=s.asm.SearchSorted).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Selu=function(){return(s._Selu=s.asm.Selu).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sign=function(){return(s._Sign=s.asm.Sign).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Sinh=function(){return(s._Sinh=s.asm.Sinh).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._Softplus=function(){return(s._Softplus=s.asm.Softplus).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._SparseToDense=function(){return(s._SparseToDense=s.asm.SparseToDense).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._TensorScatterUpdate=function(){return(s._TensorScatterUpdate=s.asm.TensorScatterUpdate).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)};var Oc=s.stackSave=function(){return(Oc=s.stackSave=s.asm.stackSave).apply(null,arguments)},el=s.stackRestore=function(){return(el=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},Er=s.stackAlloc=function(){return(Er=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)},s.cwrap=Ks;var bs;Le=function ye(){bs||vs(),bs||(Le=ye)};function vs(ye){if(Ne>0||(le(),Ne>0))return;function _e(){bs||(bs=!0,s.calledRun=!0,!F&&(se(),i(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),pe()))}s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),_e()},1)):_e()}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();vs();var Xs;u&&(Xs={uncaughtException:process.listeners("uncaughtException").filter(function(ye){return!u.uncaughtException.indexOf(ye)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(ye){return!u.unhandledRejection.indexOf(ye)>-1})});var xs;if(typeof r<"u")xs=r;else if(typeof WasmBackendModuleThreadedSimd<"u")xs=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Xs){var tl=xs._dispose;xs._dispose=function(){tl(),Xs.uncaughtException.forEach(function(ye){process.removeListener("uncaughtException",ye)}),Xs.unhandledRejection.forEach(function(ye){process.removeListener("unhandledRejection",ye)})}}return r.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=a:typeof define=="function"&&define.amd?define([],function(){return a}):typeof e=="object"&&(e.WasmBackendModule=a)}),Sb=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},lm=class{refCount(e){return er("refCount")}incRef(e){return er("incRef")}timerAvailable(){return!0}time(e){return er("time")}read(e){return er("read")}readSync(e){return er("readSync")}readToGPU(e,t){return er("readToGPU")}numDataIds(){return er("numDataIds")}disposeData(e,t){return er("disposeData")}write(e,t,a){return er("write")}move(e,t,a,n,r){return er("move")}createTensorFromGPUData(e,t,a){return er("createTensorFromGPUData")}memory(){return er("memory")}floatPrecision(){return er("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return er("dispose")}};function er(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function hA(e){let t=e.length,a=0;for(;t>0;)a=Math.random()*t|0,t--,qy(e,t,a)}function XU(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let a=e.length,n=0;for(;a>0;)n=Math.random()*a|0,a--,qy(e,a,n),qy(t,a,n)}function Wf(e,t,a){return Math.max(e,Math.min(t,a))}function YU(e){return e%2===0?e:e+1}function qy(e,t,a){let n=e[t];e[t]=e[a],e[a]=n}function ZU(e){let t=0;for(let a=0;a<e.length;a++)t+=e[a];return t}function QU(e,t){let a=Math.random();return t*a+(1-a)*e}function JU(e,t){let a=0;for(let n=0;n<e.length;n++){let r=Number(e[n])-Number(t[n]);a+=r*r}return a}function U(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function $n(e,t,a=""){U(Si(e,t),()=>a+` Shapes ${e} and ${t} must match`)}function su(e){U(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function zt(e){if(e.length===0)return 1;let t=e[0];for(let a=1;a<e.length;a++)t*=e[a];return t}function eP(e){return e.length===0}function pA(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let a=0;a<e.length;a++)if(e[a]!==null&&t[a]!==null&&e[a]!==t[a])return!1;return!0}function Si(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let a=0;a<e.length;a++)if(e[a]!==t[a])return!1;return!0}function Ed(e){return e%1===0}function tP(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function aP(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function nP(e){let t=new Uint32Array(e);for(let a=0;a<e;++a)t[a]=a;return hA(t),t}function zf(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function rP(e,t=r=>0,a,n){return new Promise((r,s)=>{let i=0,o=()=>{if(e()){r();return}i++;let u=t(i);if(a!=null&&i>=a){s();return}n!=null?n(o,u):setTimeout(o,u)};o()})}function sP(e,t){let a=1,n=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)a*=e[s];else if(e[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(n===-1){if(t>0&&t!==a)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(a===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%a!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${a}`);let r=e.slice();return r[n]=t/a,r}function qr(e,t){let a=t.length;return e=e==null?t.map((n,r)=>r):[].concat(e),U(e.every(n=>n>=-a&&n<a),()=>`All values in axis param must be in range [-${a}, ${a}) but got axis ${e}`),U(e.every(n=>Ed(n)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(n=>n<0?a+n:n)}function fA(e,t){let a=[],n=[],r=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||r?null:qr(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(s!=null){if(s[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(s[i]==null||s[i]>o)&&e[o]===1&&(a.push(e[o]),n.push(o)),s[i]<=o&&i++}e[o]!==1&&(a.push(e[o]),n.push(o))}return{newShape:a,keptDims:n}}function mA(e,t){return M1(e,t)}function M1(e,t){let a=null;if(e==null||e==="float32")a=new Float32Array(t);else if(e==="int32")a=new Int32Array(t);else if(e==="bool")a=new Uint8Array(t);else if(e==="string")a=new Array(t);else throw new Error(`Unknown data type ${e}`);return a}function gA(e,t){for(let a=0;a<e.length;a++){let n=e[a];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function yA(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function iP(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function jy(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function bA(e){if(e==null)return 0;let t=0;return e.forEach(a=>t+=a.length),t}function po(e){return typeof e=="string"||e instanceof String}function vA(e){return typeof e=="boolean"}function xA(e){return typeof e=="number"}function um(e){return Array.isArray(e)?um(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":xA(e)?"float32":po(e)?"string":vA(e)?"bool":"float32"}function xo(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Ky(e,t){for(let a=t;a<e;++a)if(e%a===0)return a;return e}function jd(e){let t=e.length;if(t<2)return[];let a=new Array(t-1);a[t-2]=e[t-1];for(let n=t-3;n>=0;--n)a[n]=a[n+1]*e[n+1];return a}function wA(e,t,a,n=!1){let r=new Array;if(t.length===1){let s=t[0]*(n?2:1);for(let i=0;i<s;i++)r[i]=a[e+i]}else{let s=t[0],i=t.slice(1),o=i.reduce((u,d)=>u*d)*(n?2:1);for(let u=0;u<s;u++)r[u]=wA(e+u*o,i,a,n)}return r}function Nd(e,t,a=!1){if(e.length===0)return t[0];let n=e.reduce((r,s)=>r*s)*(a?2:1);if(n===0)return[];if(n!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${a?" for a complex tensor":""}.`);return wA(0,e,t,a)}function oP(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function F1(e,t){let a=Ib(e,t);for(let n=0;n<a.length;n++)a[n]=1;return a}function Ib(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function lP(e,t){let a=e.reduce((n,r)=>n*r,1);if(t==null||t==="float32")return Nd(e,new Float32Array(a));if(t==="int32")return Nd(e,new Int32Array(a));if(t==="bool")return Nd(e,new Uint8Array(a));throw new Error(`Unknown data type ${t}`)}function dr(e){e.forEach(t=>{U(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function uP(e,t,a){if(t===0)return 0;if(t===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=a[r]*e[r];return n}function cP(e,t,a){if(t===0)return[];if(t===1)return[e];let n=new Array(t);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/a[r]),e-=n[r]*a[r];return n[n.length-1]=e,n}function Nb(e){return e&&e.then&&typeof e.then=="function"}var kC="tfjsflags",kA=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=dP,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,a){if(this.flagRegistry[e]={evaluationFn:t,setHook:a},this.urlFlags[e]!=null){let n=this.urlFlags[e];ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${n}.`),this.set(e,n)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Nb(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);kC in e&&e[kC].split(",").forEach(t=>{let[a,n]=t.split(":");this.urlFlags[a]=pP(a,n)})}};function dP(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(a,...n)=>(hP(t,n[0],n[1]),n.join("="))),t}function hP(e,t,a){e[decodeURIComponent(t)]=decodeURIComponent(a||"")}function pP(e,t){let a=t.toLowerCase();return a==="true"||a==="false"?a==="true":`${+a}`===a?+a:t}function ie(){return O1}var O1=null;function fP(e){O1=e}var nw;function SA(){if(nw==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");nw=e}return nw}function mP(){let e=SA();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function z1(e,t){let a=mP();if(a.has(e))return a.get(e);{let n=t();return a.set(e,n),a.get(e)}}var Kd="Abs",iu="Acos",ou="Acosh",Oo="Add",lu="AddN",Xd="All",Yd="Any",Zd="ArgMax",Qd="ArgMin",uu="Asin",cu="Asinh",du="Atan",hu="Atanh",pu="Atan2",fu="AvgPool",cm="AvgPoolGrad",Jd="AvgPool3D",dm="AvgPool3DGrad",mu="BatchMatMul",eh="BatchToSpaceND",th="Bincount",ah="BitwiseAnd",IA="BroadcastTo",hm="BroadcastArgs",gu="Cast",yu="Ceil",zo="ClipByValue",Tb="Complex",pm="ComplexAbs",nh="Concat",bu="Conv2D",_b="Conv2DBackpropFilter",vu="Conv2DBackpropInput",xu="Conv3D",rh="Conv3DBackpropFilterV2",sh="Conv3DBackpropInputV2",wu="Cos",ku="Cosh",ih="Cumprod",Su="Cumsum",oh="CropAndResize",fm="DenseBincount",lh="DepthToSpace",Iu="DepthwiseConv2dNative",Cb="DepthwiseConv2dNativeBackpropFilter",Eb="DepthwiseConv2dNativeBackpropInput",mm="Diag",Nu="Dilation2D",Ad="Dilation2DBackpropInput",$d="Dilation2DBackpropFilter",Ab="Draw",Tu="RealDiv",$b="Einsum",_u="Elu",uh="EluGrad",Cu="Erf",ch="Equal",Eu="Exp",dh="ExpandDims",Au="Expm1",Rb="FFT",gm="Fill",hh="FlipLeftRight",$u="Floor",Ru="FloorDiv",Du="FusedBatchNorm",ph="GatherV2",fh="GatherNd",mh="Greater",Mu="GreaterEqual",Fu="Identity",Db="IFFT",Mb="Imag",Ou="IsFinite",zu="IsInf",Lu="IsNan",Bu="LeakyRelu",gh="Less",yh="LessEqual",bh="LinSpace",Uu="Log",Pu="Log1p",vh="LogicalAnd",xh="LogicalNot",wh="LogicalOr",NA="LogicalXor",TA="LogSoftmax",gP="LowerBound",Wu="LRN",kh="LRNGrad",yP="MatrixBandPart",Vu="Max",Gu="Maximum",Hu="MaxPool",ym="MaxPoolGrad",Sh="MaxPool3D",bm="MaxPool3DGrad",vm="MaxPoolWithArgmax",qu="Mean",ju="Min",Ku="Minimum",Xu="MirrorPad",Yu="Mod",Ih="Multinomial",Zu="Multiply",Nh="Neg",Th="NotEqual",_h="NonMaxSuppressionV3",Ch="NonMaxSuppressionV4",Eh="NonMaxSuppressionV5",Ah="OnesLike",Qu="OneHot",$h="Pack",Ju="PadV2",bP="Pool",ec="Pow",tc="Prelu",ac="Prod",Fb="RaggedGather",Ob="RaggedRange",zb="RaggedTensorToTensor",xm="Range",Lb="Real",nc="Reciprocal",rc="Relu",Rh="Reshape",sc="ResizeNearestNeighbor",Dh="ResizeNearestNeighborGrad",ic="ResizeBilinear",Mh="ResizeBilinearGrad",oc="Relu6",lc="Reverse",uc="Round",cc="Rsqrt",Fh="ScatterNd",Oh="TensorScatterUpdate",zh="SearchSorted",Lh="Select",dc="Selu",Bh="Slice",hc="Sin",pc="Sinh",fc="Sign",mc="Sigmoid",gc="Softplus",yc="Sqrt",bc="Sum",Uh="SpaceToBatchND",Ph="SplitV",vc="Softmax",wm="SparseFillEmptyRows",Wh="SparseReshape",km="SparseSegmentMean",Sm="SparseSegmentSum",Vh="SparseToDense",xc="SquaredDifference",Im="Square",Nm="StaticRegexReplace",Gh="StridedSlice",Tm="StringNGrams",_m="StringSplit",Cm="StringToHashBucketFast",wc="Sub",kc="Tan",Sc="Tanh",Lo="Tile",Hh="TopK",qh="Transform",yi="Transpose",Em="Unique",jh="Unpack",Am="UnsortedSegmentSum",vP="UpperBound",Kh="ZerosLike",Bo="Step",Xy="FromPixels",Xh="RotateWithOffset",Bl="_FusedMatMul",Ul="FusedConv2D",Pl="FusedDepthwiseConv2D";function ho(...e){ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(...e)}function xP(...e){ie().getBool("IS_TEST")||ie().getBool("PROD")||console.log(...e)}var Rd=z1("kernelRegistry",()=>new Map),Vf=z1("gradRegistry",()=>new Map);function Gf(e,t){let a=L1(e,t);return Rd.get(a)}function kw(e){return Vf.get(e)}function Yy(e){let t=Rd.entries(),a=[];for(;;){let{done:n,value:r}=t.next();if(n)break;let[s,i]=r,[o]=s.split("_");o===e&&a.push(i)}return a}function $m(e){let{kernelName:t,backendName:a}=e,n=L1(t,a);Rd.has(n)&&ho(`The kernel '${t}' for backend '${a}' is already registered`),Rd.set(n,e)}function _A(e){let{kernelName:t}=e;Vf.has(t)&&ie().getBool("DEBUG")&&ho(`Overriding the gradient for '${t}'`),Vf.set(t,e)}function wP(e,t){let a=L1(e,t);if(!Rd.has(a))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Rd.delete(a)}function kP(e){if(!Vf.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Vf.delete(e)}function SP(e,t){Yy(e).forEach(a=>{let n=Object.assign({},a,{backendName:t});$m(n)})}function L1(e,t){return`${t}_${e}`}var C={};rt(C,{arraysEqual:()=>Si,arraysEqualWithNull:()=>pA,assert:()=>U,assertNonNegativeIntegerDimensions:()=>dr,assertNonNull:()=>su,assertShapesMatch:()=>$n,bytesFromStringArray:()=>bA,bytesPerElement:()=>jy,checkConversionForErrors:()=>gA,clamp:()=>Wf,computeStrides:()=>jd,convertBackendValuesAndArrayBuffer:()=>oP,createScalarValue:()=>EP,createShuffledIndices:()=>nP,decodeString:()=>Zy,distSquared:()=>JU,encodeString:()=>Dm,fetch:()=>$P,fingerPrint64:()=>CP,flatten:()=>wo,getArrayFromDType:()=>M1,getTypedArrayFromDType:()=>mA,hasEncodingLoss:()=>iP,hexToLong:()=>Rm,indexToLoc:()=>cP,inferDtype:()=>um,inferFromImplicitShape:()=>sP,isBoolean:()=>vA,isFunction:()=>xo,isInt:()=>Ed,isNumber:()=>xA,isPromise:()=>Nb,isScalarShape:()=>eP,isString:()=>po,isTypedArray:()=>Ya,isValidDtype:()=>yA,locToIndex:()=>uP,makeOnesTypedArray:()=>F1,makeZerosNestedTypedArray:()=>lP,makeZerosTypedArray:()=>Ib,nearestDivisor:()=>Ky,nearestLargerEven:()=>YU,now:()=>Hf,parseAxisParam:()=>qr,randUniform:()=>QU,repeatedTry:()=>rP,rightPad:()=>zf,shuffle:()=>hA,shuffleCombo:()=>XU,sizeFromShape:()=>zt,sizeToSquarishShape:()=>aP,squeezeShape:()=>fA,sum:()=>ZU,swap:()=>qy,tanh:()=>tP,toNestedArray:()=>Nd,toTypedArray:()=>Bb});function CA(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var SC=Fo(RU()),_l=SC.default||SC;function Rm(e){return _l.fromString(e,!0,16)}var EA=Rm("c3a5c85c97cb3127"),Il=Rm("b492b66fbe98f273"),In=Rm("9ae16a3b2f90404f");function Sw(e){return e.xor(e.shru(47))}function AA(e,t,a){let n=e.slice(t,t+a);return _l.fromBytes(Array.from(n),!0,!0)}function ea(e,t){return AA(e,t,8)}function IC(e,t){return AA(e,t,4)}function Xa(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function yo(e,t,a=Rm("9ddfea08eb382d69")){let n=e.xor(t).mul(a);n=n.xor(n.shru(47));let r=t.xor(n).mul(a);return r=r.xor(r.shru(47)),r=r.mul(a),r}function IP(e,t,a,n,r,s){r=r.add(e),s=Xa(s.add(r).add(n),21);let i=r;return r=r.add(t),r=r.add(a),s=s.add(Xa(r,44)),[r.add(n),s.add(i)]}function xy(e,t,a,n){return IP(ea(e,t),ea(e,t+8),ea(e,t+16),ea(e,t+24),a,n)}function NP(e,t=e.length){if(t>=8){let a=In.add(t*2),n=ea(e,0).add(In),r=ea(e,t-8),s=Xa(r,37).mul(a).add(n),i=Xa(n,25).add(r).mul(a);return yo(s,i,a)}if(t>=4){let a=In.add(t*2),n=IC(e,0);return yo(n.shl(3).add(t),IC(e,t-4),a)}if(t>0){let a=e[0],n=e[t>>1],r=e[t-1],s=a+(n<<8),i=t+(r<<2);return Sw(In.mul(s).xor(EA.mul(i))).mul(In)}return In}function TP(e,t=e.length){let a=In.add(t*2),n=ea(e,0).mul(Il),r=ea(e,8),s=ea(e,t-8).mul(a),i=ea(e,t-16).mul(In);return yo(Xa(n.add(r),43).add(Xa(s,30)).add(i),n.add(Xa(r.add(In),18)).add(s),a)}function _P(e,t=e.length){let a=In.add(t*2),n=ea(e,0).mul(In),r=ea(e,8),s=ea(e,t-8).mul(a),i=ea(e,t-16).mul(In),o=Xa(n.add(r),43).add(Xa(s,30)).add(i),u=yo(o,n.add(Xa(r.add(In),18)).add(s),a),d=ea(e,16).mul(a),c=ea(e,24),f=o.add(ea(e,t-32)).mul(a),m=u.add(ea(e,t-24)).mul(a);return yo(Xa(d.add(c),43).add(Xa(f,30)).add(m),d.add(Xa(c.add(n),18)).add(f),a)}function CP(e,t=e.length){let a=_l.fromNumber(81,!0);if(t<=32)return t<=16?NP(e,t):TP(e,t);if(t<=64)return _P(e,t);let n=a,r=a.mul(Il).add(113),s=Sw(r.mul(In).add(113)).mul(In),i=[_l.UZERO,_l.UZERO],o=[_l.UZERO,_l.UZERO];n=n.mul(In).add(ea(e,0));let u=0,d=(t-1>>6)*64,c=d+(t-1&63)-63;do n=Xa(n.add(r).add(i[0]).add(ea(e,u+8)),37).mul(Il),r=Xa(r.add(i[1]).add(ea(e,u+48)),42).mul(Il),n=n.xor(o[1]),r=r.add(i[0]).add(ea(e,u+40)),s=Xa(s.add(o[0]),33).mul(Il),i=xy(e,u,i[1].mul(Il),n.add(o[0])),o=xy(e,u+32,s.add(o[1]),r.add(ea(e,u+16))),[s,n]=[n,s],u+=64;while(u!==d);let f=Il.add(s.and(255).shl(1));return u=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),n=Xa(n.add(r).add(i[0]).add(ea(e,u+8)),37).mul(f),r=Xa(r.add(i[1]).add(ea(e,u+48)),42).mul(f),n=n.xor(o[1].mul(9)),r=r.add(i[0].mul(9).add(ea(e,u+40))),s=Xa(s.add(o[0]),33).mul(f),i=xy(e,u,i[1].mul(f),n.add(o[0])),o=xy(e,u+32,s.add(o[1]),r.add(ea(e,u+16))),[s,n]=[n,s],yo(yo(i[0],o[0],f).add(Sw(r).mul(EA)).add(s),yo(i[1],o[1],f).add(n),f)}function EP(e,t){return t==="string"?Dm(e):Bb([e],t)}function AP(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Bb(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=wo(e)),ie().getBool("DEBUG")&&gA(e,t),AP(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let a=new Uint8Array(e.length);for(let n=0;n<a.length;++n)Math.round(e[n])!==0&&(a[n]=1);return a}else throw new Error(`Unknown data type ${t}`)}function Hf(){return ie().platform.now()}function $P(e,t){return ie().platform.fetch(e,t)}function Dm(e,t="utf-8"){return t=t||"utf-8",ie().platform.encode(e,t)}function Zy(e,t="utf-8"){return t=t||"utf-8",ie().platform.decode(e,t)}function Ya(e){return ie().platform.isTypedArray!=null?ie().platform.isTypedArray(e):CA(e)}function wo(e,t=[],a=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||Nb(e)||e==null||Ya(e)&&a)t.push(e);else if(Array.isArray(e)||Ya(e))for(let n=0;n<e.length;++n)wo(e[n],t,a);else{let n=-1;for(let r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(n=Math.max(n,Number(r)));for(let r=0;r<=n;r++)wo(e[r],t,a)}return t}var RP=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new MP)}profileKernel(e,t,a){let n,r=()=>{n=a()},s,i=Hf();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(let o of n)o.dataSync();s=Promise.resolve({kernelMs:Hf()-i})}if(ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<n.length;o++){let u=n[o];u.data().then(d=>{DP(d,u.dtype,e)})}return{kernelName:e,outputs:n,inputs:t,timeMs:s.then(o=>o.kernelMs),extraInfo:s.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:a,timeMs:n,inputs:r,extraInfo:s}=e;a.forEach(i=>{Promise.all([i.data(),n,s]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],r,o[2])})})}};function DP(e,t,a){if(t!=="float32")return!1;for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${a}'`),!0}return!1}var MP=class{logKernelProfile(e,t,a,n,r,s){let i=typeof n=="number"?zf(`${n}ms`,9):n.error,o=zf(e,25),u=t.rank,d=t.size,c=zf(t.shape.toString(),14),f="";for(let m in r){let g=r[m];if(g!=null){let b=g.shape||t.shape,v=b.length;f+=`${m}: ${v}D ${v>0?b:""} `}}console.log(`%c${o}	%c${i}	%c${u}D ${c}	%c${d}	%c${f}	%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function FP(e,t,a){let n={},r={};for(let u=0;u<t.length;u++)n[t[u].id]=!0;for(let u=0;u<e.length;u++){let d=e[u],c=d.inputs;for(let f in c){let m=c[f],g=!1;for(let b=0;b<t.length;b++)if(n[m.id]){d.outputs.forEach(v=>n[v.id]=!0),g=!0,r[d.id]=!0;break}if(g)break}}let s={};s[a.id]=!0;let i={};for(let u=e.length-1;u>=0;u--){let d=e[u],c=d.inputs;for(let f=0;f<d.outputs.length;f++)if(s[d.outputs[f].id]){for(let m in c)s[c[m].id]=!0,i[d.id]=!0;break}}let o=[];for(let u=0;u<e.length;u++){let d=e[u];if(r[d.id]&&i[d.id]){let c={};for(let m in d.inputs){let g=d.inputs[m];n[g.id]&&(c[m]=g)}let f=Object.assign({},d);f.inputs=c,f.outputs=d.outputs,o.push(f)}}return o}function OP(e,t,a,n){for(let r=t.length-1;r>=0;r--){let s=t[r],i=[];if(s.outputs.forEach(u=>{let d=e[u.id];d!=null?i.push(d):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let u in s.inputs){if(!(u in o))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(o)}.`);let d=a(()=>o[u]());if(d.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${d.dtype}'`);let c=s.inputs[u];if(!Si(d.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${d.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=d;else{let f=e[c.id];e[c.id]=n(f,d),f.dispose()}}}}var NC=20,kf=3,rw=7;function zP(e,t,a,n){let r=jd(t),s=LP(e,t,a,r),i=t.length,o=zy(e,t,a,r,s),u=["Tensor"];return n&&(u.push(`  dtype: ${a}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map(d=>"    "+d).join(`
`)),u.join(`
`)}function LP(e,t,a,n){let r=zt(t),s=n[n.length-1],i=new Array(s).fill(0),o=t.length,u=a==="complex64"?Cf(e):e;if(o>1)for(let d=0;d<r/s;d++){let c=d*s;for(let f=0;f<s;f++)i[f]=Math.max(i[f],_f(u[c+f],0,a).length)}return i}function _f(e,t,a){let n;return Array.isArray(e)?n=`${parseFloat(e[0].toFixed(rw))} + ${parseFloat(e[1].toFixed(rw))}j`:po(e)?n=`'${e}'`:a==="bool"?n=$A(e):n=parseFloat(e.toFixed(rw)).toString(),zf(n,t)}function $A(e){return e===0?"false":"true"}function zy(e,t,a,n,r,s=!0){let i=a==="complex64"?2:1,o=t[0],u=t.length;if(u===0){if(a==="complex64"){let v=Cf(e);return[_f(v[0],0,a)]}return a==="bool"?[$A(e[0])]:[e[0].toString()]}if(u===1){if(o>NC){let v=kf*i,x=Array.from(e.slice(0,v)),k=Array.from(e.slice((o-kf)*i,o*i));return a==="complex64"&&(x=Cf(x),k=Cf(k)),["["+x.map((S,N)=>_f(S,r[N],a)).join(", ")+", ..., "+k.map((S,N)=>_f(S,r[o-kf+N],a)).join(", ")+"]"]}return["["+(a==="complex64"?Cf(e):Array.from(e)).map((v,x)=>_f(v,r[x],a)).join(", ")+"]"]}let d=t.slice(1),c=n.slice(1),f=n[0]*i,m=[];if(o>NC){for(let v=0;v<kf;v++){let x=v*f,k=x+f;m.push(...zy(e.slice(x,k),d,a,c,r,!1))}m.push("...");for(let v=o-kf;v<o;v++){let x=v*f,k=x+f;m.push(...zy(e.slice(x,k),d,a,c,r,v===o-1))}}else for(let v=0;v<o;v++){let x=v*f,k=x+f;m.push(...zy(e.slice(x,k),d,a,c,r,v===o-1))}let g=u===2?",":"";m[0]="["+(o>0?m[0]+g:"");for(let v=1;v<m.length-1;v++)m[v]=" "+m[v]+g;let b=`,
`;for(let v=2;v<u;v++)b+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":b),m}function Cf(e){let t=[];for(let a=0;a<e.length;a+=2)t.push([e[a],e[a+1]]);return t}var Aa=class{constructor(e,t,a){if(this.dtype=t,this.shape=e.slice(),this.size=zt(e),a!=null){let n=a.length;U(n===this.size,()=>`Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=a||M1(t,this.size),this.strides=jd(e)}set(e,...t){t.length===0&&(t=[0]),U(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let a=this.locToIndex(t);this.values[a]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let n of e){if(n<0||n>=this.shape[t]){let r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let a=e[e.length-1];for(let n=0;n<e.length-1;++n)a+=this.strides[n]*e[n];return this.values[a]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let a=0;a<e.length-1;++a)t+=this.strides[a]*e[a];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let a=0;a<t.length-1;++a)t[a]=Math.floor(e/this.strides[a]),e-=t[a]*this.strides[a];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return os().makeTensor(this.values,this.shape,this.dtype)}},os=null,wd=null;function BP(e){os=e}function UP(e){wd=e}var ht=class{constructor(e,t,a,n){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=zt(e),this.strides=jd(e),this.dataId=a,this.id=n,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return wd.buffer(this.shape,this.dtype,e)}bufferSync(){return wd.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Nd(this.shape,e,this.dtype==="complex64")}arraySync(){return Nd(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=os().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(a=>Zy(a))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),os().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=os().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Zy(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await os().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),os().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return wd.print(this,e)}clone(){return this.throwIfDisposed(),wd.clone(this)}toString(e=!1){let t=this.dataSync();return zP(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),wd.cast(this,e)}variable(e=!0,t,a){return this.throwIfDisposed(),os().makeVariable(this,e,t,a)}};Object.defineProperty(ht,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function be(){return z1("Tensor",()=>ht)}be();var Wl=class extends ht{constructor(e,t,a,n){super(e.shape,e.dtype,e.dataId,n),this.trainable=t,this.name=a}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Si(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);os().disposeTensor(this),this.dataId=e.dataId,os().incRef(this,null)}dispose(){os().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Wl,Symbol.hasInstance,{value:e=>e instanceof ht&&e.assign!=null&&e.assign instanceof Function});var ls={};rt(ls,{assertTypesMatch:()=>MA,getTensorsInContainer:()=>B1,isTensorInList:()=>WP,makeTypesMatch:()=>pa});var Iw;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(Iw||(Iw={}));var Nw;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(Nw||(Nw={}));var Tw;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(Tw||(Tw={}));var _w;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(_w||(_w={}));var Cw;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(Cw||(Cw={}));var PP={float32:_w,int32:Nw,bool:Tw,complex64:Cw};function Nr(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return PP[e][t]}function Ub(e){return Nr(e,"int32")}function RA(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function DA(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function pa(e,t){if(e.dtype===t.dtype)return[e,t];let a=Nr(e.dtype,t.dtype);return[e.cast(a),t.cast(a)]}function MA(e,t){U(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function WP(e,t){return t.some(a=>a.id===e.id)}function B1(e){let t=[];return FA(e,t,new Set),t}function FA(e,t,a){if(e==null)return;if(e instanceof ht){t.push(e);return}if(!VP(e))return;let n=e;for(let r in n){let s=n[r];a.has(s)||(a.add(s),FA(s,t,a))}}function VP(e){return Array.isArray(e)||typeof e=="object"}function sw(e){return e.kernelName!=null}var TC=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},U1=class Ew{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new TC}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let a=0;a<t.length;a++){let n=t[a];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:a}=this.initializeBackendsAndReturnBest();if(a)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:a}=this.initializeBackend(t);if(a)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,a,n=1){return t in this.registryFactory?(ho(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:a,priority:n},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:a,asyncInit:n}=this.initializeBackend(t);if(!(n?await a:a))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new RP(this.backendInstance),!0}setupRegisteredKernels(){Yy(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Yy(t).forEach(a=>{a.disposeFunc!=null&&a.disposeFunc(this.registry[t])})}initializeBackend(t){let a=this.registryFactory[t];if(a==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let n=a.factory();if(n&&!(n instanceof lm)&&typeof n.then=="function"){let r=++this.pendingBackendInitId,s=n.then(i=>r<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,ho(`Initialization of backend ${t} failed`),ho(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return ho(`Initialization of backend ${t} failed`),ho(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,a)=>this.registryFactory[a].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let a=0;a<t.length;a++){let n=t[a],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,a){let n=this.state.tensorInfo.get(a),r=n.backend,s=this.readSync(a),i=r.refCount(a);r.disposeData(a,!0),n.backend=t,t.move(a,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,a){let n=null;if(a==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");a=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof a!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=t}let r;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>(r=a(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,a,n){t();try{let r=n();return a(),r}catch(r){throw a(),r}}nextTensorId(){return Ew.nextTensorId++}nextVariableId(){return Ew.nextVariableId++}clone(t){let a=j.runKernel(Fu,{x:t}),n={x:t},r=i=>({x:()=>{let o="float32",u={x:i},d={dtype:o};return j.runKernel(gu,u,d)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[a],r,s,{}),a}runKernel(t,a,n){if(this.backendName==null&&this.backend,Gf(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:a,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,a,n){let r=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=r-a-s-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let a,n=[],r=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let u,d=sw(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(sw(t)){let{kernelName:b,inputs:v,attrs:x}=t;this.backendName==null&&this.backend;let k=Gf(b,this.backendName);U(k!=null,()=>`Cannot find registered kernel '${b}' for backend '${this.backendName}'`),o=()=>{let S=this.backend.numDataIds();u=k.kernelFunc({inputs:v,attrs:x,backend:this.backend});let N=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(b,S,N);let T=N.map(_=>_.rank!=null?_:this.makeTensorFromTensorInfo(_));if(r){let _=this.getTensorsForGradient(b,v,T);n=this.saveTensorsForBackwardMode(_)}return T}}else{let{forwardFunc:b}=t,v=x=>{r&&(n=x.map(k=>this.keep(this.clone(k))))};o=()=>{let x=this.backend.numDataIds();u=this.tidy(()=>b(this.backend,v));let k=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,x,k),k}}let{inputs:c,attrs:f}=t,m=sw(t)?null:t.backwardsFunc,g;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?a=o():(g=this.profiler.profileKernel(d,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(g),a=g.outputs)}),r&&this.addTapeNode(d,c,a,m,n,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(b=>c[b]!=null?c[b].shape:null),outputShapes:a.map(b=>b.shape),kernelTimeMs:g.timeMs,extraInfo:g.extraInfo}),Array.isArray(u)?a:a[0]}saveTensorsForBackwardMode(t){return t.map(a=>this.keep(this.clone(a)))}getTensorsForGradient(t,a,n){let r=kw(t);if(r!=null){let s=r.inputsToSave||[],i=r.outputsToSave||[],o;r.saveAllInputs?(U(Array.isArray(a),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(a).map(d=>a[d])):o=s.map(d=>a[d]);let u=n.filter((d,c)=>i[c]);return o.concat(u)}return[]}makeTensor(t,a,n,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=t;n==="string"&&po(t[0])&&(s=t.map(u=>Dm(u)));let i=r.write(s,a,n),o=new ht(a,n,i,this.nextTensorId());if(this.trackTensor(o,r),n==="string"){let u=this.state.tensorInfo.get(i),d=bA(s);this.state.numBytes+=d-u.bytes,u.bytes=d}return o}makeTensorFromDataId(t,a,n,r){n=n||"float32";let s={dataId:t,shape:a,dtype:n};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(t,a){let{dataId:n,shape:r,dtype:s}=t,i=new ht(r,s,n,this.nextTensorId());return this.trackTensor(i,a),i}makeVariable(t,a=!0,n,r){n=n||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));let s=new Wl(t,a,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,a){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let n=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(n=t.size*jy(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:a||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof Wl||this.track(t)}incRef(t,a){this.trackTensor(t,a),this.backend.incRef(t.dataId)}removeDataId(t,a){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===a&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let a=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=a.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let n=t.size*jy(t.dtype);this.state.numBytes-=n}a.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,a.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let a=this.state.registeredVariables[t];this.disposeVariable(a)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let a=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-a,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,a,n,r,s,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:a,outputs:n,saved:s},u=kw(t);u!=null&&(r=u.gradFunc),r!=null&&(o.gradient=d=>(d=d.map((c,f)=>{if(c==null){let m=n[f],g=Ib(m.size,m.dtype);return this.makeTensor(g,m.shape,m.dtype)}return c}),r(d.length>1?d:d[0],s,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let a={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(a.name=t),this.state.scopeStack.push(a),this.state.activeScope=a}endScope(t){let a=B1(t),n=new Set(a.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!n.has(i.id)&&i.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],a.forEach(s=>{!s.kept&&s.scopeId===r.id&&this.track(s)})}gradients(t,a,n,r=!1){if(U(a.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));U(s instanceof ht,()=>"The result y returned by f() must be a tensor.");let i=FP(this.state.activeTape,a,s);if(!r&&i.length===0&&a.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[s.id]=n??GP(s.shape),OP(o,i,d=>this.tidy(d),HP);let u=a.map(d=>o[d.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(d=>{for(let c of d.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(t){return U(xo(t),()=>"The f passed in customGrad(f) must be a function."),(...a)=>{U(a.every(o=>o instanceof ht),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,r={};a.forEach((o,u)=>{r[u]=o});let s=(o,u)=>(n=t(...a,u),U(n.value instanceof ht,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),U(xo(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),i=(o,u)=>{let d=n.gradFunc(o,u),c=Array.isArray(d)?d:[d];U(c.length===a.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),U(c.every(m=>m instanceof ht),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let f={};return c.forEach((m,g)=>{f[g]=()=>m}),f};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,a){return this.state.tensorInfo.get(t).backend.readToGPU(t,a)}async time(t){let a=Hf(),n=await this.backend.time(t);return n.wallMs=Hf()-a,n}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new TC;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};U1.nextTensorId=0;U1.nextVariableId=0;function GP(e){let t=F1(zt(e),"float32");return j.makeTensor(t,e,"float32")}function OA(){let e=SA();if(e._tfengine==null){let t=new kA(e);e._tfengine=new U1(t)}return fP(e._tfengine.ENV),BP(()=>e._tfengine),e._tfengine}var j=OA();function HP(e,t){let a={a:e,b:t};return j.runKernel(Oo,a)}var Mm={};rt(Mm,{isBrowser:()=>zA,isMobile:()=>KP,mockIsMobile:()=>jP});function qP(){return typeof navigator<"u"&&navigator!=null}var Aw;function jP(e){Aw=e}function KP(e){if(Aw!==void 0)return Aw;if(e||qP()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let a=e;return a.userAgentData&&a.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function zA(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Gn=ie();Gn.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Gn.registerFlag("IS_BROWSER",()=>zA());Gn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Gn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Gn.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Gn.registerFlag("PROD",()=>!1);Gn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Gn.getBool("DEBUG"));Gn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Gn.registerFlag("IS_TEST",()=>!1);Gn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Gn.getBool("DEBUG"));Gn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Gn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Gn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Us(e,t){let a=e;if(Ya(e))return t==="string"?[]:[e.length];if(RA(e)){let r=e.channels||"RGBA";return[e.height,e.width*r.length]}else if(DA(e))return[e.buffer.size/(t==null?4:jy(t))];if(!Array.isArray(e))return[];let n=[];for(;Array.isArray(a)||Ya(a)&&t!=="string";)n.push(a.length),a=a[0];return Array.isArray(e)&&ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&LA(e,n,[]),n}function LA(e,t,a){if(a=a||[],!Array.isArray(e)&&!Ya(e)){U(t.length===0,()=>`Element arr[${a.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}U(t.length>0,()=>`Element arr[${a.join("][")}] should be a primitive, but is an array of ${e.length} elements`),U(e.length===t[0],()=>`Element arr[${a.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let n=t.slice(1);for(let r=0;r<e.length;++r)LA(e[r],n,a.concat(r))}function _C(e,t,a,n){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${a}' passed to '${n}' must be ${e} tensor, but got ${t} tensor`)}}function O(e,t,a,n="numeric"){if(e instanceof be())return _C(n,e.dtype,t,a),e;let r=um(e);if(r!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(r=n),_C(n,r,t,a),e==null||!Ya(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${a}' must be a Tensor or TensorLike, but got '${o}'`)}let s=Us(e,r);!Ya(e)&&!Array.isArray(e)&&(e=[e]);let i=r!=="string"?Bb(e,r):wo(e,[],!0);return j.makeTensor(i,s,r)}function qf(e,t,a,n="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${a} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((r,s)=>O(r,`${t}[${s}]`,a,n))}var P1="__op";function K(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let a=t[0],n=e[a];a.endsWith("_")&&(a=a.substring(0,a.length-1)),a=a+P1;let r=(...s)=>{j.startScope(a);try{let i=n(...s);return Nb(i)&&console.error("Cannot return a Promise inside of tidy."),j.endScope(i),i}catch(i){throw j.endScope(null),i}};return Object.defineProperty(r,"name",{value:a,configurable:!0}),r}function XP(e,t){let a=O(e,"real","complex"),n=O(t,"imag","complex");$n(a.shape,n.shape,`real and imag shapes, ${a.shape} and ${n.shape}, must match in call to tf.complex().`);let r={real:a,imag:n};return j.runKernel(Tb,r)}var wi=K({complex_:XP});function Uo(e,t,a,n){if(n==null)n=um(e);else if(n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(DA(e)||RA(e)){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return j.backend.createTensorFromGPUData(e,t||a,n)}if(!Ya(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){dr(t);let r=zt(t),s=zt(a);U(r===s,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${s}`);for(let i=0;i<a.length;++i){let o=a[i],u=i===a.length-1?o!==zt(t.slice(i)):!0;U(a[i]===t[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${a}) does not match the provided shape (${t}). `)}}return!Ya(e)&&!Array.isArray(e)&&(e=[e]),t=t||a,e=n!=="string"?Bb(e,n):wo(e,[],!0),j.makeTensor(e,t,n)}function _n(e,t,a){let n=Us(e,a);return Uo(e,t,n,a)}var Vl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Ii=class BA{static join(t){return new BA(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(n=>Ya(n)?n.buffer:n),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let a=0;for(let n=0;n<t.length;n++){let r=t[n];n!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let s=a+r.byteLength;this.shards.push({buffer:r,start:a,end:s}),a=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,a=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,a=isNaN(Number(a))?0:a,t=Math.max(0,t),a=Math.min(this.byteLength,a),a<=t)return new ArrayBuffer(0);let n=this.findShardForByte(t);if(n===-1)throw new Error(`Could not find start shard for byte ${t}`);let r=a-t,s=new ArrayBuffer(r),i=new Uint8Array(s),o=0;for(let u=n;u<this.shards.length;u++){let d=this.shards[u],c=t+o-d.start,f=o,m=Math.min(a,d.end)-d.start,g=new Uint8Array(d.buffer,c,m-c);if(i.set(g,f),o+=g.length,a<d.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function a(r){return t<r.start?-1:t>=r.end?1:0}if(a(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let n=YP(this.shards,a);return n===-1?-1:(this.previousShardIndex=n,this.previousShardIndex)}};function YP(e,t){let a=0,n=e.length;for(;a<=n;){let r=Math.floor((n-a)/2)+a,s=t(e[r]);if(s===0)return r;s<0?n=r:a=r+1}return-1}function ZP(){ie().set("PROD",!0)}function QP(){ie().set("DEBUG",!0)}function JP(){ie().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function UA(e){ie().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function eW(){j.disposeVariables()}function Pr(){return j}function $w(){return j.memory()}function tW(e){return j.profile(e)}function ae(e,t){return j.tidy(e,t)}function nt(e){B1(e).forEach(t=>t.dispose())}function Ba(e){return j.keep(e)}function aW(e){return j.time(e)}function nW(e){return j.setBackend(e)}function rW(){return j.ready()}function PA(){return j.backendName}function sW(e){j.removeBackend(e)}function iW(e){return j.findBackend(e)}function oW(e){return j.findBackendFactory(e)}function Pb(e,t,a=1){return j.registerBackend(e,t,a)}function W1(){return j.backend}function lW(e,t){ie().setPlatform(e,t)}var ko=4;async function uW(e,t){let a=[],n=[],r=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<r.length;++i){let o=r[i],u=Array.isArray(e)?e[i].tensor:e[o];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${u.dtype}`);let d={name:o,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let c=new Promise(async f=>{let m=await u.bytes(),g=m.reduce((x,k)=>x+k.length,0)+ko*m.length,b=new Uint8Array(g),v=0;for(let x=0;x<m.length;x++){let k=m[x],S=new Uint8Array(new Uint32Array([k.length]).buffer);b.set(S,v),v+=ko,b.set(k,v),v+=k.length}f(b)});n.push(c)}else n.push(u.data());t!=null&&(d.group=t),a.push(d)}let s=await Promise.all(n);return{data:hW(s),specs:a}}function WA(e,t){let a=new Ii(e),n={},r=0;for(let s of t){let i=cW(s,(o,u)=>a.slice(r+o,r+u));n[s.name]=VA(s,a.slice(r,r+i)),r+=i}return n}function cW(e,t){let a=zt(e.shape),n;if("quantization"in e){let r=e.quantization;n=Vl[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<a;s++)r+=ko+new Uint32Array(t(r,r+ko))[0];return r}else n=Vl[e.dtype];return a*n}async function dW(e,t){let a=zt(e.shape),n;if("quantization"in e){let r=e.quantization;n=Vl[r.dtype]}else if(e.dtype==="string"){let r=0;for(let s=0;s<a;s++)r+=ko+new Uint32Array(await t(r,r+ko))[0];return r}else n=Vl[e.dtype];return a*n}function VA(e,t){let a=e.name,n=e.dtype,r=e.shape,s=zt(r),i,o=0;if("quantization"in e){let u=e.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${e.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(n!=="float32")throw new Error(`Weight ${e.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${n}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let d=Vl[u.dtype],c=u.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(n==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){i=new Float32Array(c.length);for(let f=0;f<c.length;f++){let m=c[f];i[f]=m*u.scale+u.min}}else if(u.dtype==="float16")i=vW()(c);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(n==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let f=0;f<c.length;f++){let m=c[f];i[f]=Math.round(m*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${n}`);o+=s*d}else if(n==="string"){let u=zt(e.shape);i=[];for(let d=0;d<u;d++){let c=new Uint32Array(t.slice(o,o+ko))[0];o+=ko;let f=new Uint8Array(t.slice(o,o+c));i.push(f),o+=c}}else{let u=Vl[n];if(n==="float32")i=new Float32Array(t);else if(n==="int32")i=new Int32Array(t);else if(n==="bool")i=new Uint8Array(t);else if(n==="complex64"){i=new Float32Array(t);let d=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let b=0;b<d.length;b++)d[b]=i[b*2],c[b]=i[b*2+1];let f=_n(d,r,"float32"),m=_n(c,r,"float32"),g=wi(f,m);return f.dispose(),m.dispose(),g}else throw new Error(`Unsupported dtype in weight '${a}': ${n}`);o+=s*u}return _n(i,r,n)}async function CC(e,t,a){let n=new Uint8Array(t);for(;n.byteLength<a;){let{done:r,value:s}=await e.read();if(r&&s==null){let o=a-n.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(n.length+s.byteLength);i.set(n,0),i.set(new Uint8Array(s),n.length),n=i}return n.buffer}async function GA(e,t){let a={},n=e.getReader(),r=new ArrayBuffer(0);for(let s of t){let i=await dW(s,async(d,c)=>(r=await CC(n,r,c),r.slice(d,c)));r=await CC(n,r,i);let o=r.slice(0,i);r=r.slice(i);let u=VA(s,o);if(a[s.name]=u,PA()==="webgpu"){let d=W1();"uploadToGPU"in d&&zt(u.shape)>=ie().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&d.uploadToGPU(u.dataId)}}return a}function hW(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,a=[];e.forEach(s=>{if(t+=s.byteLength,a.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(t),r=0;return a.forEach(s=>{n.set(new Uint8Array(s.buffer),r),r+=s.byteLength}),n.buffer}var V1=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function EC(e){return V1?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function pW(e){if(V1)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),a="";for(let n=0,r=t.length;n<r;n++)a+=String.fromCharCode(t[n]);return btoa(a)}function fW(e){if(V1){let n=Buffer.from(e,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let t=atob(e),a=new Uint8Array(t.length);for(let n=0;n<t.length;++n)a.set([t.charCodeAt(n)],n);return a.buffer}function mW(e){return Ii.join(e)}function AC(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let a=e.split(t);return a[a.length-1]}function HA(e,t){let a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(a.signature=e.signature),e.userDefinedMetadata!=null&&(a.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(a.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(a.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(a.trainingConfig=e.trainingConfig),a}function qA(e,t,a){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!a)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=t,n.weightData=a}return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),n}async function G1(e,t){let a,n;return e.weightsManifest!=null&&([a,n]=await t(e.weightsManifest)),qA(e,a,n)}function Fm(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:EC(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:EC(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Ii(e.weightData).byteLength}}function Rw(e){let t=[];for(let a of e)t.push(...a.weights);return t}function gW(){let e=a=>{let n=a<<13,r=0;for(;!(n&8388608);)r-=8388608,n<<=1;return n&=-8388609,r+=947912704,n|r},t=new Uint32Array(2048);t[0]=0;for(let a=1;a<1024;a++)t[a]=e(a);for(let a=1024;a<2048;a++)t[a]=939524096+(a-1024<<13);return t}function yW(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function bW(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function vW(){let e=gW(),t=yW(),a=bW();return n=>{let r=new ArrayBuffer(4*n.length),s=new Uint32Array(r);for(let i=0;i<n.length;i++){let o=n[i],u=e[a[o>>10]+(o&1023)]+t[o>>10];s[i]=u}return new Float32Array(r)}}var Tr=class ss{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ss.instance==null&&(ss.instance=new ss),ss.instance}static registerSaveRouter(t){ss.getInstance().saveRouters.push(t)}static registerLoadRouter(t){ss.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return ss.getHandlers(t,"save")}static getLoadHandlers(t,a){return ss.getHandlers(t,"load",a)}static getHandlers(t,a,n){let r=[];return(a==="load"?ss.getInstance().loadRouters:ss.getInstance().saveRouters).forEach(s=>{let i=s(t,n);i!==null&&r.push(i)}),r}},xW=e=>Tr.registerSaveRouter(e),wW=e=>Tr.registerLoadRouter(e),kW=e=>Tr.getSaveHandlers(e),SW=(e,t)=>Tr.getLoadHandlers(e,t),Dw="tensorflowjs",Mw=1,Rl="models_store",fo="model_info_store";function jA(){if(!ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Fw(e){let t=e.result;t.createObjectStore(Rl,{keyPath:"modelPath"}),t.createObjectStore(fo,{keyPath:"modelPath"})}var Gl=class{constructor(e){if(this.indexedDB=jA(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((a,n)=>{let r=this.indexedDB.open(Dw,Mw);r.onupgradeneeded=()=>Fw(r),r.onsuccess=()=>{let s=r.result;if(t==null){let i=s.transaction(Rl,"readonly"),o=i.objectStore(Rl).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));a(o.result.modelArtifacts)},o.onerror=u=>(s.close(),n(o.error)),i.oncomplete=()=>s.close()}else{t.weightData=Ii.join(t.weightData);let i=Fm(t),o=s.transaction(fo,"readwrite"),u=o.objectStore(fo),d;try{d=u.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(f){return n(f)}let c;d.onsuccess=()=>{c=s.transaction(Rl,"readwrite");let f=c.objectStore(Rl),m;try{m=f.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(g){return n(g)}m.onsuccess=()=>a({modelArtifactsInfo:i}),m.onerror=g=>{u=o.objectStore(fo);let b=u.delete(this.modelPath);b.onsuccess=()=>(s.close(),n(m.error)),b.onerror=v=>(s.close(),n(m.error))}},d.onerror=f=>(s.close(),n(d.error)),o.oncomplete=()=>{c==null?s.close():c.oncomplete=()=>s.close()}}},r.onerror=s=>n(r.error)})}};Gl.URL_SCHEME="indexeddb://";var KA=e=>ie().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Gl.URL_SCHEME)?IW(e.slice(Gl.URL_SCHEME.length)):null;Tr.registerSaveRouter(KA);Tr.registerLoadRouter(KA);function IW(e){return new Gl(e)}function NW(e){return e.startsWith(Gl.URL_SCHEME)?e.slice(Gl.URL_SCHEME.length):e}var TW=class{constructor(){this.indexedDB=jA()}async listModels(){return new Promise((e,t)=>{let a=this.indexedDB.open(Dw,Mw);a.onupgradeneeded=()=>Fw(a),a.onsuccess=()=>{let n=a.result,r=n.transaction(fo,"readonly"),s=r.objectStore(fo).getAll();s.onsuccess=()=>{let i={};for(let o of s.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},s.onerror=i=>(n.close(),t(s.error)),r.oncomplete=()=>n.close()},a.onerror=n=>t(a.error)})}async removeModel(e){return e=NW(e),new Promise((t,a)=>{let n=this.indexedDB.open(Dw,Mw);n.onupgradeneeded=()=>Fw(n),n.onsuccess=()=>{let r=n.result,s=r.transaction(fo,"readwrite"),i=s.objectStore(fo),o=i.get(e),u;o.onsuccess=()=>{if(o.result==null)return r.close(),a(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let d=i.delete(e),c=()=>{u=r.transaction(Rl,"readwrite");let f=u.objectStore(Rl).delete(e);f.onsuccess=()=>t(o.result.modelArtifactsInfo),f.onerror=m=>a(o.error)};d.onsuccess=c,d.onerror=f=>(c(),r.close(),a(o.error))}},o.onerror=d=>(r.close(),a(o.error)),s.oncomplete=()=>{u==null?r.close():u.oncomplete=()=>r.close()}},n.onerror=r=>a(n.error)})}},gi="/",kd="tensorflowjs_models",XA="info",_W="model_topology",CW="weight_specs",EW="weight_data",AW="model_metadata";function YA(e){return{info:[kd,e,XA].join(gi),topology:[kd,e,_W].join(gi),weightSpecs:[kd,e,CW].join(gi),weightData:[kd,e,EW].join(gi),modelMetadata:[kd,e,AW].join(gi)}}function ZA(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function $W(e){let t=e.split(gi);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(gi)}function RW(e){return e.startsWith(Hl.URL_SCHEME)?e.slice(Hl.URL_SCHEME.length):e}var Hl=class{constructor(e){if(!ie().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=YA(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),n=Fm(e),r=Ii.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(n)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,pW(r));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:n}}catch{throw ZA(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${n.modelTopologyBytes}, weightSpecsBytes=${n.weightSpecsBytes}, weightDataBytes=${n.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},a=JSON.parse(this.LS.getItem(this.keys.topology));if(a==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=a;let n=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(n==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=n;let r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){let i=JSON.parse(r);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(s==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=fW(s),t}};Hl.URL_SCHEME="localstorage://";var QA=e=>ie().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Hl.URL_SCHEME)?DW(e.slice(Hl.URL_SCHEME.length)):null;Tr.registerSaveRouter(QA);Tr.registerLoadRouter(QA);function DW(e){return new Hl(e)}var MW=class{constructor(){U(ie().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),U(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=kd+gi,a=gi+XA;for(let n=0;n<this.LS.length;++n){let r=this.LS.key(n);if(r.startsWith(t)&&r.endsWith(a)){let s=$W(r);e[s]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=RW(e);let t=YA(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let a=JSON.parse(this.LS.getItem(t.info));return ZA(t),a}},Td="://",So=class io{constructor(){this.managers={}}static getInstance(){return io.instance==null&&(io.instance=new io),io.instance}static registerManager(t,a){U(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Td)&&(t=t.slice(0,t.indexOf(Td))),U(t.length>0,()=>"scheme must not be an empty string.");let n=io.getInstance();U(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=a}static getManager(t){let a=io.getInstance().managers[t];if(a==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return a}static getSchemes(){return Object.keys(io.getInstance().managers)}};function Ly(e){if(e.indexOf(Td)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${So.getSchemes().join(",")}`);return{scheme:e.split(Td)[0],path:e.split(Td)[1]}}async function JA(e,t,a=!1){U(e!==t,()=>`Old path and new path are the same: '${e}'`);let n=Tr.getLoadHandlers(e);U(n.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),U(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${e}.`);let r=n[0],s=Tr.getSaveHandlers(t);U(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),U(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let i=s[0],o=Ly(e).scheme,u=Ly(e).path,d=o===Ly(e).scheme,c=await r.load();a&&d&&await So.getManager(o).removeModel(u);let f=await i.save(c);return a&&!d&&await So.getManager(o).removeModel(u),f.modelArtifactsInfo}async function FW(){let e=So.getSchemes(),t={};for(let a of e){let n=await So.getManager(a).listModels();for(let r in n){let s=a+Td+r;t[s]=n[r]}}return t}async function OW(e){let t=Ly(e);return So.getManager(t.scheme).removeModel(t.path)}async function zW(e,t){return JA(e,t,!1)}async function LW(e,t){return JA(e,t,!0)}var BW=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ie().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",a=>{if(a.source===window&&a.data.name===this.messageName){a.stopPropagation();let n=this.functionRefs[a.data.index];n(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return CA(e)}};if(ie().get("IS_BROWSER")){ie().setPlatform("browser",new BW);try{So.registerManager(Hl.URL_SCHEME,new MW)}catch{}try{So.registerManager(Gl.URL_SCHEME,new TW)}catch{}}var UW={importFetch:()=>DU()},iw,PW=class{constructor(){this.util=MU(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ie().global.fetch!=null?ie().global.fetch(e,t):(iw==null&&(iw=UW.importFetch()),iw(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};ie().get("IS_NODE")&&!ie().get("IS_BROWSER")&&ie().setPlatform("node",new PW);function ct(e,t="float32",a){return t=t||"float32",dr(e),new Aa(e,t,a)}function WW(e,t){let a=O(e,"x","cast");if(!yA(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&a.dtype!=="string"||t!=="string"&&a.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:a},r={dtype:t};return j.runKernel(gu,n,r)}var Te=K({cast_:WW});function VW(e){let t={x:O(e,"x","clone","string_or_numeric")};return j.runKernel(Fu,t)}var zs=K({clone_:VW});function H1(e,t=!1){console.log(e.toString(t))}OA();var GW={buffer:ct,cast:Te,clone:zs,print:H1};UP(GW);function HW(e,t){let a=O(e,"a","add"),n=O(t,"b","add");[a,n]=pa(a,n);let r={a,b:n};return j.runKernel(Oo,r)}var ge=K({add_:HW});function qW(e,t){let a=O(e,"a","floorDiv"),n=O(t,"b","floorDiv");[a,n]=pa(a,n);let r={a,b:n};return j.runKernel(Ru,r)}var Wb=K({floorDiv_:qW});function jW(e,t){let a=O(e,"a","div"),n=O(t,"b","div");if([a,n]=pa(a,n),a.dtype==="int32"&&n.dtype==="int32")return Wb(a,n);let r={a,b:n},s={};return j.runKernel(Tu,r,s)}var Fe=K({div_:jW});function KW(e,t){let a=O(e,"a","mul"),n=O(t,"b","mul");[a,n]=pa(a,n);let r={a,b:n};return j.runKernel(Zu,r)}var Z=K({mul_:KW});function XW(e){let t=O(e,"x","abs");if(t.dtype==="complex64"){let a={x:t};return j.runKernel(pm,a)}else{let a={x:t};return j.runKernel(Kd,a)}}var Ca=K({abs_:XW});function YW(e){let t={x:O(e,"x","acos")};return j.runKernel(iu,t)}var q1=K({acos_:YW});function ZW(e){let t={x:O(e,"x","acosh")};return j.runKernel(ou,t)}var j1=K({acosh_:ZW});function QW(e){U(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),U(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((r,s)=>O(r,`tensors${s}`,"addN")),a=t[0];t.forEach(r=>{if(r.dtype!==a.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(r=>{if(!Si(r.shape,a.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=t;return j.runKernel(lu,n)}var e$=K({addN_:QW});function JW(e,t=null,a=!1){let n={x:O(e,"x","all","bool")},r={axis:t,keepDims:a};return j.runKernel(Xd,n,r)}var Vb=K({all_:JW});function eV(e,t=null,a=!1){let n={x:O(e,"x","any","bool")},r={axis:t,keepDims:a};return j.runKernel(Yd,n,r)}var jf=K({any_:eV});function tV(e,t=0){let a={x:O(e,"x","argMax")},n={axis:t};return j.runKernel(Zd,a,n)}var ql=K({argMax_:tV});function aV(e,t=0){let a={x:O(e,"x","argMin")},n={axis:t};return j.runKernel(Qd,a,n)}var K1=K({argMin_:aV});function nV(e){let t={x:O(e,"x","asin")};return j.runKernel(uu,t)}var X1=K({asin_:nV});function rV(e){let t={x:O(e,"x","asinh")};return j.runKernel(cu,t)}var Y1=K({asinh_:rV});function sV(e){let t={x:O(e,"x","atan")};return j.runKernel(du,t)}var Z1=K({atan_:sV});function iV(e,t){let a=O(e,"a","atan2"),n=O(t,"b","atan2");[a,n]=pa(a,n);let r={a,b:n};return j.runKernel(pu,r)}var Q1=K({atan2_:iV});function oV(e){let t={x:O(e,"x","atanh")};return j.runKernel(hu,t)}var J1=K({atanh_:oV});function lV(e,t,a,n,r="NHWC",s){let i=e[3],o=[...t,i],u=n$(r);return Om(e,o,a,s,n,null,null,u)}function t$(e,t,a,n,r,s,i="channelsLast"){let[o,u]=Kf(t),d;if(i==="channelsLast")d=[o,u,e[3],e[3]];else if(i==="channelsFirst")d=[o,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Om(e,d,a,n,r,s,!1,i)}function uV(e,t,a,n,r,s,i="NDHWC"){let[o,u,d]=Ow(t),c,f;if(i==="NDHWC")f="channelsLast",c=[o,u,d,e[4],e[4]];else if(i==="NCDHW")f="channelsFirst",c=[o,u,d,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return a$(e,c,a,n,r,!1,f,s)}function Om(e,t,a,n,r,s,i=!1,o="channelsLast"){let[u,d,c,f]=[-1,-1,-1,-1];if(o==="channelsLast")[u,d,c,f]=e;else if(o==="channelsFirst")[u,f,d,c]=e;else throw new Error(`Unknown dataFormat ${o}`);let[m,g,,b]=t,[v,x]=Kf(a),[k,S]=Kf(n),N=_d(m,k),T=_d(g,S),{padInfo:_,outHeight:R,outWidth:M}=hV(r,d,c,v,x,N,T,s,o),F=i?b*f:b,B;return o==="channelsFirst"?B=[u,F,R,M]:o==="channelsLast"&&(B=[u,R,M,F]),{batchSize:u,dataFormat:o,inHeight:d,inWidth:c,inChannels:f,outHeight:R,outWidth:M,outChannels:F,padInfo:_,strideHeight:v,strideWidth:x,filterHeight:m,filterWidth:g,effectiveFilterHeight:N,effectiveFilterWidth:T,dilationHeight:k,dilationWidth:S,inShape:e,outShape:B,filterShape:t}}function a$(e,t,a,n,r,s=!1,i="channelsLast",o){let[u,d,c,f,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,d,c,f,m]=e;else if(i==="channelsFirst")[u,m,d,c,f]=e;else throw new Error(`Unknown dataFormat ${i}`);let[g,b,v,,x]=t,[k,S,N]=Ow(a),[T,_,R]=Ow(n),M=_d(g,T),F=_d(b,_),B=_d(v,R),{padInfo:V,outDepth:P,outHeight:A,outWidth:G}=pV(r,d,c,f,k,S,N,M,F,B,o),J=s?x*m:x,ee;return i==="channelsFirst"?ee=[u,J,P,A,G]:i==="channelsLast"&&(ee=[u,P,A,G,J]),{batchSize:u,dataFormat:i,inDepth:d,inHeight:c,inWidth:f,inChannels:m,outDepth:P,outHeight:A,outWidth:G,outChannels:J,padInfo:V,strideDepth:k,strideHeight:S,strideWidth:N,filterDepth:g,filterHeight:b,filterWidth:v,effectiveFilterDepth:M,effectiveFilterHeight:F,effectiveFilterWidth:B,dilationDepth:T,dilationHeight:_,dilationWidth:R,inShape:e,outShape:ee,filterShape:t}}function cV(e,t,a,n,r){n==null&&(n=ek(e,t,a));let s=e[0],i=e[1],o=Xf((s-t+2*n)/a+1,r),u=Xf((i-t+2*n)/a+1,r);return[o,u]}function dV(e,t,a,n,r,s){r==null&&(r=ek(e,t[0],n[0]));let i=[0,0,0,a];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(i[o]=Xf((e[o]-t[o]+2*r)/n[o]+1,s));return i}function ek(e,t,a,n=1){let r=_d(t,n);return Math.floor((e[0]*(a-1)-a+r)/2)}function Kf(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function Ow(e){return typeof e=="number"?[e,e,e]:e}function _d(e,t){return t<=1?e:e+(e-1)*(t-1)}function hV(e,t,a,n,r,s,i,o,u){let d,c,f;if(typeof e=="number"){d={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let m=cV([t,a],s,n,e,o);c=m[0],f=m[1]}else if(e==="same"){c=Math.ceil(t/n),f=Math.ceil(a/r);let m=Math.max(0,(c-1)*n+s-t),g=Math.max(0,(f-1)*r+i-a),b=Math.floor(m/2),v=m-b,x=Math.floor(g/2),k=g-x;d={top:b,bottom:v,left:x,right:k,type:"SAME"}}else if(e==="valid")d={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/n),f=Math.ceil((a-i+1)/r);else if(typeof e=="object"){let m=u==="channelsLast"?e[1][0]:e[2][0],g=u==="channelsLast"?e[1][1]:e[2][1],b=u==="channelsLast"?e[2][0]:e[3][0],v=u==="channelsLast"?e[2][1]:e[3][1];d={top:m,bottom:g,left:b,right:v,type:m===0&&g===0&&b===0&&v===0?"VALID":"EXPLICIT"},c=Xf((t-s+m+g)/n+1,o),f=Xf((a-i+b+v)/r+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outHeight:c,outWidth:f}}function pV(e,t,a,n,r,s,i,o,u,d,c){let f,m,g,b;if(e==="valid"&&(e=0),typeof e=="number"){f={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let v=dV([t,a,n,1],[o,u,d],1,[r,s,i],e,c);m=v[0],g=v[1],b=v[2]}else if(e==="same"){m=Math.ceil(t/r),g=Math.ceil(a/s),b=Math.ceil(n/i);let v=(m-1)*r+o-t,x=(g-1)*s+u-a,k=(b-1)*i+d-n,S=Math.floor(v/2),N=v-S,T=Math.floor(x/2),_=x-T,R=Math.floor(k/2),M=k-R;f={top:T,bottom:_,left:R,right:M,front:S,back:N,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:f,outDepth:m,outHeight:g,outWidth:b}}function Xf(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Io(e){let[t,a,n]=Kf(e);return t===1&&a===1&&n===1}function Gs(e,t){return Io(e)||Io(t)}function jl(e){return Kf(e).every(t=>t>0)}function n$(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Rn(e,t,a){if(a!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${a} but got pad ${t}.`);if(typeof t=="number")U(Ed(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${a} but got pad ${t}.`);else if(typeof t=="object")t.forEach(n=>{n.forEach(r=>{U(Ed(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${a} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function fV(e,t){let a={x:O(e,"x","reshape","string_or_numeric")},n={shape:t};return j.runKernel(Rh,a,n)}var te=K({reshape_:fV});function mV(e,t,a,n,r){let s=O(e,"x","avgPool","float32"),i=1;U(Gs(a,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${i}'`);let o=s,u=!1;s.rank===3&&(u=!0,o=te(s,[1,s.shape[0],s.shape[1],s.shape[2]])),U(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Rn("avgPool",n,r);let d={x:o},c={filterSize:t,strides:a,pad:n,dimRoundingMode:r},f=j.runKernel(fu,d,c);return f=Te(f,s.dtype),u?te(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Ni=K({avgPool_:mV});function gV(e,t,a,n,r,s="NDHWC"){let i=O(e,"x","avgPool3d","float32"),o=i,u=!1;i.rank===4&&(u=!0,o=te(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),U(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),U(typeof a=="number"&&a>0||Array.isArray(a)&&a[0]>0&&a[1]>0&&a[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${a}'`),Rn("avgPool3d",n,r);let d={x:o},c={filterSize:t,strides:a,pad:n,dimRoundingMode:r,dataFormat:s},f=j.runKernel(Jd,d,c);return f=Te(f,o.dtype),u?te(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var tk=K({avgPool3d_:gV});function yV(e,t=0){U(e.length>=1,()=>"Pass at least one tensor to concat");let a=qf(e,"tensors","concat","string_or_numeric");if(a[0].dtype==="complex64"&&a.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),a.length===1)return zs(a[0]);let n=a,r={axis:t};return j.runKernel(nh,n,r)}var Gt=K({concat_:yV});function bV(e,t,a=!1,n=!1){let r=O(e,"a","matMul"),s=O(t,"b","matMul");[r,s]=pa(r,s);let i={a:r,b:s},o={transposeA:a,transposeB:n};return j.runKernel(mu,i,o)}var lt=K({matMul_:bV});function vV(e){let t={x:O(e,"x","sigmoid","float32")};return j.runKernel(mc,t)}var Vr=K({sigmoid_:vV});function xV(e,t,a){let n=O(e,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let r={x:n},s={begin:t,size:a};return j.runKernel(Bh,r,s)}var bt=K({slice_:xV});function wV(e){let t={x:O(e,"x","tanh","float32")};return j.runKernel(Sc,t)}var No=K({tanh_:wV});function kV(e,t,a,n,r,s){let i=O(e,"forgetBias","basicLSTMCell"),o=O(t,"lstmKernel","basicLSTMCell"),u=O(a,"lstmBias","basicLSTMCell"),d=O(n,"data","basicLSTMCell"),c=O(r,"c","basicLSTMCell"),f=O(s,"h","basicLSTMCell"),m=Gt([d,f],1),g=lt(m,o),b=ge(g,u),v=b.shape[0],x=b.shape[1]/4,k=[v,x],S=bt(b,[0,0],k),N=bt(b,[0,x],k),T=bt(b,[0,x*2],k),_=bt(b,[0,x*3],k),R=ge(Z(Vr(S),No(N)),Z(c,Vr(ge(i,T)))),M=Z(No(R),Vr(_));return[R,M]}var r$=K({basicLSTMCell_:kV});function SV(e,t,a){let n=O(e,"x","batchToSpaceND"),r=t.reduce((o,u)=>o*u);U(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),U(a.length===t.length,()=>`crops.length is ${a.length} but should be equal to blockShape.length  ${t.length}`),U(n.shape[0]%r===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);let s={x:n},i={blockShape:t,crops:a};return j.runKernel(eh,s,i)}var zm=K({batchToSpaceND_:SV});function IV(e){let t;return e.rank===0||e.rank===1?t=te(e,[1,1,1,e.size]):e.rank===2?t=te(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=te(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function NV(e,t,a,n,r,s){s==null&&(s=.001);let i=O(e,"x","batchNorm"),o=O(t,"mean","batchNorm"),u=O(a,"variance","batchNorm"),d;r!=null&&(d=O(r,"scale","batchNorm"));let c;n!=null&&(c=O(n,"offset","batchNorm")),U(o.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),U(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),U(d==null||o.rank===d.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let f={x:IV(i),scale:d,offset:c,mean:o,variance:u},m={varianceEpsilon:s},g=j.runKernel(Du,f,m);return te(g,i.shape)}var Ic=K({batchNorm_:NV});function TV(e,t,a,n,r,s){let i=O(e,"x","batchNorm"),o=O(t,"mean","batchNorm"),u=O(a,"variance","batchNorm"),d;r!=null&&(d=O(r,"scale","batchNorm"));let c;return n!=null&&(c=O(n,"offset","batchNorm")),U(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),U(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),U(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),d!=null&&U(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${d.rank}.`),c!=null&&U(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),Ic(i,o,u,c,d,s)}var ak=K({batchNorm2d_:TV});function _V(e,t,a,n,r,s){let i=O(e,"x","batchNorm"),o=O(t,"mean","batchNorm"),u=O(a,"variance","batchNorm"),d;r!=null&&(d=O(r,"scale","batchNorm"));let c;return n!=null&&(c=O(n,"offset","batchNorm")),U(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),U(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),U(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),d!=null&&U(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${d.rank}.`),c!=null&&U(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),Ic(i,o,u,c,d,s)}var nk=K({batchNorm3d_:_V});function CV(e,t,a,n,r,s){let i=O(e,"x","batchNorm"),o=O(t,"mean","batchNorm"),u=O(a,"variance","batchNorm"),d;r!=null&&(d=O(r,"scale","batchNorm"));let c;return n!=null&&(c=O(n,"offset","batchNorm")),U(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),U(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),U(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),d!=null&&U(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${d.rank}.`),c!=null&&U(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),Ic(i,o,u,c,d,s)}var rk=K({batchNorm4d_:CV});function EV(e,t,a){let n=O(e,"x","bincount"),r=O(t,"weights","bincount");U(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),U(a>=0,()=>`size must be non-negative, but got ${a}.`),U(r.size===n.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${r.shape}.`);let s={x:n,weights:r},i={size:a};return j.runKernel(th,s,i)}var sk=K({bincount_:EV});function AV(e,t){let a=O(e,"x","bitwiseAnd"),n=O(t,"y","bitwiseAnd");if(!Si(a.shape,n.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${a.shape}, y: ${n.shape}`);if(a.dtype!=="int32"||n.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${a.dtype} and type of y: ${n.dtype}`);let r={a,b:n};return j.runKernel(ah,r)}var s$=K({bitwiseAnd_:AV});function $V(e,t){let a=O(e,"s0","broadcastArgs","int32"),n=O(t,"s1","broadcastArgs","int32");if(a.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${a.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let r={s0:a,s1:n};return j.runKernel(hm,r)}var i$=K({broadcastArgs_:$V});function RV(e,t){let a=O(e,"broadcastTo","x"),n=a.shape;if(dr(t),t.length<a.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${a.rank}.`);if(t.length>a.rank){let u=a.shape.slice();for(;u.length<t.length;)u.unshift(1);a=te(a,u)}let r=a.shape,s=Array.from(t);for(let u=t.length-1;u>=0;u--)if(r[u]===t[u])s[u]=1;else if(a.shape[u]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(s.map((u,d)=>u>1?d:-1).filter(u=>u>=0).length===0)return zs(a);let i={x:a},o={reps:s};return j.runKernel(Lo,i,o)}var Ml=K({broadcastTo_:RV});function DV(e){let t={x:O(e,"x","ceil","float32")};return j.runKernel(yu,t)}var ik=K({ceil_:DV});function ir(e,t,a){dr(e),a=a||um(t);let n={shape:e,value:t,dtype:a};return j.runKernel(gm,{},n)}function MV(e,t,a){let n=O(e,"x","clipByValue");if(U(t<=a,()=>`Error in clip: min (${t}) must be less than or equal to max (${a}).`),t===a)return ir(n.shape,t,n.dtype);let r={x:n},s={clipValueMin:t,clipValueMax:a};return j.runKernel(zo,r,s)}var yn=K({clipByValue_:MV});function FV(e){return Gt(e,0)}var ok=K({concat1d_:FV});function OV(e,t){return Gt(e,t)}var lk=K({concat2d_:OV});function zV(e,t){return Gt(e,t)}var uk=K({concat3d_:zV});function LV(e,t){return Gt(e,t)}var ck=K({concat4d_:LV});function BV(e,t,a,n,r="NHWC",s=[1,1],i){let o=O(e,"x","conv2d","float32"),u=O(t,"filter","conv2d","float32"),d=o,c=!1;o.rank===3&&(c=!0,d=te(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(d.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${d.rank}.`),U(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Rn("conv2d",n,i);let f=r==="NHWC"?d.shape[3]:d.shape[1];U(f===u.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${u.shape[2]}.`),U(Gs(a,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`),U(jl(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),U(jl(a),()=>"Error in conv2D: Strides should be larger than 0.");let m={x:d,filter:u},g={strides:a,pad:n,dataFormat:r,dilations:s,dimRoundingMode:i},b=j.runKernel(bu,m,g);return c?te(b,[b.shape[1],b.shape[2],b.shape[3]]):b}var Cn=K({conv2d_:BV});function UV(e,t,a,n,r="NWC",s=1,i){let o=O(e,"x","conv1d"),u=O(t,"filter","conv1d"),d=o,c=!1;o.rank===2&&(c=!0,d=te(o,[1,o.shape[0],o.shape[1]])),U(d.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${d.rank}.`),U(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Rn("conv1d",n,i),U(d.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${d.shape[2]}) must match input depth for filter ${u.shape[1]}.`),U(Gs(a,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${a} and dilation '${s}'`),U(jl(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),U(jl(a),()=>"Error in conv1D: Stride should be larger than 0."),U(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);let f=te(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=te(d,[d.shape[0],1,d.shape[1],d.shape[2]]),g=Cn(m,f,[1,a],n,"NHWC",[1,s],i);return c?te(g,[g.shape[2],g.shape[3]]):te(g,[g.shape[0],g.shape[2],g.shape[3]])}var Gb=K({conv1d_:UV});function PV(e,t,a,n,r,s="NHWC",i){U(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,u=t,d=!1;t.rank===3&&(d=!0,u=te(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),U(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),U(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),U(a.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${a.rank}`);let c=s==="NHWC"?o[3]:o[1],f=s==="NHWC"?u.shape[3]:u.shape[1];U(c===a.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${a.shape[2]}.`),U(f===a.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${a.shape[3]}.`),Rn("conv2dDerInput",r,i);let m={dy:u,filter:a},g={strides:n,pad:r,dataFormat:s,dimRoundingMode:i,inputShape:o},b=j.runKernel(vu,m,g);return d?te(b,[b.shape[1],b.shape[2],b.shape[3]]):b}var dk=K({conv2DBackpropInput_:PV});function WV(e,t,a,n,r,s){let i=O(e,"x","conv2dTranspose"),o=O(t,"filter","conv2dTranspose");return dk(a,i,o,n,r,"NHWC",s)}var Hb=K({conv2dTranspose_:WV});function VV(e,t,a,n,r="NDHWC",s=[1,1,1]){let i=O(e,"x","conv3d"),o=O(t,"filter","conv3d"),u=i,d=!1;i.rank===4&&(d=!0,u=te(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),U(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),U(u.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`),U(Gs(a,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`),U(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),U(jl(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),U(jl(a),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:u,filter:o},f={strides:a,pad:n,dataFormat:r,dilations:s},m=j.runKernel(xu,c,f);return d?te(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var hk=K({conv3d_:VV});function GV(e,t,a,n,r){U(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let s=e,i=t,o=!1;t.rank===4&&(o=!0,i=te(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let u=s[4],d=i.shape[4];U(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),U(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),U(a.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${a.rank}`),U(u===a.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${a.shape[3]}.`),U(d===a.shape[4],()=>`Error in conv3dDerInput: depth of output (${d}) must match output depth for filter ${a.shape[4]}.`);let c={dy:i,filter:a},f={pad:r,strides:n,inputShape:s},m=j.runKernel(sh,c,f);return o?te(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var o$=K({conv3DBackpropInput_:GV});function HV(e,t,a,n,r){let s=O(e,"x","conv3dTranspose"),i=O(t,"filter","conv3dTranspose");return o$(a,s,i,n,r)}var pk=K({conv3dTranspose_:HV});function qV(e){let t={x:O(e,"x","cos","float32")};return j.runKernel(wu,t)}var Lm=K({cos_:qV});function jV(e){let t={x:O(e,"x","cosh","float32")};return j.runKernel(ku,t)}var qb=K({cosh_:jV});function KV(e,t=0,a=!1,n=!1){let r={x:O(e,"x","cumprod")},s={axis:t,exclusive:a,reverse:n};return j.runKernel(ih,r,s)}var Yf=K({cumprod_:KV});function XV(e,t=0,a=!1,n=!1){let r={x:O(e,"x","cumsum")},s={axis:t,exclusive:a,reverse:n};return j.runKernel(Su,r,s)}var jb=K({cumsum_:XV});function YV(e,t,a,n=!1){let r=O(e,"x","denseBincount"),s=O(t,"weights","denseBincount");U(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),U(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),U(a>=0,()=>`size must be non-negative, but got ${a}.`),U(s.size===r.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${s.shape}.`);let i={x:r,weights:s},o={size:a,binaryOutput:n};return j.runKernel(fm,i,o)}var Qy=K({denseBincount_:YV});function ZV(e,t,a="NHWC"){let n=O(e,"x","depthToSpace","float32"),r=a==="NHWC"?n.shape[1]:n.shape[2],s=a==="NHWC"?n.shape[2]:n.shape[3],i=a==="NHWC"?n.shape[3]:n.shape[1];U(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),U(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${n.shape}`),U(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${n.shape}`),U(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${n.shape}`);let o={x:n},u={blockSize:t,dataFormat:a};return j.runKernel(lh,o,u)}var fk=K({depthToSpace_:ZV});function QV(e,t,a,n,r="NHWC",s=[1,1],i){let o=O(e,"x","depthwiseConv2d","float32"),u=O(t,"filter","depthwiseConv2d","float32"),d=o,c=!1;o.rank===3&&(c=!0,d=te(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(d.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),U(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let f=r==="NHWC"?d.shape[3]:d.shape[1];U(f===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${u.shape[2]}.`),Rn("depthwiseConv2d",n,i);let m={x:d,filter:u},g={strides:a,pad:n,dataFormat:r,dilations:s,dimRoundingMode:i},b=j.runKernel(Iu,m,g);return c?te(b,[b.shape[1],b.shape[2],b.shape[3]]):b}var Nc=K({depthwiseConv2d_:QV});function JV(e){let t={x:O(e,"x","diag")};return j.runKernel(mm,t)}var l$=K({diag_:JV});function eG(e,t,a,n,r=[1,1],s="NHWC"){let i=O(e,"x","dilation2d"),o=O(t,"filter","dilation2d");U(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),U(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),U(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=i,d=!1;i.rank===3&&(u=te(i,[1,i.shape[0],i.shape[1],i.shape[2]]),d=!0),U(u.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`);let c={x:u,filter:o},f={strides:a,pad:n,dilations:r},m=j.runKernel(Nu,c,f);return d?te(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var mk=K({dilation2d_:eG}),Yh={};rt(Yh,{assertAndGetBroadcastShape:()=>Ht,getBroadcastDims:()=>u$,getReductionAxes:()=>Ra});function u$(e,t){let a=e.length,n=[];for(let r=0;r<a;r++){let s=a-1-r,i=e[s]||1;(t[t.length-1-r]||1)>1&&i===1&&n.unshift(s)}return n}function Ra(e,t){let a=[];for(let n=0;n<t.length;n++){let r=e[e.length-n-1],s=t.length-n-1,i=t[s];(r==null||r===1&&i>1)&&a.unshift(s)}return a}function Ht(e,t){let a=Math.max(e.length,t.length),n=new Array(a);for(let r=0;r<a;r++){let s=e[e.length-r-1];s==null&&(s=1);let i=t[t.length-r-1];if(i==null&&(i=1),s===1)n[a-r-1]=i;else if(i===1)n[a-r-1]=s;else if(s!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else n[a-r-1]=s}return n}function tG(e,t){let a=O(e,"a","equal","string_or_numeric"),n=O(t,"b","equal","string_or_numeric");[a,n]=pa(a,n),Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(ch,r)}var or=K({equal_:tG});function aG(e,t,a){let n=O(t,"a","where"),r=O(a,"b","where"),s=O(e,"condition","where","bool"),i=Ht(Ht(s.shape,n.shape),r.shape),o=Ml(s,i),u=Ml(n,i),d=Ml(r,i),c={condition:o,t:u,e:d};return j.runKernel(Lh,c)}var Ja=K({where_:aG});function nG(e){let t={x:O(e,"x","zerosLike")};return j.runKernel(Kh,t)}var St=K({zerosLike_:nG});function rG(e,t){let a=O(e,"a","div"),n=O(t,"b","div");[a,n]=pa(a,n);let r=Fe(a,n),s=St(r),i=or(n,s);return Ja(i,s,r)}var gk=K({divNoNan_:rG});function sG(e,t){let a=O(e,"t1","dot"),n=O(t,"t2","dot");U((a.rank===1||a.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${a.rank} and ${n.rank}.`);let r=a.rank===1?a.size:a.shape[1],s=n.rank===1?n.size:n.shape[0];if(U(r===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${s}.`),a.rank===1&&n.rank===1){let i=te(a,[1,-1]),o=te(n,[-1,1]),u=lt(i,o);return te(u,[])}else if(a.rank===1&&n.rank===2){let i=te(a,[1,-1]),o=te(n,[n.shape[0],n.shape[1]]),u=lt(i,o);return te(u,[u.size])}else if(a.rank===2&&n.rank===1){let i=te(n,[-1,1]),o=lt(a,i);return te(o,[o.size])}else{let i=te(n,[n.shape[0],n.shape[1]]);return lt(a,i)}}var yk=K({dot_:sG});function iG(e,...t){let a=t.map((r,s)=>O(r,`tensors${s}`,"einsum")),n={equation:e};return j.runKernel($b,a,n)}var Cl=K({einsum_:iG});function oG(e){let t={x:O(e,"x","elu","float32")};return j.runKernel(_u,t)}var Zh=K({elu_:oG});function lG(e,t){let a=O(e,"x","ensureShape","string_or_numeric");if(!pA(a.shape,t))throw new Error(`EnsureShape: Shape of tensor ${a.shape} is not compatible with expected shape ${t}`);return e}var c$=K({ensureShape_:lG});function uG(e){let t=O(e,"x","erf");U(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Te(t,"float32"));let a={x:t};return j.runKernel(Cu,a)}var Kb=K({erf_:uG});function bk(e,t){for(let a=0;a<e.length;++a)if(e[e.length-a-1]!==t-1-a)return!1;return!0}function d$(e,t,a){let n=e.length+t.length,r=[],s=0,i=0;for(let o=0;o<n;o++)a.indexOf(o)===-1?r.push(e[s++]):r.push(t[i++]);return r}function h$(e,t){let a=[],n=e.length;for(let s=0;s<n;s++)t.indexOf(s)===-1&&a.push(e[s]);let r=t.map(s=>e[s]);return[a,r]}function Kl(e,t){let a=t.map(n=>1);return d$(e,a,t)}function cG(e,t,a){U(bk(t,a),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${a} input.`)}function p$(e,t){if(bk(e,t))return null;let a=[];for(let n=0;n<t;++n)e.indexOf(n)===-1&&a.push(n);return e.forEach(n=>a.push(n)),a}function vk(e){return e.map((t,a)=>[a,t]).sort((t,a)=>t[1]-a[1]).map(t=>t[0])}function dG(e,t){let a=[];for(let n=t-e;n<t;++n)a.push(n);return a}function hG(e,t=null,a=!1){let n={x:O(e,"x","max")},r={reductionIndices:t,keepDims:a};return j.runKernel(Vu,n,r)}var Ir=K({max_:hG});function pG(e,t=null,a=!1){let n={x:O(e,"x","min")},r={axis:t,keepDims:a};return j.runKernel(ju,n,r)}var Dd=K({min_:pG});function fG(e,t){let a=O(e,"base","pow"),n=O(t,"exp","pow");[a,n]=pa(a,n);let r={a,b:n};return j.runKernel(ec,r)}var Ps=K({pow_:fG});function We(e,t){if((Ya(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Ya(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Uo(e,[],[],t)}function mG(e){let t={x:O(e,"x","sqrt","float32")};return j.runKernel(yc,t)}var en=K({sqrt_:mG});function gG(e){let t=O(e,"x","square"),a={};return j.runKernel("Square",{x:t},a)}var Vt=K({square_:gG});function yG(e,t=null,a=!1){let n=O(e,"x","sum");n.dtype==="bool"&&(n=Te(n,"int32"));let r={x:n},s={axis:t,keepDims:a};return j.runKernel(bc,r,s)}var ze=K({sum_:yG});function bG(e,t="euclidean",a=null,n=!1){e=O(e,"x","norm");let r=f$(e,t,a),s=r.shape;if(n){let i=qr(a,e.shape);s=Kl(r.shape,i)}return te(r,s)}function f$(e,t,a=null){if(e.rank===0)return Ca(e);if(e.rank!==1&&a===null)return f$(te(e,[-1]),t,a);if(e.rank===1||typeof a=="number"||Array.isArray(a)&&a.length===1){if(t===1)return ze(Ca(e),a);if(t===1/0)return Ir(Ca(e),a);if(t===-1/0)return Dd(Ca(e),a);if(t==="euclidean"||t===2)return en(ze(Ps(Ca(e),We(2,"int32")),a));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(a)&&a.length===2){if(t===1)return Ir(ze(Ca(e),a[0]),a[1]-1);if(t===1/0)return Ir(ze(Ca(e),a[1]),a[0]);if(t===-1/0)return Dd(ze(Ca(e),a[1]),a[0]);if(t==="fro"||t==="euclidean")return en(ze(Vt(e),a));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${a}`)}var Qh=K({norm_:bG});function vG(e,t=null,a=!1){return Qh(e,"euclidean",t,a)}var xk=K({euclideanNorm_:vG});function xG(e){let t={x:O(e,"x","exp")};return j.runKernel(Eu,t)}var bn=K({exp_:xG});function wG(e,t=0){let a=O(e,"x","expandDims","string_or_numeric");U(t<=a.rank,()=>"Axis must be <= rank of the tensor");let n={input:a},r={dim:t};return j.runKernel(dh,n,r)}var Za=K({expandDims_:wG});function kG(e){let t={x:O(e,"x","expm1")};return j.runKernel(Au,t)}var wk=K({expm1_:kG});function SG(e,t){let a=O(e,"x","tile","string_or_numeric");U(a.rank===t.length,()=>`Error in transpose: rank of input ${a.rank} must match length of reps ${t}.`);let n={x:a},r={reps:t};return j.runKernel(Lo,n,r)}var sr=K({tile_:SG});function IG(e,t,a,n="float32"){t==null&&(t=e);let r=ct([e,t],n),s=e<=t?e:t;for(let o=0;o<s;++o)r.set(1,o,o);let i=te(r.toTensor(),[e,t]);if(a==null)return i;if(a.length===1)return sr(Za(i,0),[a[0],1,1]);if(a.length===2)return sr(Za(Za(i,0),0),[a[0],a[1],1,1]);if(a.length===3)return sr(Za(Za(Za(i,0),0),0),[a[0],a[1],a[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${a.length}D.`)}var Xb=K({eye_:IG});function NG(e){let t={x:O(e,"x","floor","float32")};return j.runKernel($u,t)}var Jh=K({floor_:NG});function TG(e,t,a=0,n=0){let r=O(e,"x","gather"),s=O(t,"indices","gather","int32"),i={x:r,indices:s},o={axis:a,batchDims:n};return j.runKernel(ph,i,o)}var ep=K({gather_:TG});function _G(e,t){let a=O(e,"a","greater","string_or_numeric"),n=O(t,"b","greater","string_or_numeric");[a,n]=pa(a,n),Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(mh,r)}var Dn=K({greater_:_G});function CG(e,t){let a=O(e,"a","greaterEqual","string_or_numeric"),n=O(t,"b","greaterEqual","string_or_numeric");[a,n]=pa(a,n),Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(Mu,r)}var Ti=K({greaterEqual_:CG});function EG(e){let t={input:O(e,"input","imag")};return j.runKernel(Mb,t)}var Bm=K({imag_:EG});function AG(e){let t={x:O(e,"x","isFinite")};return j.runKernel(Ou,t)}var kk=K({isFinite_:AG});function $G(e){let t={x:O(e,"x","isInf")};return j.runKernel(zu,t)}var Sk=K({isInf_:$G});function RG(e){let t={x:O(e,"x","isNaN")};return j.runKernel(Lu,t)}var Ik=K({isNaN_:RG});function DG(e,t=.2){let a={x:O(e,"x","leakyRelu")},n={alpha:t};return j.runKernel(Bu,a,n)}var Um=K({leakyRelu_:DG});function MG(e,t){let a=O(e,"a","less","string_or_numeric"),n=O(t,"b","less","string_or_numeric");[a,n]=pa(a,n),Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(gh,r)}var Md=K({less_:MG});function FG(e,t){let a=O(e,"a","lessEqual","string_or_numeric"),n=O(t,"b","lessEqual","string_or_numeric");[a,n]=pa(a,n),Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(yh,r)}var Po=K({lessEqual_:FG});function m$(e,t,a){if(a<=0)throw new Error("The number of values should be positive.");let n={start:e,stop:t,num:a};return j.runKernel(bh,{},n)}function OG(e,t=5,a=1,n=1,r=.5){let s=O(e,"x","localResponseNormalization");U(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),U(Ed(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=s,o=!1;s.rank===3&&(o=!0,i=te(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:i},d={depthRadius:t,bias:a,alpha:n,beta:r},c=j.runKernel(Wu,u,d);return o?te(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Nk=K({localResponseNormalization_:OG});function zG(e){let t={x:O(e,"x","log","float32")};return j.runKernel(Uu,t)}var lr=K({log_:zG});function LG(e){let t={x:O(e,"x","log1p")};return j.runKernel(Pu,t)}var Pm=K({log1p_:LG});function BG(e){return U(xo(e),()=>"The f passed in grad(f) must be a function"),(t,a)=>{let n=O(t,"x","tf.grad","string_or_numeric"),r=a!=null?O(a,"dy","tf.grad"):null;return j.tidy(()=>{let{value:s,grads:i}=j.gradients(()=>e(n),[n],r);return r!=null&&$n(s.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Yb(i),i[0]})}}function UG(e){return U(xo(e),()=>"The f passed in grads(f) must be a function"),(t,a)=>{U(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=qf(t,"args","tf.grads","string_or_numeric"),r=a!=null?O(a,"dy","tf.grads"):null;return j.tidy(()=>{let{value:s,grads:i}=j.gradients(()=>e(...n),n,r);return r!=null&&$n(s.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Yb(i),i})}}function PG(e){return U(xo(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,a)=>{U(t instanceof ht,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),U(a==null||a instanceof ht,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:r}=j.gradients(()=>e(t),[t],a);return Yb(n),{grad:n[0],value:r}}}function WG(e){return U(xo(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,a)=>{U(Array.isArray(t)&&t.every(r=>r instanceof ht),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),U(a==null||a instanceof ht,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=j.gradients(()=>e(...t),t,a);return a!=null&&$n(n.value.shape,a.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Yb(n.grads),n}}function g$(e,t){U(xo(e),()=>"The f passed in variableGrads(f) must be a function"),U(t==null||Array.isArray(t)&&t.every(d=>d instanceof Wl),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let a=t!=null;if(!a){t=[];for(let d in j.registeredVariables)t.push(j.registeredVariables[d])}let n=a?t.filter(d=>!d.trainable):null,r=t.length;t=t.filter(d=>d.trainable),U(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);let s=!0,{value:i,grads:o}=j.gradients(e,t,null,s);U(o.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),U(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let u={};return t.forEach((d,c)=>{o[c]!=null&&(u[d.name]=o[c])}),n!=null&&n.forEach(d=>u[d.name]=null),{value:i,grads:u}}function Ws(e){return j.customGrad(e)}function Yb(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function VG(e){let t={x:O(e,"x","neg")};return j.runKernel(Nh,t)}var ta=K({neg_:VG});function GG(e){let t={x:O(e,"x","softplus")};return j.runKernel(gc,t)}var Tc=K({softplus_:GG});function HG(e){let t=O(e,"x","logSigmoid");return Ws(a=>({value:ta(Tc(ta(a))),gradFunc:n=>Z(n,Vr(ta(a)))}))(t)}var Tk=K({logSigmoid_:HG});function qG(e,t){let a=O(e,"a","sub"),n=O(t,"b","sub");[a,n]=pa(a,n);let r={a,b:n};return j.runKernel(wc,r)}var $e=K({sub_:qG});function jG(e,t=-1){let a=O(e,"logits","logSoftmax");if(t===-1&&(t=a.rank-1),t!==a.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${a.rank} and axis was ${t}`);return Ws((n,r)=>{let s=Ir(n,t,!0),i=$e(n,s),o=$e(Te(i,"float32"),lr(ze(bn(i),t,!0)));return r([o]),{value:o,gradFunc:(u,d)=>{let[c]=d,f=!0,m=bn(c);return $e(u,Z(ze(u,t,f),m))}}})(a)}var Zb=K({logSoftmax_:jG});function KG(e,t=null,a=!1){let n=O(e,"x","logSumExp"),r=qr(t,n.shape),s=Ir(n,r,!0),i=$e(n,s),o=bn(i),u=ze(o,r),d=lr(u),c=ge(te(s,d.shape),d);if(a){let f=Kl(c.shape,r);return te(c,f)}return c}var Wm=K({logSumExp_:KG});function XG(e,t){let a=O(e,"a","logicalAnd","bool"),n=O(t,"b","logicalAnd","bool");Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(vh,r)}var Gr=K({logicalAnd_:XG});function YG(e){let t={x:O(e,"x","logicalNot","bool")};return j.runKernel(xh,t)}var Vm=K({logicalNot_:YG});function ZG(e,t){let a=O(e,"a","logicalOr","bool"),n=O(t,"b","logicalOr","bool");Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(wh,r)}var Qb=K({logicalOr_:ZG});function QG(e,t){let a=O(e,"a","logicalXor","bool"),n=O(t,"b","logicalXor","bool");return Ht(a.shape,n.shape),Gr(Qb(e,t),Vm(Gr(e,t)))}var _k=K({logicalXor_:QG}),wy=2147483648;function JG(e,t,a="left"){let n=O(e,"sortedSequence","searchSorted"),r=O(t,"values","searchSorted"),s=n.shape[n.shape.length-1],i=r.shape[r.shape.length-1],o=te(n,[-1,s]),u=te(r,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(zt(u.shape)>=wy)throw new Error(`values tensor size must less than ${wy}`);if(o.shape[1]>=wy)throw new Error(`trailing dim_size must less than ${wy} for int32 output type, was ${o.shape[1]}`);let d={sortedSequence:o,values:u},c={side:a};return j.runKernel(zh,d,c)}var Jb=K({searchSorted_:JG});function y$(e,t){return Jb(e,t,"left")}function eH(e,t,a,n,r){let s=O(e,"x","maxPool"),i=1,o=s,u=!1;s.rank===3&&(u=!0,o=te(s,[1,s.shape[0],s.shape[1],s.shape[2]])),U(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),U(Gs(a,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${i}'`),Rn("maxPool",n,r);let d={x:o},c={filterSize:t,strides:a,pad:n,dimRoundingMode:r},f=j.runKernel(Hu,d,c);return u?te(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Ka=K({maxPool_:eH});function tH(e,t=[1,1,1],a,n,r,s="NDHWC"){let i=O(e,"x","maxPool3d"),o=i,u=!1;i.rank===4&&(u=!0,o=te(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),U(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),U(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Rn("maxPool3d",n,r);let d={x:o},c={filterSize:t,strides:a,pad:n,dimRoundingMode:r,dataFormat:s},f=j.runKernel(Sh,d,c);return u?te(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var Ck=K({maxPool3d_:tH});function aH(e,t,a,n,r=!1){let s={x:O(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:a,pad:n,includeBatchInIndex:r},o=j.runKernel(vm,s,i);return{result:o[0],indexes:o[1]}}var b$=K({maxPoolWithArgmax_:aH});function nH(e,t){let a=O(e,"a","maximum"),n=O(t,"b","maximum");[a,n]=pa(a,n),a.dtype==="bool"&&(a=Te(a,"int32"),n=Te(n,"int32")),Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(Gu,r)}var Hs=K({maximum_:nH});function rH(e,t=null,a=!1){let n={x:O(e,"x","mean")},r={axis:t,keepDims:a};return j.runKernel(qu,n,r)}var ca=K({mean_:rH});function da(e,t="float32"){if(dr(e),t==="complex64"){let n=da(e,"float32"),r=da(e,"float32");return wi(n,r)}let a=Ib(zt(e),t);return j.makeTensor(a,e,t)}function Pn(e,t="float32"){if(dr(e),t==="complex64"){let n=Pn(e,"float32"),r=da(e,"float32");return wi(n,r)}let a=F1(zt(e),t);return j.makeTensor(a,e,t)}function v$(e,t,{indexing:a="xy"}={}){if(a!=="xy"&&a!=="ij")throw new TypeError(`${a} is not a valid third argument to meshgrid`);if(e===void 0)return[];let n=O(e,"x","meshgrid",e instanceof ht?e.dtype:"float32");if(t===void 0)return[n];let r=O(t,"y","meshgrid",t instanceof ht?t.dtype:"float32"),s=zt(n.shape),i=zt(r.shape);return a==="xy"?(n=te(n,[1,-1]),r=te(r,[-1,1]),[lt(Pn([i,1],n.dtype),n),lt(r,Pn([1,s],r.dtype))]):(n=te(n,[-1,1]),r=te(r,[1,-1]),[lt(n,Pn([1,i],n.dtype)),lt(Pn([s,1],r.dtype),r)])}function sH(e,t){let a=O(e,"a","minimum"),n=O(t,"b","minimum");[a,n]=pa(a,n),a.dtype==="bool"&&(a=Te(a,"int32"),n=Te(n,"int32")),Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(Ku,r)}var To=K({minimum_:sH});function iH(e,t,a){U(a==="reflect"||a==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${a}.`);let n=O(e,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");U(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let r=a==="reflect"?1:0;for(let o=0;o<n.rank;o++)U(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),U(t[o][0]>=0&&t[o][0]<=n.shape[o]-r&&t[o][1]>=0&&t[o][1]<=n.shape[o]-r,()=>`Padding in dimension ${o} cannot be greater than or equal to ${n.shape[o]-r} or less than 0 for input of shape ${n.shape}`);let s={paddings:t,mode:a},i={x:n};return j.runKernel(Xu,i,s)}var Ek=K({mirrorPad_:iH});function oH(e,t){let a=O(e,"a","mod"),n=O(t,"b","mod");[a,n]=pa(a,n);let r={a,b:n};return j.runKernel(Yu,r)}var Ak=K({mod_:oH});function lH(e,t=null,a=!1){e=O(e,"x","moments");let n=qr(t,e.shape),r=ca(e,n,a),s=r.shape;a||(s=Kl(r.shape,n));let i=Vt($e(Te(e,"float32"),te(r,s))),o=ca(i,n,a);return{mean:r,variance:o}}var Gm=K({moments_:lH});function uH(e,t,a,n){let r=O(t,"data","multiRNNCell"),s=qf(a,"c","multiRNNCell"),i=qf(n,"h","multiRNNCell"),o=r,u=[];for(let f=0;f<e.length;f++){let m=e[f](o,s[f],i[f]);u.push(m[0]),u.push(m[1]),o=m[1]}let d=[],c=[];for(let f=0;f<u.length;f+=2)d.push(u[f]),c.push(u[f+1]);return[d,c]}var x$=K({multiRNNCell_:uH});function cH(e,t,a,n=!1){let r=O(e,"logits","multinomial"),s=r.size,i=r.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);a=a||Math.random();let o={logits:i===1?te(r,[1,-1]):r},u={numSamples:t,seed:a,normalized:n},d=j.runKernel(Ih,o,u);return i===1?te(d,[d.size]):d}var w$=K({multinomial_:cH});function dH(e,t){let a=O(e,"a","notEqual","string_or_numeric"),n=O(t,"b","notEqual","string_or_numeric");[a,n]=pa(a,n),Ht(a.shape,n.shape);let r={a,b:n};return j.runKernel(Th,r)}var Xl=K({notEqual_:dH});function hH(e,t,a=1,n=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let s={indices:O(e,"indices","oneHot","int32")},i={dtype:r,depth:t,onValue:a,offValue:n};return j.runKernel(Qu,s,i)}var Fd=K({oneHot_:hH});function pH(e){let t={x:O(e,"x","onesLike")};return j.runKernel(Ah,t)}var ur=K({onesLike_:pH});function fH(e,t){let a=O(e,"v1","outerProduct"),n=O(t,"v2","outerProduct");U(a.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${a.rank} and ${n.rank}.`);let r=te(a,[-1,1]),s=te(n,[1,-1]);return lt(r,s)}var k$=K({outerProduct_:fH});function mH(e,t,a=0){let n=O(e,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let r={paddings:t,constantValue:a},s={x:n};return j.runKernel(Ju,s,r)}var ms=K({pad_:mH});function gH(e,t,a=0){return U(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),ms(e,[t],a)}var S$=K({pad1d_:gH});function yH(e,t,a=0){return U(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ms(e,t,a)}var I$=K({pad2d_:yH});function bH(e,t,a=0){return U(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ms(e,t,a)}var N$=K({pad3d_:bH});function vH(e,t,a=0){return U(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ms(e,t,a)}var T$=K({pad4d_:vH});function xH(e,t,a){let n=O(e,"x","spaceToBatchND");U(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),U(a.length===t.length,()=>`paddings.shape[0] ${a.length} must be equal to [blockShape] ${t.length}`),U(n.shape.reduce((i,o,u)=>u>0&&u<=t.length?i&&(o+a[u-1][0]+a[u-1][1])%t[u-1]===0:i,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${a.toString()} must be divisible by blockShapes ${t.toString()}`);let r={x:n},s={blockShape:t,paddings:a};return j.runKernel(Uh,r,s)}var Hm=K({spaceToBatchND_:xH});function wH(e,t,a,n,r,s,i){r==null&&(r=[1,1]),s==null&&(s=1),n===0&&(n="valid");let o=O(e,"x","maxPool"),u=o,d=!1;o.rank===3&&(d=!0,u=te(o,[1,o.shape[0],o.shape[1],o.shape[2]])),U(Gs(s,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${r}'`);let c=t$(u.shape,t,s,r,n),f=[c.dilationHeight,c.dilationWidth],m;n==="same"?m=SH([c.filterHeight,c.filterWidth],f):m=[[0,0],[0,0]];let g=f[0]===1&&f[1]===1,[b,v]=kH([c.inHeight,c.inWidth],f,m),x=g?n:"valid",k=g?u:Hm(u,f,b),S=(a==="avg"?()=>Ni(k,t,s,x,i):()=>Ka(k,t,s,x,i))(),N=g?S:zm(S,f,v);return d?te(N,[N.shape[1],N.shape[2],N.shape[3]]):N}function kH(e,t,a){let n=a.map(c=>c[0]),r=a.map(c=>c[1]),s=e.concat(n,r),i=t.map((c,f)=>(c-s[f]%c)%c),o=r.map((c,f)=>c+i[f]),u=t.map((c,f)=>[n[f],o[f]]),d=t.map((c,f)=>[0,i[f]]);return[u,d]}function SH(e,t){let a=e.map((s,i)=>s+(s-1)*(t[i]-1)).map(s=>s-1),n=a.map(s=>Math.floor(s/2)),r=a.map((s,i)=>s-n[i]);return a.map((s,i)=>[n[i],r[i]])}var $k=K({pool_:wH});function IH(e,t){let a=O(e,"x","prelu"),n=O(t,"alpha","prelu"),r={x:a,alpha:n};return j.runKernel(tc,r)}var qm=K({prelu_:IH});function NH(e,t=null,a=!1){let n=O(e,"x","prod");n.dtype==="bool"&&(n=Te(n,"int32"));let r={x:n},s={axis:t,keepDims:a};return j.runKernel(ac,r,s)}var Rk=K({prod_:NH});function TH(e,t,a,n){let r=e.map((c,f)=>O(c,`tensors${f}`,"raggedGather","int32")),s=O(t,"paramsDenseValues","raggedGather"),i=O(a,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:s,indices:i},u={outputRaggedRank:n},d=j.runKernel(Fb,o,u);return{outputNestedSplits:d.slice(0,d.length-1),outputDenseValues:d[d.length-1]}}var _$=K({raggedGather_:TH});function _H(e,t,a){let n=O(e,"starts","raggedRange"),r=O(t,"limits","raggedRange",n.dtype),s=O(a,"deltas","raggedRange",n.dtype),i={starts:n,limits:r,deltas:s},o=j.runKernel(Ob,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var C$=K({raggedRange_:_H});function CH(e,t,a,n,r){let s=O(e,"shape","raggedTensorToTensor","int32"),i=O(t,"values","raggedTensorToTensor"),o=O(a,"defaultValue","raggedTensorToTensor",i.dtype),u=n.map((f,m)=>O(f,`tensors${m}`,"raggedTensorToTensor","int32")),d={shape:s,values:i,defaultValue:o,rowPartitionTensors:u},c={rowPartitionTypes:r};return j.runKernel(zb,d,c)}var E$=K({raggedTensorToTensor_:CH});function EH(e,t,a){dr(e);let n=zt(e),r=null;if(a==null||a==="float32")r=new Float32Array(n);else if(a==="int32")r=new Int32Array(n);else if(a==="bool")r=new Uint8Array(n);else throw new Error(`Unknown data type ${a}`);for(let s=0;s<n;s++)r[s]=t();return j.makeTensor(r,e,a)}var A$=K({rand_:EH}),Dk=Fo(kb()),$$={};rt($$,{TEST_EPSILON_FLOAT16:()=>R$,createVideoElement:()=>zH,encodeStrings:()=>D$,expectArrayBuffersEqual:()=>OH,expectArraysClose:()=>$H,expectArraysEqual:()=>DH,expectNumbersClose:()=>MH,expectPromiseToFail:()=>RH,expectValuesInRange:()=>FH,play:()=>LH,testEpsilon:()=>Mk});var AH=.001,R$=.1;function $H(e,t,a){return a==null&&(a=Mk()),zw(e,t,(n,r)=>Fk(n,r,a))}function Mk(){return j.backend.floatPrecision()===32?AH:R$}function zw(e,t,a){let n=!0;if((Ya(e)||Ya(t))&&(n=!1),Ya(e)&&Ya(t)&&(n=!0),n){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=Us(e),o=Us(t);if(!Si(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let r=Ya(e)?e:wo(e),s=Ya(t)?t:wo(t);if(r.length!==s.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${s.length}.
Actual:   ${r}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let o=r[i],u=s[i];if(!a(o,u))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${u}.
Actual:   ${r}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function RH(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function DH(e,t){let a=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return po(e)||po(e[0])||po(t)||po(t[0])?zw(e,a,(n,r)=>n==r):zw(e,t,(n,r)=>Fk(n,r,0))}function MH(e,t,a){if(a==null&&(a=Mk()),!Fk(e,t,a))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function Fk(e,t,a){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>a)}function FH(e,t,a){for(let n=0;n<e.length;n++)if(e[n]<t||e[n]>a)throw new Error(`Value out of range:${e[n]} low: ${t}, high: ${a}`)}function OH(e,t){let a=new Float32Array(e),n=new Float32Array(t);if(a.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${a.length}`);for(let r=0;r<n.length;r++)if(a[r]!==n[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${n[r]} but got ${a[r]} instead`)}function D$(e){for(let t=0;t<e.length;t++){let a=e[t];Array.isArray(a)?D$(a):e[t]=Dm(a)}return e}function zH(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(a=>{t.addEventListener("loadeddata",n=>a(t)),t.load()})}async function LH(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var Ok=class{constructor(e,t,a,n,r){this.mean=e,this.stdDev=t,this.dtype=a,this.nextVal=NaN,this.truncated=n,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let s=r||Math.random();this.random=Dk.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let n=this.nextVal;return this.nextVal=NaN,n}let e,t,a=!1;for(;!a;){let n,r,s;do n=2*this.random()-1,r=2*this.random()-1,s=n*n+r*r;while(s>=1||s===0);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*n*i,t=this.mean+this.stdDev*r*i,(!this.truncated||this.isValidTruncated(e))&&(a=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},BH=class{constructor(e,t,a,n){this.alpha=e,this.beta=1/t,this.dtype=a;let r=n||Math.random();this.randu=Dk.alea(r.toString()),this.randn=new Ok(0,1,a,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,a,n,r,s;for(;;){do n=this.randn.nextValue(),s=1+this.c*n;while(s<=0);if(s*=s*s,e=n*n,t=1-.331*e*e,a=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<a)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},UH=class{constructor(e=0,t=1,a,n){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=a,n==null&&(n=Math.random()),typeof n=="number"&&(n=n.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Dk.alea(n)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function PH(e,t,a=1,n="float32",r){if(dr(e),a==null&&(a=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new BH(t,a,n,r),i=ct(e,n);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var M$=K({randomGamma_:PH});function WH(e,t=0,a=1,n,r){if(dr(e),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new Ok(t,a,n,!1,r),i=ct(e,n);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var ev=K({randomNormal_:WH});function VH(e,t,a){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return ev(e,0,1,t,a)}var F$=K({randomStandardNormal_:VH});function GH(e,t=0,a=1,n="float32",r){dr(e);let s=ct(e,n),i=new UH(t,a,null,r);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var Wo=K({randomUniform_:GH});function HH(e,t,a,n){return Wo(e,t,a,"int32",n)}var O$=K({randomUniformInt_:HH});function Yl(e,t,a=1,n="float32"){if(a===0)throw new Error("Cannot have a step of zero");let r={start:e,stop:t,step:a,dtype:n};return j.runKernel(xm,{},r)}function qH(e){let t={input:O(e,"input","real")};return j.runKernel(Lb,t)}var Od=K({real_:qH});function jH(e){let t={x:O(e,"x","reciprocal")};return j.runKernel(nc,t)}var zk=K({reciprocal_:jH});function KH(e){let t={x:O(e,"x","relu")};return j.runKernel(rc,t)}var Ot=K({relu_:KH});function XH(e){let t={x:O(e,"x","relu6")};return j.runKernel(oc,t)}var tv=K({relu6_:XH});function YH(e,t){let a={x:O(e,"x","reverse")},n={dims:t};return j.runKernel(lc,a,n)}var _r=K({reverse_:YH});function ZH(e){let t=O(e,"x","reverse");return U(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),_r(t,0)}var z$=K({reverse1d_:ZH});function QH(e,t){let a=O(e,"x","reverse");return U(a.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${a.rank}.`),_r(a,t)}var L$=K({reverse2d_:QH});function JH(e,t){let a=O(e,"x","reverse");return U(a.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${a.rank}.`),_r(a,t)}var B$=K({reverse3d_:JH});function e6(e,t){let a=O(e,"x","reverse");return U(a.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${a.rank}.`),_r(a,t)}var U$=K({reverse4d_:e6});function t6(e){let t={x:O(e,"x","round")};return j.runKernel(uc,t)}var av=K({round_:t6});function a6(e){let t={x:O(e,"x","rsqrt","float32")};return j.runKernel(cc,t)}var nv=K({rsqrt_:a6});function n6(e){let t={x:O(e,"x","selu")};return j.runKernel(dc,t)}var rv=K({selu_:n6});function r6(e,t,a,n,r,s=[1,1],i="NHWC"){let o=O(e,"x","separableConv2d"),u=O(t,"depthwiseFilter","separableConv2d"),d=O(a,"pointwiseFilter","separableConv2d"),c=o,f=!1;if(o.rank===3&&(f=!0,c=te(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");U(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),U(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),U(d.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),U(d.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${d.shape[0]}.`),U(d.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${d.shape[1]}.`);let m=u.shape[2],g=u.shape[3];U(d.shape[2]===m*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*g}, but got ${d.shape[2]}.`);let b=Nc(c,u,n,r,i,s),v=Cn(b,d,1,"valid",i);return f?te(v,[v.shape[1],v.shape[2],v.shape[3]]):v}var tp=K({separableConv2d_:r6});async function s6(e,t){let a=O(e,"x","setdiff1d"),n=O(t,"y","setdiff1d");U(a.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${a.dtype}) and y (${n.dtype}).`),U(a.rank===1,()=>`x should be 1D tensor, but got x (${a.shape}).`),U(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let r=await a.data(),s=await n.data(),i=new Set(s),o=0;for(let c=0;c<r.length;c++)i.has(r[c])||o++;let u=new Aa([o],a.dtype),d=new Aa([o],"int32");for(let c=0,f=0;c<r.length;c++)i.has(r[c])||(u.values[f]=r[c],d.values[f]=c,f++);return[u.toTensor(),d.toTensor()]}var P$=s6;function i6(e){let t={x:O(e,"x","sign")};return j.runKernel(fc,t)}var Lk=K({sign_:i6});function o6(e){let t={x:O(e,"x","sin","float32")};return j.runKernel(hc,t)}var sv=K({sin_:o6});function l6(e){let t={x:O(e,"x","sinh")};return j.runKernel(pc,t)}var iv=K({sinh_:l6});function u6(e,t,a){let n=O(e,"x","slice1d");return U(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),bt(n,[t],[a])}var jm=K({slice1d_:u6});function c6(e,t,a){let n=O(e,"x","slice2d");return U(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),bt(n,t,a)}var ov=K({slice2d_:c6});function d6(e,t,a){let n=O(e,"x","slice3d");return U(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),bt(n,t,a)}var ap=K({slice3d_:d6});function h6(e,t,a){let n=O(e,"x","slice4d");return U(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),bt(n,t,a)}var zd=K({slice4d_:h6});function p6(e,t=-1){let a=O(e,"logits","softmax","float32");if(t===-1&&(t=a.rank-1),t!==a.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a.rank} and dim was ${t}`);let n={logits:a},r={dim:t};return j.runKernel(vc,n,r)}var Vo=K({softmax_:p6});function f6(e){U(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return j.runKernel(Rb,t)}var Km=K({fft_:f6});function m6(e){U(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return j.runKernel(Db,t)}var Ld=K({ifft_:m6});function g6(e){let t=e.shape[e.shape.length-1],a=e.size/t,n;if(t<=2){let r=te(e,[a,t]);n=Ld(r)}else{let r=[a,2*(t-1)],s=te(Od(e),[a,t]),i=te(Bm(e),[a,t]),o=_r(bt(s,[0,1],[a,t-2]),1),u=Z(_r(bt(i,[0,1],[a,t-2]),1),We(-1)),d=Gt([s,o],1),c=Gt([i,u],1),f=te(wi(d,c),[r[0],r[1]]);n=Ld(f)}if(n=Od(n),e.rank===3&&e.shape[0]!==0){let r=n,s=e.shape[0];n=te(n,[s,n.shape[0]/s,n.shape[1]]),r.dispose()}return n}var lv=K({irfft_:g6});function y6(e,t,a=0){let n={x:O(e,"x","split")},r={numOrSizeSplits:t,axis:a};return j.runKernel(Ph,n,r)}var Wn=K({split_:y6});function b6(e,t){U(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let a=e.shape[e.shape.length-1],n=e.size/a,r;if(t!=null&&t<a){let b=e.shape.map(x=>0),v=e.shape.map(x=>x);v[e.shape.length-1]=t,r=bt(e,b,v),a=t}else if(t!=null&&t>a){let b=e.shape.map(v=>v);b[e.shape.length-1]=t-a,r=Gt([e,da(b)],e.shape.length-1),a=t}else r=e;let s=St(r),i=te(wi(r,s),[n,a]),o=Km(i),u=Math.floor(a/2)+1,d=Od(o),c=Bm(o),f=Wn(d,[u,a-u],d.shape.length-1),m=Wn(c,[u,a-u],c.shape.length-1),g=r.shape.slice();return g[r.shape.length-1]=u,te(wi(f[0],m[0]),g)}var Xm=K({rfft_:b6});function v6(e,t){let a=O(e,"a","squaredDifference"),n=O(t,"b","squaredDifference");[a,n]=pa(a,n),Ht(a.shape,n.shape);let r={a,b:n},s={};return j.runKernel(xc,r,s)}var uv=K({squaredDifference_:v6});function x6(e,t){let a=O(e,"x","squeeze","string_or_numeric");return te(a,fA(a.shape,t).newShape)}var Go=K({squeeze_:x6});function w6(e,t=0){let a=qf(e,"tensors","stack","string_or_numeric");U(a.length>=1,()=>"Pass at least one tensor to tf.stack"),a.length>0&&U(t<=a[0].rank,()=>"Axis must be <= rank of the tensor");let n=a,r={axis:t};return j.runKernel($h,n,r)}var $a=K({stack_:w6});function k6(e,t=0){let a={x:O(e,"x","step")},n={alpha:t};return j.runKernel(Bo,a,n)}var _c=K({step_:k6});function S6(e,t,a,n,r=0,s=0,i=0,o=0,u=0){let d={x:O(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:a,strides:n,beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};return j.runKernel(Gh,d,c)}var Bk=K({stridedSlice_:S6});function I6(e){let t={x:O(e,"x","tan","float32")};return j.runKernel(kc,t)}var Uk=K({tan_:I6});function Mt(e,t){su(e);let a=Us(e,t);if(a.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Uo(e,null,a,t)}function Ls(e,t,a){if(su(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Us(e,a);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Uo(e,t,n,a)}function cv(e,t,a){if(su(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Us(e,a);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Uo(e,t,n,a)}function _o(e,t,a){if(su(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Us(e,a);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Uo(e,t,n,a)}function W$(e,t,a){if(su(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Us(e,a);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Uo(e,t,n,a)}function V$(e,t,a){if(su(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Us(e,a);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||n,Uo(e,t,n,a)}var dv={};rt(dv,{calculateShapes:()=>G$,validateInput:()=>hv,validateUpdateShape:()=>Pk});function Pk(e,t,a){let n=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${a.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${n}, and batchDim: ${r}.`;if(a.rank<r)throw new Error(s+` update.rank < ${r}. `);if(e.length<n+(a.rank-r))throw new Error(s+` Output shape length < ${n+(a.rank-r)}`);if(a.rank!==r+e.length-n)throw new Error(s+` update.rank != ${r+e.length-n}`);for(let i=0;i<r;++i)if(a.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${a.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<a.rank-r;++i)if(a.shape[i+r]!==e[i+n])throw new Error(s+` updates.shape[${i+r}] (${a.shape[i+r]}) != shape[${i+r}] (${e[i+r]})`)}function hv(e,t,a){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(a.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${a}`);if(a.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Pk(a,t,e)}function G$(e,t,a){let n=t.shape.length,r=n>1?t.shape[n-1]:1,s=a.length,i=1;for(let f=r;f<s;++f)i*=a[f];let o=r<1?1:r,u=zt(t.shape)/o,d=[...jd(a.slice(0,r)),1],c=zt(a);return{sliceRank:r,numUpdates:u,sliceSize:i,strides:d,outputSize:c}}function N6(e,t,a){let n=O(e,"tensor","tensorScatterupdate"),r=O(t,"indices","tensorScatterupdate","int32"),s=O(a,"updates","tensorScatterupdate");if(hv(s,r,n.shape),n.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${n.dtype} and ${s.dtype}.`);let i={tensor:n,indices:r,updates:s},o={};return j.runKernel(Oh,i,o)}var H$=K({tensorScatterUpdate_:N6});function T6(e,t=1,a=!0){let n=O(e,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let r=n.shape[n.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);let s={x:n},i={k:t,sorted:a},[o,u]=j.runKernel(Hh,s,i);return{values:o,indices:u}}var Wk=K({topk_:T6});function _6(e,t=0,a=1,n,r){if(dr(e),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new Ok(t,a,n,!0,r),i=ct(e,n);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var pv=K({truncatedNormal_:_6});function C6(e,t=0){let a=O(e,"x","unique","string_or_numeric");U(a.rank>0,()=>"The input tensor must be at least 1D");let n={x:a},r={axis:t},[s,i]=j.runKernel(Em,n,r);return{values:s,indices:i}}var Vk=K({unique_:C6});function E6(e,t,a){let n=O(e,"x","unsortedSegmentSum"),r=O(t,"segmentIds","unsortedSegmentSum","int32");U(Ed(a),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:r},i={numSegments:a};return j.runKernel(Am,s,i)}var fv=K({unsortedSegmentSum_:E6});function A6(e,t=0){let a=O(e,"x","unstack","string_or_numeric");U(t>=-a.shape.length&&t<a.shape.length,()=>`Axis = ${t} is not in [-${a.shape.length}, ${a.shape.length})`);let n={value:a},r={axis:t};return j.runKernel(jh,n,r)}var ya=K({unstack_:A6});function q$(e,t){return Jb(e,t,"right")}function Gk(e,t=!0,a,n){return j.makeVariable(e,t,a,n)}function j$(e,t){let a=[];for(let s=0;s<t.length;s++)t[s]&&a.push(s);let n=ct(e,"int32"),r=ct([a.length,e.length],"int32");for(let s=0;s<a.length;s++){let i=n.indexToLoc(a[s]),o=s*e.length;r.values.set(i,o)}return r.toTensor()}async function $6(e){let t=O(e,"condition","whereAsync","bool"),a=await t.data(),n=j$(t.shape,a);return e!==t&&t.dispose(),n}var Hk=$6;async function R6(e,t,a){let n=O(e,"tensor","boolMask"),r=O(t,"mask","boolMask","bool"),s=a??0,i=r.rank,o=n.shape;U(i>0,()=>"mask cannot be scalar"),$n(o.slice(s,s+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let v=s;v<s+i;v++)u*=o[v];let d=o.slice(0,s).concat([u],o.slice(s+i)),c=te(n,d),f=te(r,[-1]),m=await Hk(f),g=Go(m,[1]),b=ep(c,g,s);return e!==n&&n.dispose(),t!==r&&r.dispose(),g.dispose(),c.dispose(),f.dispose(),m.dispose(),b}var K$=R6;function D6(e,t,a){let n=O(e,"x","transpose");if(t==null&&(t=n.shape.map((i,o)=>o).reverse()),U(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(i=>{U(i>=0&&i<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();let r={x:n},s={perm:t};return n.dtype==="complex64"?ae(()=>{let i=Od(n),o=Bm(n);return i=j.runKernel(yi,{x:i},s),o=j.runKernel(yi,{x:o},s),a&&(o=ta(o)),wi(i,o)}):j.runKernel(yi,r,s)}var ut=K({transpose_:D6});function M6(e,t,a,n,r=!0){let s=O(e,"v","movingAverage"),i=O(t,"x","movingAverage"),o=O(a,"decay","movingAverage");MA(s,i),U(Si(s.shape,i.shape),()=>"Shape mismatch in v and x");let u=We(1),d=$e(u,o),c=Z($e(i,s),d);if(r){U(n!=null,()=>"When using zeroDebias: true, step is required.");let f=O(n,"step","movingAverage");c=Fe(c,$e(u,Ps(o,f)))}return ge(s,c)}var X$=K({movingAverage_:M6});function F6(e,t,a){dr(a);let n=O(e,"indices","scatterND","int32"),r=O(t,"updates","scatterND");hv(r,n,a);let s={indices:n,updates:r},i={shape:a};return j.runKernel(Fh,s,i)}var Y$=K({scatterND_:F6});function O6(e,t,a,n){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(a.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${a.length}, should be: ${s}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`);if(t.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function z6(e,t,a,n=0){dr(a);let r=O(e,"sparseIndices","sparseToDense","int32"),s=O(t,"sparseValues","sparseToDense","string_or_numeric"),i=O(n,"defaultValue","sparseToDense",s.dtype);O6(r,s,a,i);let o={sparseIndices:r,sparseValues:s,defaultValue:i},u={outputShape:a};return j.runKernel(Vh,o,u)}var Z$=K({sparseToDense_:z6});function L6(e,t){let a=O(t,"indices","gatherND","int32"),n={params:O(e,"x","gatherND","string_or_numeric"),indices:a};return j.runKernel(fh,n)}var Q$=K({gatherND_:L6});function B6(e,t){if(t==null)return e.shape.slice();if(Si(e.shape,t))return t;if(e.shape.length===t.length){let a=[];for(let n=0;n<e.shape.length;n++)t[n]==null&&e.shape[n]!=null?a.push(e.shape[n]):a.push(t[n]);return a}return t}function U6(e,t,a,n){let r=O(e,"x","dropout");if(U(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),U(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof ht?r.clone():r;let s=B6(r,a),i=1-t,o=Fe(Jh(ge(Wo(s,0,1,"float32",n),i)),i);return Z(r,o)}var qk=K({dropout_:U6});function jk(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function mv(e,t,a){let n=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+n-1);r[s]=t-a*Math.cos(i)}return Mt(r,"float32")}async function P6(e,t,a=1){let n=O(e,"predictions","inTopK"),r=O(t,"targets","inTopK");U(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),U(n.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${r.rank}`),$n(n.shape.slice(0,n.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];U(a>0&&a<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${a}`);let i=await n.data(),o=await r.data(),[u,d]=[i.length/s,s],c=mA("bool",u);for(let f=0;f<u;f++){let m=f*d,g=i.subarray(m,m+d),b=[];for(let v=0;v<g.length;v++)b.push({value:g[v],index:v});b.sort((v,x)=>x.value-v.value),c[f]=0;for(let v=0;v<a;v++)if(b[v].index===o[f]){c[f]=1;break}}return e!==n&&n.dispose(),t!==r&&r.dispose(),_n(c,r.shape,"bool")}var J$=P6,Bd={};rt(Bd,{conv2d:()=>G6,depthwiseConv2d:()=>K6,matMul:()=>Y6});function W6(e,t,a,n,r,s="NHWC",i){let o=e;e.rank===3&&(o=te(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=te(t,[1,t.shape[0],t.shape[1],t.shape[2]])),U(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),U(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),U(a.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${a}.`);let d=s==="NHWC"?o.shape[3]:o.shape[1],c=s==="NHWC"?u.shape[3]:u.shape[1];U(d===a[2],()=>`Error in conv2dDerFilter: depth of input ${d}) must match input depth in filter (${a[2]}.`),U(c===a[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${a[3]}).`),Rn("conv2dDerFilter",r,i);let f={x:o,dy:u},m={strides:n,pad:r,dataFormat:s,dimRoundingMode:i,filterShape:a};return j.runKernel(_b,f,m)}var Kk=K({conv2DBackpropFilter_:W6});function gv(e,t,a){if(a==null||a==="linear")return e;if(a==="relu")return Z(e,_c(t));throw new Error(`Cannot compute gradient for fused activation ${a}.`)}function yv(e,t){let a=t,n=Ra(e.shape,t.shape);return n.length>0&&(a=ze(a,n)),te(a,e.shape)}function bv(e,t,a,n){if(t==="linear")return e;if(t==="relu")return Ot(e);if(t==="elu")return Zh(e);if(t==="relu6")return tv(e);if(t==="prelu")return qm(e,a);if(t==="leakyrelu")return Um(e,n);if(t==="sigmoid")return Vr(e);throw new Error(`Unknown fused activation ${t}.`)}var vv=(e,t)=>!(e>0)||t==="linear";function V6({x:e,filter:t,strides:a,pad:n,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:c}){if(u=u||"linear",vv(j.state.gradientDepth,u)===!1){U(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let R=Cn(e,t,a,n,r,s,i);return o!=null&&(R=ge(R,o)),bv(R,u,d,c)}let f=O(e,"x","conv2d","float32"),m=O(t,"filter","conv2d","float32"),g=f,b=!1;f.rank===3&&(b=!0,g=te(f,[1,f.shape[0],f.shape[1],f.shape[2]])),U(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),U(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Rn("fused conv2d",n,i);let v=r==="NHWC"?g.shape[3]:g.shape[1];U(m.shape[2]===v,()=>`Error in conv2d: depth of input (${v}) must match input depth for filter ${m.shape[2]}.`),U(Gs(a,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);let x=Om(g.shape,m.shape,a,s,n,i),k;o!=null&&(k=O(o,"bias","fused conv2d"),[k]=pa(k,f),r==="NHWC"?Ht(x.outShape,k.shape):(U(k.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${k.shape.length}.`),U(k.shape.length===0||k.shape[0]===x.outChannels||k.shape[0]===1,()=>`Error in fused conv2d: bias shape (${k.shape}) is not compatible with the number of output channels (${x.outChannels})`)));let S;if(d!=null){let R=d.shape;if(U(R.length<=1||R.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${R.length}.`),R.length===1)U(R[0]===1||R[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${R}) is not compatible with the number of output channels (${x.outChannels}).`);else if(R.length===3)try{Ht(R,x.outShape)}catch{let F=`Error in fused conv2d: PReLU activation weights (${R}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error(F)}S=O(d,"prelu weights","fused conv2d")}let N=(R,M)=>{U(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);let[F,B,V,P]=M,A=gv(R,V,u);U(Io(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let G=dk(B.shape,A,F,a,n),J=Kk(B,A,F.shape,a,n),ee=[G,J];if(P!=null){let W=yv(P,A);ee.push(W)}return ee},T={x:g,filter:m,bias:k,preluActivationWeights:S},_={strides:a,pad:n,dataFormat:r,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return o==null?Ws((R,M,F)=>{let B=j.runKernel(Ul,T,_);return F([M,R,B]),b&&(B=te(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:N}})(g,m):Ws((R,M,F,B)=>{let V=j.runKernel(Ul,T,_);return B([M,R,V,F]),b&&(V=te(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:N}})(g,m,k)}var G6=K({fusedConv2d_:V6});function H6(e,t,a,n,r,s=[1,1],i){let o=e;e.rank===3&&(o=te(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;u.rank===3&&(u=te(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d={x:o,dy:u},c={strides:n,pad:r,dimRoundingMode:i,dilations:s,filterShape:a};return j.runKernel(Cb,d,c)}var eR=K({depthwiseConv2dNativeBackpropFilter_:H6});function q6(e,t,a,n,r,s=[1,1],i){let o=t,u=!1;t.rank===3&&(u=!0,o=te(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let d={dy:o,filter:a},c={strides:n,pad:r,dimRoundingMode:i,dilations:s,inputShape:e},f=j.runKernel(Eb,d,c);return u?te(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var tR=K({depthwiseConv2dNativeBackpropInput_:q6});function j6({x:e,filter:t,strides:a,pad:n,dataFormat:r="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:u="linear",preluActivationWeights:d,leakyreluAlpha:c}){if(vv(j.state.gradientDepth,u)===!1){let _=Nc(e,t,a,n,r,s,i);return o!=null&&(_=ge(_,o)),bv(_,u,d,c)}let f=O(e,"x","depthwiseConv2d","float32"),m=O(t,"filter","depthwiseConv2d","float32"),g=f,b=!1;f.rank===3&&(b=!0,g=te(f,[1,f.shape[0],f.shape[1],f.shape[2]])),U(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),U(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),U(g.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),U(Gs(a,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`),Rn("fused depthwiseConv2d",n,i);let v=Om(g.shape,m.shape,a,s,n,i,!0),x;o!=null&&(x=O(o,"bias","fused conv2d"),[x]=pa(x,f),Ht(v.outShape,x.shape));let k;d!=null&&(k=O(d,"prelu weights","fused depthwiseConv2d"));let S=(_,R)=>{U(Io(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[M,F,B,V]=R,P=gv(_,B,u),A=tR(F.shape,P,M,a,n,s,i),G=eR(F,P,M.shape,a,n,s,i);if(V!=null){let J=yv(x,P);return[A,G,J]}return[A,G]},N={x:g,filter:m,bias:x,preluActivationWeights:k},T={strides:a,pad:n,dataFormat:r,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return o==null?Ws((_,R,M)=>{let F=j.runKernel(Pl,N,T);return M([R,_,F]),b&&(F=te(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:S}})(g,m):Ws((_,R,M,F)=>{let B=j.runKernel(Pl,N,T);return F([R,_,B,M]),b&&(B=te(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:S}})(g,m,x)}var K6=K({fusedDepthwiseConv2d_:j6});function X6({a:e,b:t,transposeA:a=!1,transposeB:n=!1,bias:r,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(vv(j.state.gradientDepth,s)===!1){let V=lt(e,t,a,n);return r!=null&&(V=ge(V,r)),bv(V,s,i,o)}let u=O(e,"a","fused matMul"),d=O(t,"b","fused matMul");[u,d]=pa(u,d);let c=a?u.shape[u.rank-2]:u.shape[u.rank-1],f=n?d.shape[d.rank-1]:d.shape[d.rank-2],m=a?u.shape[u.rank-1]:u.shape[u.rank-2],g=n?d.shape[d.rank-2]:d.shape[d.rank-1],b=u.shape.slice(0,-2),v=d.shape.slice(0,-2),x=zt(b),k=zt(v);U(c===f,()=>`Error in fused matMul: inner shapes (${c}) and (${f}) of Tensors with shapes ${u.shape} and ${d.shape} and transposeA=${a} and transposeB=${n} must match.`);let S=Ht(u.shape.slice(0,-2),d.shape.slice(0,-2)).concat([m,g]),N=a?te(u,[x,c,m]):te(u,[x,m,c]),T=n?te(d,[k,g,f]):te(d,[k,f,g]),_;r!=null&&(_=O(r,"bias","fused matMul"),[_]=pa(_,u),Ht(S,_.shape));let R;i!=null&&(R=O(i,"prelu weights","fused matMul"));let M=(V,P)=>{let[A,G,J,ee]=P,W=gv(te(V,J.shape),J,s),X,Q;if(!a&&!n?(X=lt(W,G,!1,!0),Q=lt(A,W,!0,!1)):!a&&n?(X=lt(W,G,!1,!1),Q=lt(W,A,!0,!1)):a&&!n?(X=lt(G,W,!1,!0),Q=lt(A,W,!1,!1)):(X=lt(G,W,!0,!0),Q=lt(W,A,!0,!0)),r!=null){let ce=yv(ee,W);return[X,Q,ce]}else return[X,Q]},F={a:N,b:T,bias:_,preluActivationWeights:R},B={transposeA:a,transposeB:n,activation:s,leakyreluAlpha:o};return r==null?Ws((V,P,A)=>{let G=j.runKernel(Bl,F,B);return A([V,P,G]),{value:te(G,S),gradFunc:M}})(N,T):Ws((V,P,A,G)=>{let J=j.runKernel(Bl,F,B);return G([V,P,J,A]),{value:te(J,S),gradFunc:M}})(N,T,_)}var Y6=K({fusedMatMul_:X6});function Z6(e){return mv(e,.54,.46)}var Q6=K({hammingWindow_:Z6});function J6(e){return mv(e,.5,.5)}var aR=K({hannWindow_:J6});function e5(e,t,a,n=!1,r=0){let s=0,i=[];for(;s+t<=e.size;)i.push(bt(e,s,t)),s+=a;if(n)for(;s<e.size;){let o=s+t-e.size,u=Gt([bt(e,s,t-o),ir([o],r)]);i.push(u),s+=a}return i.length===0?Ls([],[0,t]):te(Gt(i),[i.length,t])}var nR=K({frame_:e5});function t5(e,t,a,n,r=aR){n==null&&(n=jk(t));let s=nR(e,t,a),i=Z(s,r(t));return Xm(i,n)}var a5=K({stft_:t5});function n5(e,t,a,n,r="bilinear",s=0){let i=O(e,"image","cropAndResize"),o=O(t,"boxes","cropAndResize","float32"),u=O(a,"boxInd","cropAndResize","int32"),d=o.shape[0];U(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),U(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${d},4] but had shape ${o.shape}.`),U(u.rank===1&&u.shape[0]===d,()=>`Error in cropAndResize: boxInd must be have size [${d}] but had shape ${o.shape}.`),U(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),U(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),U(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);let c={image:i,boxes:o,boxInd:u},f={method:r,extrapolationValue:s,cropSize:n};return j.runKernel(oh,c,f)}var r5=K({cropAndResize_:n5});function s5(e){let t=O(e,"image","flipLeftRight","float32");U(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let a={image:t};return j.runKernel(hh,a,{})}var i5=K({flipLeftRight_:s5});function o5(e){let t=O(e,"image","grayscaleToRGB"),a=t.rank-1,n=t.shape[a];U(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),U(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let r=new Array(t.rank);return r.fill(1,0,a),r[a]=3,sr(t,r)}var l5=K({grayscaleToRGB_:o5});function u5(e){let t=O(e,"image","RGBToGrayscale"),a=t.rank-1,n=t.shape[a];U(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),U(n===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${n}.`);let r=t.dtype,s=Te(t,"float32"),i=Mt([.2989,.587,.114]),o;switch(t.rank){case 2:o=Cl("ij,j->i",s,i);break;case 3:o=Cl("ijk,k->ij",s,i);break;case 4:o=Cl("ijkl,l->ijk",s,i);break;case 5:o=Cl("ijklm,m->ijkl",s,i);break;case 6:o=Cl("ijklmn,n->ijklm",s,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Za(o,-1),Te(o,r)}var c5=K({rgbToGrayscale_:u5});function d5(e,t,a=0,n=.5){let r=O(e,"image","rotateWithOffset","float32");U(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);let s={image:r},i={radians:t,fillValue:a,center:n};return j.runKernel(Xh,s,i)}var h5=K({rotateWithOffset_:d5});function np(e,t,a,n,r,s){n==null&&(n=.5),r==null&&(r=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=e.shape[0];return a=Math.min(a,i),U(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),U(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),U(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),U(t.rank===1,()=>"scores must be a 1D tensor"),U(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),U(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:a,iouThreshold:n,scoreThreshold:r,softNmsSigma:s}}function p5(e,t,a,n=.5,r=Number.NEGATIVE_INFINITY){let s=O(e,"boxes","nonMaxSuppression","float32"),i=O(t,"scores","nonMaxSuppression","float32"),o=np(s,i,a,n,r);a=o.maxOutputSize,n=o.iouThreshold,r=o.scoreThreshold;let u={maxOutputSize:a,iouThreshold:n,scoreThreshold:r};return j.runKernel(_h,{boxes:s,scores:i},u)}var f5=K({nonMaxSuppression_:p5});function m5(e,t,a){let n=g5(e,t,a),r=n<0?-(n+1):n;e.splice(r,0,t)}function g5(e,t,a){return b5(e,t,a||y5)}function y5(e,t){return e>t?1:e<t?-1:0}function b5(e,t,a){let n=0,r=e.length,s=0,i=!1;for(;n<r;){s=n+(r-n>>>1);let o=a(t,e[s]);o>0?n=s+1:(r=s,i=!o)}return i?n:-n-1}function rR(e,t,a,n,r){return Xk(e,t,a,n,r,0)}function sR(e,t,a,n,r,s){return Xk(e,t,a,n,r,0,!1,s,!0)}function iR(e,t,a,n,r,s){return Xk(e,t,a,n,r,s,!0)}function Xk(e,t,a,n,r,s,i=!1,o=!1,u=!1){let d=[];for(let x=0;x<t.length;x++)t[x]>r&&d.push({score:t[x],boxIndex:x,suppressBeginIndex:0});d.sort($C);let c=s>0?-.5/s:0,f=[],m=[];for(;f.length<a&&d.length>0;){let x=d.pop(),{score:k,boxIndex:S,suppressBeginIndex:N}=x;if(k<r)break;let T=!1;for(let _=f.length-1;_>=N;--_){let R=v5(e,S,f[_]);if(R>=n){T=!0;break}if(x.score=x.score*x5(n,c,R),x.score<=r)break}x.suppressBeginIndex=f.length,T||(x.score===k?(f.push(S),m.push(x.score)):x.score>r&&m5(d,x,$C))}let g=f.length,b=a-g;o&&b>0&&(f.push(...new Array(b).fill(0)),m.push(...new Array(b).fill(0)));let v={selectedIndices:f};return i&&(v.selectedScores=m),u&&(v.validOutputs=g),v}function v5(e,t,a){let n=e.subarray(t*4,t*4+4),r=e.subarray(a*4,a*4+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),o=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),d=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),f=Math.max(r[0],r[2]),m=Math.max(r[1],r[3]),g=(o-s)*(u-i),b=(f-d)*(m-c);if(g<=0||b<=0)return 0;let v=Math.max(s,d),x=Math.max(i,c),k=Math.min(o,f),S=Math.min(u,m),N=Math.max(k-v,0)*Math.max(S-x,0);return N/(g+b-N)}function x5(e,t,a){let n=Math.exp(t*a*a);return a<=e?n:0}function $C(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function w5(e,t,a,n=.5,r=Number.NEGATIVE_INFINITY){let s=O(e,"boxes","nonMaxSuppressionAsync"),i=O(t,"scores","nonMaxSuppressionAsync"),o=np(s,i,a,n,r);a=o.maxOutputSize,n=o.iouThreshold,r=o.scoreThreshold;let u=await Promise.all([s.data(),i.data()]),d=u[0],c=u[1],{selectedIndices:f}=rR(d,c,a,n,r);return s!==e&&s.dispose(),i!==t&&i.dispose(),Mt(f,"int32")}var k5=w5;function S5(e,t,a,n=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=O(e,"boxes","nonMaxSuppression"),o=O(t,"scores","nonMaxSuppression"),u=np(i,o,a,n,r,s);a=u.maxOutputSize,n=u.iouThreshold,r=u.scoreThreshold,s=u.softNmsSigma;let d={boxes:i,scores:o},c={maxOutputSize:a,iouThreshold:n,scoreThreshold:r,softNmsSigma:s},f=j.runKernel(Eh,d,c);return{selectedIndices:f[0],selectedScores:f[1]}}var I5=K({nonMaxSuppressionWithScore_:S5});async function N5(e,t,a,n=.5,r=Number.NEGATIVE_INFINITY,s=0){let i=O(e,"boxes","nonMaxSuppressionAsync"),o=O(t,"scores","nonMaxSuppressionAsync"),u=np(i,o,a,n,r,s);a=u.maxOutputSize,n=u.iouThreshold,r=u.scoreThreshold,s=u.softNmsSigma;let d=await Promise.all([i.data(),o.data()]),c=d[0],f=d[1],{selectedIndices:m,selectedScores:g}=iR(c,f,a,n,r,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Mt(m,"int32"),selectedScores:Mt(g)}}var T5=N5;function _5(e,t,a,n=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=O(e,"boxes","nonMaxSuppression"),o=O(t,"scores","nonMaxSuppression"),u=np(i,o,a,n,r,null),d=u.maxOutputSize,c=u.iouThreshold,f=u.scoreThreshold,m={boxes:i,scores:o},g={maxOutputSize:d,iouThreshold:c,scoreThreshold:f,padToMaxOutputSize:s},b=j.runKernel(Ch,m,g);return{selectedIndices:b[0],validOutputs:b[1]}}var C5=K({nonMaxSuppressionPadded_:_5});async function E5(e,t,a,n=.5,r=Number.NEGATIVE_INFINITY,s=!1){let i=O(e,"boxes","nonMaxSuppressionAsync"),o=O(t,"scores","nonMaxSuppressionAsync"),u=np(i,o,a,n,r,null),d=u.maxOutputSize,c=u.iouThreshold,f=u.scoreThreshold,[m,g]=await Promise.all([i.data(),o.data()]),{selectedIndices:b,validOutputs:v}=sR(m,g,d,c,f,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Mt(b,"int32"),validOutputs:We(v,"int32")}}var A5=E5;function $5(e,t,a=!1,n=!1){let r=O(e,"images","resizeBilinear");U(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),U(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),U(n===!1||a===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=te(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:s},u={alignCorners:a,halfPixelCenters:n,size:t},d=j.runKernel(ic,o,u);return i?te(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var oR=K({resizeBilinear_:$5});function R5(e,t,a=!1,n=!1){let r=O(e,"images","resizeNearestNeighbor");U(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),U(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),U(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),U(n===!1||a===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=r,i=!1;r.rank===3&&(i=!0,s=te(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let o={images:s},u={alignCorners:a,halfPixelCenters:n,size:t},d=j.runKernel(sc,o,u);return i?te(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var lR=K({resizeNearestNeighbor_:R5});function D5(e,t="binary",a=!1,n=.5){let r=O(e,"image","threshold"),s=.2989,i=.587,o=.114,u=r.shape[0]*r.shape[1],d=Z(Mt([n]),255),c,f,m,g;if(U(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),U(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),U(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),U(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),r.shape[2]===3){[c,f,m]=Wn(r,[1,1,1],-1);let v=Z(c,s),x=Z(f,i),k=Z(m,o);g=ge(ge(v,x),k)}else g=e;if(t==="otsu"){let v=sk(Te(av(g),"int32"),_n([]),256);d=M5(v,u)}let b=a?Po(g,d):Dn(g,d);return Te(Z(b,255),"int32")}function M5(e,t){let a=Mt([-1]),n=Mt([0]),r=Mt([0]),s,i,o,u,d,c;for(let f=0;f<e.size-1;f++){s=bt(e,0,f+1),i=bt(e,f+1),d=Fe(ze(s),t),c=Fe(ze(i),t);let m=ze(Z(s,Yl(0,s.size)));o=Fe(m,ze(s));let g=ir(i.shape,s.size),b=ge(Yl(0,i.size),g),v=Z(i,b);u=Fe(ze(v),ze(i));let x=$e(o,u),k=$e(o,u),S=Z(d,c);r=Z(Z(S,x),k);let N=Dn(r,n);n=Ja(N,r,n),a=Ja(N,Mt([f]),a)}return a}var F5=K({threshold_:D5});function O5(e,t,a="nearest",n="constant",r=0,s){let i=O(e,"image","transform","float32"),o=O(t,"transforms","transform","float32");U(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),U(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),U(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:i,transforms:o},d={interpolation:a,fillMode:n,fillValue:r,outputShape:s};return j.runKernel(qh,u,d)}var z5=K({transform_:O5});function L5(e,t,a){let n=O(e,"a","bandPart");U(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let r=n.shape,[s,i]=n.shape.slice(-2),o,u;typeof t=="number"?(U(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),U(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),o=O(t<0?s:t,"numLower","bandPart")):(U(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Ja(Md(t,0),s,To(t,s))),typeof a=="number"?(U(a%1===0,()=>`bandPart(): numUpper must be an integer, got ${a}.`),U(a<=i,()=>`bandPart(): numUpper (${a}) must not be greater than the number of columns (${i}).`),u=O(a<0?i:a,"numUpper","bandPart")):(U(a.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Ja(Md(a,0),i,To(a,i)));let d=te(Yl(0,s,1,"int32"),[-1,1]),c=Yl(0,i,1,"int32"),f=$e(d,c),m=Gr(Po(f,o),Ti(f,ta(u))),g=da([s,i],n.dtype);return te($a(ya(te(n,[-1,s,i])).map(b=>Ja(m,b,g))),r)}var B5=K({bandPart_:L5});function U5(e){let t;if(Array.isArray(e)){t=!1,U(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let r=e[0].shape[0];for(let s=1;s<e.length;++s)U(e[s].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[s].shape[0]} vs. ${r})`)}else t=!0,e=Wn(e,e.shape[0],0).map(r=>Go(r,[0]));U(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let a=[],n=e;for(let r=0;r<e.length;++r)a.push(j.tidy(()=>{let s=n[r];if(r>0)for(let i=0;i<r;++i){let o=Z(ze(Z(a[i],s)),a[i]);s=$e(s,o)}return Fe(s,Qh(s,"euclidean"))}));return t?$a(a,0):a}var P5=K({gramSchmidt_:U5});function W5(e,t=!1){if(U(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return RC(e,t);{let a=e.shape.slice(0,e.shape.length-2).reduce((u,d)=>u*d),n=ya(te(e,[a,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];n.forEach(u=>{let[d,c]=RC(u,t);r.push(d),s.push(c)});let i=te($a(r,0),e.shape),o=te($a(s,0),e.shape);return[i,o]}}function RC(e,t=!1){return j.tidy(()=>{U(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let a=e.shape[0],n=e.shape[1],r=Xb(a),s=zs(e),i=Ls([[1]],[1,1]),o=zs(i),u=a>=n?n:a;for(let d=0;d<u;++d){let c=s,f=o,m=r;[o,s,r]=j.tidy(()=>{let g=bt(s,[d,d],[a-d,1]),b=Qh(g),v=bt(s,[d,d],[1,1]),x=Ja(Dn(v,0),Ls([[-1]]),Ls([[1]])),k=$e(v,Z(x,b)),S=Fe(g,k);S.shape[0]===1?o=zs(i):o=Gt([i,bt(S,[1,0],[S.shape[0]-1,S.shape[1]])],0);let N=ta(Fe(lt(x,k),b)),T=bt(s,[d,0],[a-d,n]),_=Z(N,o),R=ut(o);if(d===0)s=$e(T,lt(_,lt(R,T)));else{let B=$e(T,lt(_,lt(R,T)));s=Gt([bt(s,[0,0],[d,n]),B],0)}let M=ut(_),F=bt(r,[0,d],[a,r.shape[1]-d]);if(d===0)r=$e(F,lt(lt(F,o),M));else{let B=$e(F,lt(lt(F,o),M));r=Gt([bt(r,[0,0],[a,d]),B],1)}return[o,s,r]}),nt([c,f,m])}return!t&&a>n&&(r=bt(r,[0,0],[a,n]),s=bt(s,[0,0],[n,n])),[r,s]})}var V5=K({qr_:W5}),Nn;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Nn||(Nn={}));function G5(e,t,a=Nn.SUM_BY_NONZERO_WEIGHTS){let n=O(e,"losses","computeWeightedLoss"),r=null;t!=null&&(r=O(t,"weights","computeWeightedLoss"));let s=r==null?n:Z(n,r);if(a===Nn.NONE)return s;if(a===Nn.SUM)return ze(s);if(a===Nn.MEAN){if(r==null)return ca(s);{let i=n.size/r.size,o=Fe(ze(s),ze(r));return i>1?Fe(o,We(i)):o}}if(a===Nn.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Fe(ze(s),We(n.size));{let i=Z(r,Pn(n.shape)),o=Te(ze(Xl(i,We(0))),"float32");return Fe(ze(s),o)}}throw Error(`Unknown reduction: ${a}`)}var _i=K({computeWeightedLoss_:G5});function H5(e,t,a,n=Nn.SUM_BY_NONZERO_WEIGHTS){let r=O(e,"labels","absoluteDifference"),s=O(t,"predictions","absoluteDifference"),i=null;a!=null&&(i=O(a,"weights","absoluteDifference")),$n(r.shape,s.shape,"Error in absoluteDifference: ");let o=Ca($e(r,s));return _i(o,i,n)}var q5=K({absoluteDifference_:H5});function j5(e,t,a,n,r=Nn.SUM_BY_NONZERO_WEIGHTS){let s=O(e,"labels","cosineDistance"),i=O(t,"predictions","cosineDistance"),o=null;n!=null&&(o=O(n,"weights","cosineDistance")),$n(s.shape,i.shape,"Error in cosineDistance: ");let u=We(1),d=$e(u,ze(Z(s,i),a,!0));return _i(d,o,r)}var K5=K({cosineDistance_:j5});function X5(e,t,a,n=Nn.SUM_BY_NONZERO_WEIGHTS){let r=O(e,"labels","hingeLoss"),s=O(t,"predictions","hingeLoss"),i=null;a!=null&&(i=O(a,"weights","hingeLoss")),$n(r.shape,s.shape,"Error in hingeLoss: ");let o=We(1);r=$e(Z(We(2),r),o);let u=Ot($e(o,Z(r,s)));return _i(u,i,n)}var Y5=K({hingeLoss_:X5});function Z5(e,t,a,n=1,r=Nn.SUM_BY_NONZERO_WEIGHTS){let s=O(e,"labels","huberLoss"),i=O(t,"predictions","huberLoss"),o=null;a!=null&&(o=O(a,"weights","huberLoss")),$n(s.shape,i.shape,"Error in huberLoss: ");let u=We(n),d=Ca($e(i,s)),c=To(d,u),f=$e(d,c),m=ge(Z(We(.5),Vt(c)),Z(u,f));return _i(m,o,r)}var Q5=K({huberLoss_:Z5});function J5(e,t,a,n=1e-7,r=Nn.SUM_BY_NONZERO_WEIGHTS){let s=O(e,"labels","logLoss"),i=O(t,"predictions","logLoss"),o=null;a!=null&&(o=O(a,"weights","logLoss")),$n(s.shape,i.shape,"Error in logLoss: ");let u=We(1),d=We(n),c=ta(Z(s,lr(ge(i,d)))),f=Z($e(u,s),lr(ge($e(u,i),d))),m=$e(c,f);return _i(m,o,r)}var eq=K({logLoss_:J5});function tq(e,t,a,n=Nn.SUM_BY_NONZERO_WEIGHTS){let r=O(e,"labels","meanSquaredError"),s=O(t,"predictions","meanSquaredError"),i=null;a!=null&&(i=O(a,"weights","meanSquaredError")),$n(r.shape,s.shape,"Error in meanSquaredError: ");let o=uv(r,s);return _i(o,i,n)}var aq=K({meanSquaredError_:tq});function nq(e,t){let a=O(e,"labels","sigmoidCrossEntropyWithLogits"),n=O(t,"logits","sigmoidCrossEntropyWithLogits");$n(a.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let r=Ot(n),s=Z(n,a),i=Pm(bn(ta(Ca(n))));return ge($e(r,s),i)}function rq(e,t,a,n=0,r=Nn.SUM_BY_NONZERO_WEIGHTS){let s=O(e,"multiClassLabels","sigmoidCrossEntropy"),i=O(t,"logits","sigmoidCrossEntropy"),o=null;if(a!=null&&(o=O(a,"weights","sigmoidCrossEntropy")),$n(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),n>0){let d=We(n),c=We(1),f=We(.5);s=ge(Z(s,$e(c,d)),Z(f,d))}let u=nq(s,i);return _i(u,o,r)}var sq=K({sigmoidCrossEntropy_:rq});function iq(e,t,a=-1){if(a===-1&&(a=t.rank-1),a!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${a}`);return Ws((n,r,s)=>{let i=Wm(r,[a],!0),o=$e(Te(r,"float32"),i);s([n,o]);let u=ta(Z(o,n));return{value:ze(u,[a]),gradFunc:(d,c)=>{let[f,m]=c,g=Kl(d.shape,[a]);return[Z(te(d,g),$e(Te(f,"float32"),bn(m))),Z(te(d,g),$e(bn(m),Te(f,"float32")))]}}})(e,t)}function oq(e,t,a,n=0,r=Nn.SUM_BY_NONZERO_WEIGHTS){let s=O(e,"onehotLabels","softmaxCrossEntropy"),i=O(t,"logits","softmaxCrossEntropy"),o=null;if(a!=null&&(o=O(a,"weights","softmaxCrossEntropy")),$n(s.shape,i.shape,"Error in softmaxCrossEntropy: "),n>0){let d=We(n),c=We(1),f=We(s.shape[1]);s=ge(Z(s,$e(c,d)),Fe(d,f))}let u=iq(s,i);return _i(u,o,r)}var lq=K({softmaxCrossEntropy_:oq});function uq(e,t,a,n){let r=O(e,"indices","sparseFillEmptyRows","int32"),s=O(t,"values","sparseFillEmptyRows"),i=O(a,"denseShape","sparseFillEmptyRows","int32"),o=O(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let u={indices:r,values:s,denseShape:i,defaultValue:o},d=j.runKernel(wm,u);return{outputIndices:d[0],outputValues:d[1],emptyRowIndicator:d[2],reverseIndexMap:d[3]}}var cq=K({sparseFillEmptyRows_:uq});function dq(e,t,a){let n=O(e,"inputIndices","sparseReshape","int32"),r=O(t,"inputShape","sparseReshape","int32"),s=O(a,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:n,inputShape:r,newShape:s},o=j.runKernel(Wh,i);return{outputIndices:o[0],outputShape:o[1]}}var hq=K({sparseReshape_:dq});function pq(e,t,a){let n=O(e,"data","sparseSegmentMean"),r=O(t,"indices","sparseSegmentMean","int32"),s=O(a,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:n,indices:r,segmentIds:s};return j.runKernel(km,i)}var fq=K({sparseSegmentMean_:pq});function mq(e,t,a){let n=O(e,"data","sparseSegmentSum"),r=O(t,"indices","sparseSegmentSum","int32"),s=O(a,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:n,indices:r,segmentIds:s};return j.runKernel(Sm,i)}var gq=K({sparseSegmentSum_:mq});function yq(e,t,a,n,r,s,i,o){let u=O(e,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let d=O(t,"dataSplits","stringNGrams");if(d.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:a,nGramWidths:n,leftPad:r,rightPad:s,padWidth:i,preserveShortSequences:o},f={data:u,dataSplits:d},m=j.runKernel(Tm,f,c);return{nGrams:m[0],nGramsSplits:m[1]}}var bq=K({stringNGrams_:yq});function vq(e,t,a=!0){let n=O(e,"input","stringSplit","string"),r=O(t,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);let s={skipEmpty:a},i={input:n,delimiter:r},o=j.runKernel(_m,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var xq=K({stringSplit_:vq});function wq(e,t){let a=O(e,"input","stringToHashBucketFast","string"),n={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let r={input:a};return j.runKernel(Cm,r,n)}var kq=K({stringToHashBucketFast_:wq});function Sq(e,t,a,n=!0){let r=O(e,"input","staticRegexReplace","string"),s={pattern:t,rewrite:a,replaceGlobal:n};return j.runKernel(Nm,{x:r},s)}var Iq=K({staticRegexReplace_:Sq}),uR={fft:Km,ifft:Ld,rfft:Xm,irfft:lv},cR={hammingWindow:Q6,hannWindow:aR,frame:nR,stft:a5},xr={flipLeftRight:i5,grayscaleToRGB:l5,resizeNearestNeighbor:lR,resizeBilinear:oR,rgbToGrayscale:c5,rotateWithOffset:h5,cropAndResize:r5,nonMaxSuppression:f5,nonMaxSuppressionAsync:k5,nonMaxSuppressionWithScore:I5,nonMaxSuppressionWithScoreAsync:T5,nonMaxSuppressionPadded:C5,nonMaxSuppressionPaddedAsync:A5,threshold:F5,transform:z5},Yk={bandPart:B5,gramSchmidt:P5,qr:V5},dR={absoluteDifference:q5,computeWeightedLoss:_i,cosineDistance:K5,hingeLoss:Y5,huberLoss:Q5,logLoss:eq,meanSquaredError:aq,sigmoidCrossEntropy:sq,softmaxCrossEntropy:lq},hR={sparseFillEmptyRows:cq,sparseReshape:hq,sparseSegmentMean:fq,sparseSegmentSum:gq},pR={stringNGrams:bq,stringSplit:xq,stringToHashBucketFast:kq,staticRegexReplace:Iq},ke={};rt(ke,{Serializable:()=>fR,SerializationMap:()=>mR,getRegisteredName:()=>Tq,registerClass:()=>gR});var Nq=new Map,Lw=new Map,fR=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},mR=class Sd{constructor(){this.classNameMap={}}static getMap(){return Sd.instance==null&&(Sd.instance=new Sd),Sd.instance}static register(t){Sd.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function gR(e,t,a){U(e.className!=null,()=>"Class being registered does not have the static className property defined."),U(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),U(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof a>"u"&&(a=e.className);let n=a,r=t+">"+n;return mR.register(e),Nq.set(r,e),Lw.set(e,r),e}function Tq(e){return Lw.has(e)?Lw.get(e):e.className}var Ci=class extends fR{minimize(e,t=!1,a){let{value:n,grads:r}=this.computeGradients(e,a);if(a!=null){let s=a.map(i=>({name:i.name,tensor:r[i.name]}));this.applyGradients(s)}else this.applyGradients(r);return nt(r),t?n:(n.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return g$(e,t)}dispose(){this.iterations_!=null&&nt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:We(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Ci,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var Zk=class extends Ci{static get className(){return"Adadelta"}constructor(e,t,a=null){super(),this.learningRate=e,this.rho=t,this.epsilon=a,this.accumulatedGrads=[],this.accumulatedUpdates=[],a==null&&(this.epsilon=j.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,a)=>{let n=j.registeredVariables[t],r=!1;this.accumulatedGrads[a]==null&&(this.accumulatedGrads[a]={originalName:`${t}/accum_grad`,variable:ae(()=>St(n).variable(r))}),this.accumulatedUpdates[a]==null&&(this.accumulatedUpdates[a]={originalName:`${t}/accum_var`,variable:ae(()=>St(n).variable(r))});let s=Array.isArray(e)?e[a].tensor:e[t];if(s==null)return;let i=this.accumulatedGrads[a].variable,o=this.accumulatedUpdates[a].variable;ae(()=>{let u=ge(Z(i,this.rho),Z(Vt(s),1-this.rho)),d=Z(Fe(en(ge(o,this.epsilon)),en(ge(i,this.epsilon))),s),c=ge(Z(o,this.rho),Z(Vt(d),1-this.rho));i.assign(u),o.assign(c);let f=ge(Z(d,-this.learningRate),n);n.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(nt(this.accumulatedGrads.map(e=>e.variable)),nt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,a=!1;this.accumulatedGrads=e.slice(0,t).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})),this.accumulatedUpdates=e.slice(t,t*2).map(n=>({originalName:n.name,variable:n.tensor.variable(a)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},Qk=class extends Ci{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,a)=>{let n=j.registeredVariables[t];this.accumulatedGrads[a]==null&&(this.accumulatedGrads[a]={originalName:`${t}/accumulator`,variable:ae(()=>ir(n.shape,this.initialAccumulatorValue).variable(!1))});let r=Array.isArray(e)?e[a].tensor:e[t];if(r==null)return;let s=this.accumulatedGrads[a].variable;ae(()=>{let i=ge(s,Vt(r));s.assign(i);let o=ge(Z(Fe(r,en(ge(i,j.backend.epsilon()))),-this.learningRate),n);n.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&nt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(a=>({originalName:a.name,variable:a.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},Jk=class extends Ci{static get className(){return"Adam"}constructor(e,t,a,n=null){super(),this.learningRate=e,this.beta1=t,this.beta2=a,this.epsilon=n,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ae(()=>{this.accBeta1=We(t).variable(),this.accBeta2=We(a).variable()}),n==null&&(this.epsilon=j.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(a=>a.name):Object.keys(e);ae(()=>{let a=$e(1,this.accBeta1),n=$e(1,this.accBeta2);t.forEach((r,s)=>{let i=j.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:ae(()=>St(i).variable(o))}),this.accumulatedSecondMoment[s]==null&&(this.accumulatedSecondMoment[s]={originalName:`${r}/v`,variable:ae(()=>St(i).variable(o))});let u=Array.isArray(e)?e[s].tensor:e[r];if(u==null)return;let d=this.accumulatedFirstMoment[s].variable,c=this.accumulatedSecondMoment[s].variable,f=ge(Z(d,this.beta1),Z(u,1-this.beta1)),m=ge(Z(c,this.beta2),Z(Vt(u),1-this.beta2)),g=Fe(f,a),b=Fe(m,n);d.assign(f),c.assign(m);let v=ge(Z(Fe(g,ge(en(b),this.epsilon)),-this.learningRate),i);i.assign(v)}),this.accBeta1.assign(Z(this.accBeta1,this.beta1)),this.accBeta2.assign(Z(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&nt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&nt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ae(()=>{this.accBeta1.assign(Ps(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ps(this.beta2,this.iterations_+1))});let t=e.length/2,a=!1;this.accumulatedFirstMoment=e.slice(0,t).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(n=>({originalName:n.name,variable:n.tensor.variable(a)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},eS=class extends Ci{static get className(){return"Adamax"}constructor(e,t,a,n=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=a,this.epsilon=n,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ae(()=>{this.iteration=We(0).variable(),this.accBeta1=We(t).variable()}),n==null&&(this.epsilon=j.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(a=>a.name):Object.keys(e);ae(()=>{let a=$e(1,this.accBeta1),n=Fe(-this.learningRate,ge(Z(this.iteration,this.decay),1));t.forEach((r,s)=>{let i=j.registeredVariables[r],o=!1;this.accumulatedFirstMoment[s]==null&&(this.accumulatedFirstMoment[s]={originalName:`${r}/m`,variable:St(i).variable(o)}),this.accumulatedWeightedInfNorm[s]==null&&(this.accumulatedWeightedInfNorm[s]={originalName:`${r}/v`,variable:St(i).variable(o)});let u=Array.isArray(e)?e[s].tensor:e[r];if(u==null)return;let d=this.accumulatedFirstMoment[s].variable,c=this.accumulatedWeightedInfNorm[s].variable,f=ge(Z(d,this.beta1),Z(u,1-this.beta1)),m=Z(c,this.beta2),g=Ca(u),b=Hs(m,g);d.assign(f),c.assign(b);let v=ge(Z(Fe(n,a),Fe(f,ge(b,this.epsilon))),i);i.assign(v)}),this.iteration.assign(ge(this.iteration,1)),this.accBeta1.assign(Z(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&nt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&nt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},xv=class extends Ci{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,a)=>{let n=Array.isArray(e)?e[a].tensor:e[t];if(n==null)return;let r=j.registeredVariables[t];ae(()=>{let s=ge(Z(this.c,n),r);r.assign(s)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ba(We(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},tS=class extends xv{static get className(){return"Momentum"}constructor(e,t,a=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=a,this.accumulations=[],this.m=We(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,a)=>{let n=j.registeredVariables[t];this.accumulations[a]==null&&(this.accumulations[a]={originalName:`${t}/momentum`,variable:ae(()=>St(n).variable(!1))});let r=this.accumulations[a].variable,s=Array.isArray(e)?e[a].tensor:e[t];s!=null&&ae(()=>{let i,o=ge(Z(this.m,r),s);this.useNesterov?i=ge(Z(this.c,ge(s,Z(o,this.m))),n):i=ge(Z(this.c,o),n),r.assign(o),n.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&nt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(a=>({originalName:a.name,variable:a.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},aS=class extends Ci{static get className(){return"RMSProp"}constructor(e,t=.9,a=0,n=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=a,this.epsilon=n,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,n==null&&(this.epsilon=j.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,a)=>{let n=j.registeredVariables[t],r=!1;this.accumulatedMeanSquares[a]==null&&(this.accumulatedMeanSquares[a]={originalName:`${t}/rms`,variable:ae(()=>St(n).variable(r))}),this.accumulatedMoments[a]==null&&(this.accumulatedMoments[a]={originalName:`${t}/momentum`,variable:ae(()=>St(n).variable(r))}),this.accumulatedMeanGrads[a]==null&&this.centered&&(this.accumulatedMeanGrads[a]={originalName:`${t}/mg`,variable:ae(()=>St(n).variable(r))});let s=Array.isArray(e)?e[a].tensor:e[t];if(s==null)return;let i=this.accumulatedMeanSquares[a].variable,o=this.accumulatedMoments[a].variable;ae(()=>{let u=ge(Z(i,this.decay),Z(Vt(s),1-this.decay));if(this.centered){let d=this.accumulatedMeanGrads[a].variable,c=ge(Z(d,this.decay),Z(s,1-this.decay)),f=Fe(Z(s,this.learningRate),en($e(u,ge(Vt(c),this.epsilon)))),m=ge(Z(o,this.momentum),f);i.assign(u),d.assign(c),o.assign(m);let g=$e(n,m);n.assign(g)}else{let d=ge(Z(i,this.decay),Z(Vt(s),1-this.decay)),c=ge(Z(o,this.momentum),Fe(Z(s,this.learningRate),en(ge(d,this.epsilon))));i.assign(d),o.assign(c);let f=$e(n,c);n.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&nt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&nt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&nt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,a=!1;this.accumulatedMeanSquares=e.slice(0,t).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})),this.accumulatedMoments=e.slice(t,t*2).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(n=>({originalName:n.name,variable:n.tensor.variable(a)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},_q=[Zk,Qk,Jk,eS,tS,aS,xv];function Cq(){for(let e of _q)gR(e)}var dn={};rt(dn,{CompositeArrayBuffer:()=>Ii,browserFiles:()=>Fq,browserHTTPRequest:()=>Pq,concatenateArrayBuffers:()=>mW,copyModel:()=>zW,decodeWeights:()=>WA,decodeWeightsStream:()=>GA,encodeWeights:()=>uW,fromMemory:()=>Vq,fromMemorySync:()=>wR,getLoadHandlers:()=>SW,getModelArtifactsForJSON:()=>G1,getModelArtifactsForJSONSync:()=>qA,getModelArtifactsInfoForJSON:()=>Fm,getSaveHandlers:()=>kW,getWeightSpecs:()=>Rw,http:()=>rS,isHTTPScheme:()=>Uw,listModels:()=>FW,loadWeights:()=>zq,moveModel:()=>LW,registerLoadRouter:()=>wW,registerSaveRouter:()=>xW,removeModel:()=>OW,weightsLoaderFactory:()=>bR,withSaveHandler:()=>Gq,withSaveHandlerSync:()=>Hq});var Eq="model",Aq=".json",$q=".weights.bin";function DC(e){return new Promise(t=>setTimeout(t)).then(e)}var Jy=class Bw{constructor(t){if(!ie().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Bw.URL_SCHEME)&&(t=t.slice(Bw.URL_SCHEME.length)),(t==null||t.length===0)&&(t=Eq),this.modelJsonFileName=t+Aq,this.weightDataFileName=t+$q}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let a=Ii.join(t.weightData),n=window.URL.createObjectURL(new Blob([a],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=HA(t,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await DC(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=n,await DC(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Fm(t)}}}};Jy.URL_SCHEME="downloads://";var Rq=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let a=new FileReader;a.onload=n=>{let r=JSON.parse(n.target.result),s=r.modelTopology;if(s==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:s});return}let i=G1(r,o=>this.loadWeights(o));e(i)},a.onerror=n=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),a.readAsText(this.jsonFile)})}loadWeights(e){let t=[],a=[];for(let s of e)t.push(...s.weights),a.push(...s.paths);let n=this.checkManifestAndWeightFiles(e),r=a.map(s=>this.loadWeightsFile(s,n[s]));return Promise.all(r).then(s=>[t,s])}loadWeightsFile(e,t){return new Promise((a,n)=>{let r=new FileReader;r.onload=s=>{let i=s.target.result;a(i)},r.onerror=s=>n(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],a=this.weightsFiles.map(r=>AC(r.name)),n={};for(let r of e)r.paths.forEach(s=>{let i=AC(s);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),a.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);n[s]=this.weightsFiles[a.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return n}},Dq=e=>ie().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Jy.URL_SCHEME)?Mq(e.slice(Jy.URL_SCHEME.length)):null;Tr.registerSaveRouter(Dq);function Mq(e="model"){return new Jy(e)}function Fq(e){return new Rq(e)}function MC(e,t,a,n){i(e),a=a??0,n=n??1,o(a,n);let r=0,s=u=>(u.then(d=>{let c=a+ ++r/e.length*(n-a);return t(c),d}),u);function i(u){U(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function o(u,d){U(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),U(d>=0&&d<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${d}`),U(d>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${d}`)}return Promise.all(e.map(s))}async function yR(e,t){t==null&&(t={});let a=t.fetchFunc==null?ie().platform.fetch:t.fetchFunc,n=e.map(s=>a(s,t.requestInit,{isBinary:!0})),r=(t.onProgress==null?await Promise.all(n):await MC(n,t.onProgress,0,.5)).map(s=>s.arrayBuffer());return t.onProgress==null?await Promise.all(r):await MC(r,t.onProgress,.5,1)}function Oq(e,t){var a;let n=t.fetchFunc==null?ie().platform.fetch:t.fetchFunc,r=0,s;return(a=t.onProgress)===null||a===void 0||a.call(t,0),new ReadableStream({pull:async i=>{for(var o;r<e.length;){s||(s=(await n(e[r],t.requestInit,{isBinary:!0})).body.getReader());let{done:u,value:d}=await s.read();if(u){r++,s=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,r/e.length);continue}i.enqueue(d);return}i.close()}})}async function zq(e,t="",a,n){return bR(r=>yR(r,{requestInit:n}))(e,t,a)}function bR(e){return async(t,a="",n)=>{let r=t.map(()=>!1),s={},i=n!=null?n.map(()=>!1):[],o=[];if(t.forEach((g,b)=>{let v=0;g.weights.forEach(x=>{let k="quantization"in x?x.quantization.dtype:x.dtype,S=Vl[k]*zt(x.shape),N=()=>{r[b]=!0,s[b]==null&&(s[b]=[]),s[b].push({manifestEntry:x,groupOffset:v,sizeBytes:S})};n!=null?n.forEach((T,_)=>{T===x.name&&(N(),i[_]=!0)}):N(),o.push(x.name),v+=S})}),!i.every(g=>g)){let g=n.filter((b,v)=>!i[v]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let u=r.reduce((g,b,v)=>(b&&g.push(v),g),[]),d=[];u.forEach(g=>{t[g].paths.forEach(b=>{let v=a+(a.endsWith("/")?"":"/")+b;d.push(v)})});let c=await e(d),f={},m=0;return u.forEach(g=>{let b=t[g].paths.length,v=new Ii(c.slice(m,m+b));s[g].forEach(x=>{let k=v.slice(x.groupOffset,x.groupOffset+x.sizeBytes),S=WA(k,[x.manifestEntry]);for(let N in S)f[N]=S[N]}),m+=b}),f}}var Lq="application/octet-stream",Bq="application/json",nS=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(U(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ie().platform.fetch,U(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&U(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let a=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],n=HA(e,a);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:Bq}),"model.json"),e.weightData!=null){let s=Ii.join(e.weightData);t.body.append("model.weights.bin",new Blob([s],{type:Lq}),"model.weights.bin")}let r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Fm(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let s=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?s+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":s+=" Please make sure the server is serving valid JSON for this request.",new Error(s)}let a=t.modelTopology,n=t.weightsManifest;if(a==null&&n==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return G1(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),a=Rw(e.weightsManifest),n=()=>Oq(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:a,getWeightStream:n})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[a,n]=Uq(t),r=this.weightPathPrefix||a,s=[],i=[];for(let o of e)for(let u of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(u)):s.push(r+u+n);return this.weightUrlConverter&&s.push(...await Promise.all(i)),s}async loadWeights(e){let t=await this.getWeightUrls(e),a=Rw(e),n=await yR(t,this.loadOptions);return[a,n]}};nS.URL_SCHEME_REGEX=/^https?:\/\//;function Uq(e){let t=e.lastIndexOf("/"),a=e.lastIndexOf("?"),n=e.substring(0,t),r=a>t?e.substring(a):"";return[n+"/",r]}function Uw(e){return e.match(nS.URL_SCHEME_REGEX)!=null}var vR=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let a=!0;if(Array.isArray(e)?a=e.every(n=>Uw(n)):a=Uw(e),a)return rS(e,t)}return null};Tr.registerSaveRouter(vR);Tr.registerLoadRouter(vR);function rS(e,t){return new nS(e,t)}function Pq(e,t){return rS(e,t)}var ow=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},xR=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},Wq=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function Vq(e,t,a,n){let r=arguments;return new Wq(wR(...r))}function wR(e,t,a,n){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new ow(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ow({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ow({modelTopology:e,weightSpecs:t,weightData:a,trainingConfig:n}))}function Gq(e){return new xR(e)}function Hq(e){return new xR(e)}var kR={};rt(kR,{confusionMatrix:()=>jq});function qq(e,t,a){let n=O(e,"labels","confusionMatrix"),r=O(t,"predictions","confusionMatrix");U(a==null||a>0&&Number.isInteger(a),()=>`If provided, numClasses must be a positive integer, but got ${a}`),U(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),U(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),U(n.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),U(a>0&&Number.isInteger(a),()=>`numClasses is required to be a positive integer, but got ${a}`);let s=Fd(Te(n,"int32"),a),i=Fd(Te(r,"int32"),a),o=ut(s),u=lt(o,i);return Te(u,"int32")}var jq=K({confusionMatrix_:qq}),Ym={};rt(Ym,{draw:()=>tj,fromPixels:()=>aj,fromPixelsAsync:()=>Qq,toPixels:()=>ej});var kl,FC=!1;function SR(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let a=!1,n=!1,r=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)a=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)s=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(Gf(Xy,j.backendName)!=null){let m={pixels:e},g={numChannels:t};return j.runKernel(Xy,m,g)}let[u,d]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height],c;if(i)c=e.getContext("2d").getImageData(0,0,u,d).data;else if(n||a)c=e.data;else if(s||r||o){if(kl==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")kl=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else kl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});kl.canvas.width=u,kl.canvas.height=d,kl.drawImage(e,0,0,u,d),c=kl.getImageData(0,0,u,d).data}let f;if(t===4)f=new Int32Array(c);else{let m=u*d;f=new Int32Array(m*t);for(let g=0;g<m;g++)for(let b=0;b<t;++b)f[g*t+b]=c[g*4+b]}return cv(f,[d,u,t],"int32")}function Kq(e){return e!=null&&e.data instanceof Uint8Array}function Xq(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function Yq(e){return e!=null&&e.width!==0&&e.height!==0}function Zq(e){return Xq()&&!(e instanceof ImageBitmap)&&Yq(e)&&!Kq(e)}async function Qq(e,t=3){let a=null;if(ie().getBool("WRAP_TO_IMAGEBITMAP")&&Zq(e)){let n;try{n=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{n=null}n!=null&&n.width===e.width&&n.height===e.height?a=n:a=e}else a=e;return SR(a,t)}function IR(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function Jq(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function ej(e,t){let a=O(e,"img","toPixels");if(!(e instanceof ht)){let d=a;a=Te(d,"int32"),d.dispose()}IR(a);let[n,r]=a.shape.slice(0,2),s=a.rank===2?1:a.shape[2],i=await a.data(),o=a.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*n*4);for(let d=0;d<n*r;++d){let c=[0,0,0,255];for(let m=0;m<s;m++){let g=i[d*s+m];if(a.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(a.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);s===1?(c[0]=g*o,c[1]=g*o,c[2]=g*o):c[m]=g*o}let f=d*4;u[f+0]=Math.round(c[0]),u[f+1]=Math.round(c[1]),u[f+2]=Math.round(c[2]),u[f+3]=Math.round(c[3])}if(t!=null){FC||Gf(Ab,j.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),FC=!0),t.width=r,t.height=n;let d=t.getContext("2d"),c=new ImageData(u,r,n);d.putImageData(c,0,0)}return a!==e&&a.dispose(),u}function tj(e,t,a){let n=O(e,"img","draw");if(!(e instanceof ht)){let i=n;n=Te(i,"int32"),i.dispose()}IR(n),Jq(a==null?void 0:a.imageOptions);let r={image:n},s={canvas:t,options:a};j.runKernel(Ab,r,s)}var aj=K({fromPixels_:SR}),sS={};rt(sS,{prepareAndValidate:()=>NR});function NR(e,t){let a=e.shape.length,n=t.shape.length;if(a<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${a}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>a)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${a}`);if(zt(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let r=t.shape,s=r[r.length-1],i=1;for(let f=0;f<r.length-1;++f)i*=r[f];let o=e.shape,u=r.slice();u.pop();let d=1;for(let f=s;f<a;++f)d*=o[f],u.push(o[f]);let c=[...jd(e.shape).map(f=>f/d),1].slice(0,s);return[u,i,d,c]}var Pa={};rt(Pa,{assertParamsValid:()=>rj,computeFlatOffset:()=>uj,computeOutShape:()=>ij,getNormalizedAxes:()=>oj,isSliceContinous:()=>lj,maskToAxes:()=>sj,parseSliceParams:()=>MR,sliceInfo:()=>cj,startForAxis:()=>RR,startIndicesWithElidedDims:()=>ER,stopForAxis:()=>DR,stopIndicesWithElidedDims:()=>AR,stridesForAxis:()=>$R,stridesWithElidedDims:()=>TR});var Pw=-2,nj=-1;function rj(e,t,a){let n=e.shape.length;U(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),U(n===a.length,()=>`Error in slice${n}D: Length of size ${a} must match the rank of the array (${n}).`);for(let r=0;r<n;++r)U(t[r]+a[r]<=e.shape[r],()=>`Error in slice${n}D: begin[${r}] + size[${r}] (${t[r]+a[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}function sj(e){let t=[],a=0;for(;e>0;)e&1&&t.push(a),e/=2,a++;return t}function ij(e,t,a){let n=[];for(let r=0;r<e.length;r++)n[r]=Math.ceil((t[r]-e[r])/a[r]);return n}function TR(e,t,a,n){let r=[...e];for(let s=r.length;s<n.length;s++)r.push(1);for(let s=0;s<a;s++)s===0?r[t]=1:(r.splice(t,0,1),r.pop());return r}function _R(e,t,a){return a<=e?a:a-(t-1)}function CR(e,t){let a=[];for(let n=0;n<e;n++)a.push(t+n);return a}function oj(e,t,a,n,r,s,i,o,u){let d=e.length,c=new Array(d),f=new Array(d),m=new Array(d);if(t.length&&a>0){let g=t[0],b=a+1;c=ER(i,g,b,n,e),f=AR(o,g,b,r,e),m=TR(s,g,b,e)}else for(let g=0;g<d;g++)c[g]=RR(i,n,s,e,g,u),f[g]=DR(o,r,s,e,g,u),m[g]=$R(s,g,u);return{begin:c,end:f,strides:m}}function ER(e,t,a,n,r){let s=[...r],i=CR(a,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let u=_R(t,a,o),d=n[u];e&1<<u&&(d=0),s[o]=d}return s}function AR(e,t,a,n,r){let s=[...r],i=CR(a,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let u=_R(t,a,o),d=n[u];e&1<<u&&(d=Number.MAX_SAFE_INTEGER),s[o]=d}for(let o=0;o<s.length;o++){let u=r[o];s[o]<0&&(s[o]+=u),s[o]=Wf(0,s[o],r[o])}return s}function $R(e,t,a){let n=e[t];return(a&1<<t||n==null)&&(n=1),n}function RR(e,t,a,n,r,s){let i=t[r],o=a[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=n[r];return i<0&&(i+=u),i=Wf(0,i,u-1),i}function DR(e,t,a,n,r,s){let i=t[r],o=a[r]||1;(e&1<<r||s&1<<r||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=n[r];return i<0&&(i+=u),o>0?i=Wf(0,i,u):i=Wf(-1,i,u-1),i}function lj(e,t,a){let n=a.length;for(let r=0;r<a.length;r++)if(a[r]>1){n=r;break}for(let r=n+1;r<a.length;r++)if(t[r]>0||a[r]!==e[r])return!1;return!0}function uj(e,t){let a=e.length>0?e[e.length-1]:1;for(let n=0;n<e.length-1;n++)a+=e[n]*t[n];return a}function MR(e,t,a){let n,r=e.shape.length;typeof t=="number"?n=[t,...new Array(r-1).fill(0)]:t.length<r?n=t.concat(new Array(r-t.length).fill(0)):n=t.slice(),n.forEach(i=>{U(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return a==null?s=new Array(r).fill(-1):typeof a=="number"?s=[a,...new Array(r-1).fill(-1)]:a.length<r?s=a.concat(new Array(r-a.length).fill(-1)):s=a,s=s.map((i,o)=>i>=0?i:(U(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-n[o])),[n,s]}function cj(e,t,a,n,r,s,i,o,u){let d;if(n==null?(d=new Array(t.length),d.fill(1)):d=n,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,f={dims:d.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:a.slice(),strides:d.slice(),beginMask:r,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};for(let S=0;S<f.dims;S++)c&&1<<S&o&&f.numAddAxisAfterEllipsis++,1<<S&i&&(c=!0);c||(f.ellipsisMask|=1<<f.dims,f.dims++);let m={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};dj(f,m);let g=!0,b=!0,v=!0,x=[],k=[];for(let S=0;S<e.length;++S){if(m.strides[S]===0)throw Error(`strides[${S}] must be non-zero`);let N=!!(m.shrinkAxisMask&1<<S),T=e[S];if(T===-1){x.push(N?1:-1);continue}let _=[m.beginMask&1<<S,m.endMask&1<<S],R=[m.strides[S]>0?0:-1,m.strides[S]>0?T:T-1];if(N&&m.strides[S]<=0)throw Error("only stride 1 allowed on non-range indexing.");v=v&&m.strides[S]===1;let M=!!(m.beginMask&1<<S&&m.endMask&1<<S);if(m.beginValid&&m.endValid){if(N){let P=m.begin[S]<0?T+m.begin[S]:m.begin[S];if(m.begin[S]=P,m.end[S]=m.begin[S]+1,P<0||P>=T)throw Error(`slice index ${m.begin[S]} of dimension ${S} out of bounds.`)}else m.begin[S]=OC(m.begin[S],0,m.strides[S],T,_,R),m.end[S]=OC(m.end[S],1,m.strides[S],T,_,R);let V=m.strides[S]===1&&m.begin[S]===0&&m.end[S]===T;g=g&&V,b=b&&(S===0&&m.strides[S]===1||V)}else g=g&&m.strides[S]===1&&M,b=b&&(S===0&&m.strides[S]===1||M);let F,B=!1;if(m.beginValid&&m.endValid?(F=m.end[S]-m.begin[S],B=!0):N?(F=1,B=!0):M&&T>=0&&(m.strides[S]<0?F=-T:F=T,B=!0),B){let V;F===0||F<0!=m.strides[S]<0?V=0:V=Math.trunc(F/m.strides[S])+(F%m.strides[S]!==0?1:0),x.push(V)}else x.push(-1)}for(let S=0;S<m.finalShapeGatherIndices.length;++S){let N=m.finalShapeGatherIndices[S];N>=0?k.push(x[N]):N===Pw&&k.push(1)}return{finalShapeSparse:k.filter((S,N)=>m.finalShapeGatherIndices[N]!==Pw),finalShape:k,isIdentity:g,sliceDim0:b,isSimpleSlice:v,begin:m.begin,end:m.end,strides:m.strides}}function dj(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let a=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let n=0;n<e.dims;n++)if(1<<n&e.ellipsisMask){let r=Math.min(t.dims-(e.dims-n)+1+e.numAddAxisAfterEllipsis,t.dims);for(;a<r;a++)t.begin[a]=0,t.end[a]=0,t.strides[a]=1,t.beginMask|=1<<a,t.endMask|=1<<a,t.finalShapeGatherIndices.push(a),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[a]=n}else if(1<<n&e.newAxisMask)t.finalShapeGatherIndices.push(Pw),t.finalShapeGatherIndicesSparse.push(-1);else{if(a===t.begin.length)throw Error(`Index out of range using input dim ${a}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[a]=e.begin[n]),e.end!=null&&(t.end[a]=e.end[n]),t.strides[a]=e.strides[n],e.beginMask&1<<n&&(t.beginMask|=1<<a),e.endMask&1<<n&&(t.endMask|=1<<a),e.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(nj),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<a):(t.finalShapeGatherIndices.push(a),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[a]=n,a++}}function OC(e,t,a,n,r,s){if(r[t])return a>0?s[t]:s[t+1&1];{let i=e<0?n+e:e;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var hj="4.22.0",FR=class{static sgd(e){return new xv(e)}static momentum(e,t,a=!1){return new tS(e,t,a)}static rmsprop(e,t=.9,a=0,n=null,r=!1){return new aS(e,t,a,n,r)}static adam(e=.001,t=.9,a=.999,n=null){return new Jk(e,t,a,n)}static adadelta(e=.001,t=.95,a=null){return new Zk(e,t,a)}static adamax(e=.002,t=.9,a=.999,n=null,r=0){return new eS(e,t,a,n,r)}static adagrad(e,t=.1){return new Qk(e,t)}},Nl=FR,pj=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function iS(){return new Promise(e=>pj(()=>e()))}var D={};rt(D,{ERF_A1:()=>Cj,ERF_A2:()=>Ej,ERF_A3:()=>Aj,ERF_A4:()=>$j,ERF_A5:()=>Rj,ERF_P:()=>_j,PARALLELIZE_THRESHOLD:()=>oS,RowPartitionType:()=>Rs,SELU_SCALE:()=>zR,SELU_SCALEALPHA:()=>OR,applyActivation:()=>bv,assertAndGetBroadcastShape:()=>Ht,assertAxesAreInnerMostDims:()=>cG,assertParamsConsistent:()=>fj,assignToTypedArray:()=>Lj,axesAreInnerMostDims:()=>bk,calculateShapes:()=>G$,checkEinsumDimSizes:()=>Gj,checkPadOnDimRoundingMode:()=>Rn,combineLocations:()=>d$,combineRaggedTensorToTensorShapes:()=>gj,complexWithEvenIndex:()=>Fj,complexWithOddIndex:()=>Oj,computeConv2DInfo:()=>Om,computeConv3DInfo:()=>a$,computeDefaultPad:()=>ek,computeDilation2DInfo:()=>lV,computeOptimalWindowSize:()=>xj,computeOutAndReduceShapes:()=>h$,computeOutShape:()=>mj,computePool2DInfo:()=>t$,computePool3DInfo:()=>uV,convertConv2DDataFormat:()=>n$,decodeEinsumEquation:()=>Wj,eitherStridesOrDilationsAreOne:()=>Gs,expandShapeToKeepDim:()=>Kl,exponent:()=>Uj,exponents:()=>Bj,fromStringArrayToUint8:()=>d8,fromUint8ToStringArray:()=>c8,getAxesPermutation:()=>p$,getBroadcastDims:()=>u$,getComplexWithIndex:()=>zj,getEinsumComputePath:()=>Hj,getEinsumPermutation:()=>Vj,getFusedBiasGradient:()=>yv,getFusedDyActivation:()=>gv,getImageCenter:()=>wj,getInnerMostAxes:()=>dG,getPermuted:()=>Sj,getRaggedRank:()=>bj,getReductionAxes:()=>Ra,getReshaped:()=>kj,getReshapedPermuted:()=>Ij,getRowPartitionTypesHelper:()=>yj,getSliceBeginCoords:()=>Nj,getSliceSize:()=>Tj,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Xj,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Yj,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Zj,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>e8,getSparseReshapeInputOutputMismatchErrorMessage:()=>a8,getSparseReshapeInputOutputMultipleErrorMessage:()=>t8,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Qj,getSparseReshapeNegativeOutputDimErrorMessage:()=>Jj,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>i8,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>n8,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>r8,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>s8,getUndoAxesPermutation:()=>vk,isIdentityPermutation:()=>qj,log:()=>xP,mergeRealAndImagArrays:()=>Dj,prepareAndValidate:()=>NR,prepareSplitSize:()=>Kj,segment_util:()=>LR,shouldFuse:()=>vv,slice_util:()=>Pa,splitRealAndImagArrays:()=>Mj,stridesOrDilationsArePositive:()=>jl,tupleValuesAreOne:()=>Io,upcastType:()=>Nr,validateDefaultValueShape:()=>vj,validateInput:()=>hv,validateUpdateShape:()=>Pk,warn:()=>ho});function fj(e,t){let a=e[0].length;e.forEach((r,s)=>{U(r.length===a,()=>`Error in concat${a}D: rank of tensors[${s}] must be the same as the rank of the rest (${a})`)}),U(t>=0&&t<a,()=>`Error in concat${a}D: axis must be between 0 and ${a-1}.`);let n=e[0];e.forEach((r,s)=>{for(let i=0;i<a;i++)U(i===t||r[i]===n[i],()=>`Error in concat${a}D: Shape of tensors[${s}] (${r}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function mj(e,t){let a=e[0].slice();for(let n=1;n<e.length;n++)a[t]+=e[n][t];return a}var Rs;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Rs||(Rs={}));function gj(e,t,a){let n=new Array;if(a==null&&t==null)return n;if(t==null)for(;n.length<e+a.length;)n.push(-1);else n=t.slice();if(a==null)return n;if(e+a.length!==n.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+a.length}, but shape.rank = ${n.length}`);for(let r=1;r<a.length;++r){let s=a[r],i=n[n.length-a.length+r],o=n[i];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${s} but shape[${r+e}] = ${o}`)}else n[i]=s}return n}function yj(e){let t={FIRST_DIM_SIZE:Rs.FIRST_DIM_SIZE,VALUE_ROWIDS:Rs.VALUE_ROWIDS,ROW_LENGTHS:Rs.ROW_LENGTHS,ROW_SPLITS:Rs.ROW_SPLITS,ROW_LIMITS:Rs.ROW_LIMITS,ROW_STARTS:Rs.ROW_STARTS},a=[];for(let n of e)if(n in t)a.push(t[n]);else break;return a}function bj(e){return e.length===0?0:e[0]===Rs.FIRST_DIM_SIZE?e.length-1:e.length}function vj(e,t){if(e==null||t==null)return;let a=e.length,n=t.length;if(a>=n)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${a} must be less than ragged tensor input flatValues.rank = ${n})`);for(let r=0;r<Math.min(a,n-1);++r){let s=e[r],i=t[r+1];if(s>=0&&i>=0&&s!==1&&s!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${s} but ragged tensor input.flatValues.shape[${r-e.length}] = ${i}`)}}var oS=30;function xj(e){return e<=oS?e:Ky(e,Math.floor(Math.sqrt(e)))}function wj(e,t,a){let n=a*(typeof e=="number"?e:e[0]),r=t*(typeof e=="number"?e:e[1]);return[n,r]}function kj(e,t,a,n=!0){let r=[];if(n)r=r.concat(t.slice(0)),r.push(e[0]/a),r=r.concat(e.slice(1));else{r=r.concat(e[0]);let s=t.length;for(let i=0;i<s;++i)r=r.concat([e[i+1]/t[i],t[i]]);r=r.concat(e.slice(s+1))}return r}function Sj(e,t,a=!0){let n=[];if(a){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{let r=[],s=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?s.push(i):r.push(i);n.push(...r),n.push(0),n.push(...s)}return n}function Ij(e,t,a,n=!0){let r=[];n?r.push(e[0]/a):r.push(e[0]*a);for(let s=1;s<e.length;++s)s<=t.length?n?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function Nj(e,t){let a=[0];for(let n=0;n<t;++n)a.push(e[n][0]);return a}function Tj(e,t,a){let n=e.slice(0,1);for(let r=0;r<a;++r)n.push(e[r+1]-t[r][0]-t[r][1]);return n}var OR=1.7580993408473768,zR=1.0507009873554805,_j=.3275911,Cj=.254829592,Ej=-.284496736,Aj=1.421413741,$j=-1.453152027,Rj=1.061405429;function Dj(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let a=new Float32Array(e.length*2);for(let n=0;n<a.length;n+=2)a[n]=e[n/2],a[n+1]=t[n/2];return a}function Mj(e){let t=new Float32Array(e.length/2),a=new Float32Array(e.length/2);for(let n=0;n<e.length;n+=2)t[n/2]=e[n],a[n/2]=e[n+1];return{real:t,imag:a}}function Fj(e){let t=Math.ceil(e.length/4),a=new Float32Array(t),n=new Float32Array(t);for(let r=0;r<e.length;r+=4)a[Math.floor(r/4)]=e[r],n[Math.floor(r/4)]=e[r+1];return{real:a,imag:n}}function Oj(e){let t=Math.floor(e.length/4),a=new Float32Array(t),n=new Float32Array(t);for(let r=2;r<e.length;r+=4)a[Math.floor(r/4)]=e[r],n[Math.floor(r/4)]=e[r+1];return{real:a,imag:n}}function zj(e,t){let a=e[t*2],n=e[t*2+1];return{real:a,imag:n}}function Lj(e,t,a,n){e[n*2]=t,e[n*2+1]=a}function Bj(e,t){let a=new Float32Array(e/2),n=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){let s=(t?2:-2)*Math.PI*(r/e);a[r]=Math.cos(s),n[r]=Math.sin(s)}return{real:a,imag:n}}function Uj(e,t,a){let n=(a?2:-2)*Math.PI*(e/t),r=Math.cos(n),s=Math.sin(n);return{real:r,imag:s}}var lw="->",Pj=/->/g,zC=",",LC="...";function Wj(e,t){e=e.replace(/\s/g,"");let a=(e.length-e.replace(Pj,"").length)/lw.length;if(a<1)throw new Error("Equations without an arrow are not supported.");if(a>1)throw new Error(`Equation must contain exactly one arrow ("${lw}").`);let[n,r]=e.split(lw);U(n.indexOf(LC)===-1,()=>`The ellipsis notation ("${LC}") is not supported yet.`);let s=n.split(zC),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let m=0;m<r.length;++m){let g=r[m];if(!s.some(b=>b.indexOf(g)!==-1))throw new Error(`Output subscripts contain the label ${g} not present in the input subscripts.`);o.indexOf(g)===-1&&o.push(g)}for(let m=0;m<n.length;++m){let g=n[m];o.indexOf(g)===-1&&g!==zC&&o.push(g)}let u=new Array(s.length);for(let m=0;m<i;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let g=0;g<s[m].length;++g)u[m].push(o.indexOf(s[m][g]))}let d=o.length,c=r.length,f=[];for(let m=c;m<d;++m)f.push(m);return{allDims:o,summedDims:f,idDims:u}}function Vj(e,t){let a=new Array(e);a.fill(-1);for(let r=0;r<t.length;++r)a[t[r]]=r;let n=[];for(let r=0;r<e;++r)a[r]===-1&&n.push(r);return a=a.filter(r=>r!==-1),{permutationIndices:a,expandDims:n}}function Gj(e,t,a){let n=new Array(e);for(let r=0;r<a.length;++r){let s=a[r].shape;for(let i=0;i<t[r].length;++i)n[t[r][i]]===void 0?n[t[r][i]]=s[i]:U(n[t[r][i]]===s[i],()=>`Expected dimension ${n[t[r][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function Hj(e,t){let a=e,n=[],r=0;e.length===0&&a.push(-1),r=e.length+1;for(let i=0;i<r;++i)n.push([]);let s=[];for(let i=0;i<a.length;++i){let o=a[i],u=jj(t,o);for(let d of u)s.indexOf(d)===-1&&(n[i].push(d),s.push(d))}return{path:a,steps:n}}function qj(e){return e.every((t,a)=>t===a)}function jj(e,t){let a=[];for(let n=0;n<e.length;++n)(e[n].length===0||e[n].indexOf(t)!==-1||t===-1)&&a.push(n);return a}function Kj(e,t,a=0){let n=[];if(typeof t=="number")U(e.shape[a]%t===0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(e.shape[a]/t);else{let r=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);U(r<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let i=t.reduce((o,u)=>u>0?o+u:o);t[s]=e.shape[a]-i}U(e.shape[a]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function Xj(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function Yj(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function Zj(e,t,a){return`indices(${e}, 0) is invalid: ${t} >= ${a}`}function Qj(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Jj(e,t){return`size ${e} must be non-negative, not ${t}`}function e8(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function t8(e,t){let a=zt(e),n=zt(t);return`Input to reshape is a SparseTensor with ${a}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${e} outputShape= ${t}`}function a8(e,t){let a=zt(e),n=zt(t);return`Input to reshape is a tensor with ${a} dense values, but the requested shape has ${n}. inputShape=${e} outputShape=${t}`}function n8(){return"segment ids must be >= 0"}function r8(){return"segment ids are not increasing"}function s8(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function i8(e,t,a){return`Bad: indices[${e}] == ${t} out of range [0, ${a})`}var LR={};rt(LR,{collectGatherOpShapeInfo:()=>u8,computeOutShape:()=>l8,segOpComputeOptimalWindowSize:()=>o8});function o8(e,t){let a=!1,n;for(e<=oS?(n=e,a=!0):n=Ky(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=Ky(e,n+1);return n}function l8(e,t,a){let n=[],r=e.length;for(let s=0;s<r;s++)s!==t?n.push(e[s]):n.push(a);return n}function u8(e,t,a,n){let r=t.shape.length,s=e.shape.length;if(n!==0&&(n<-r||n>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${n}`);if(n<0&&(n+=r),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(a<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${a}).`);for(let f=0;f<n;++f)if(e.shape[f]!==t.shape[f])throw new Error(`x.shape[${f}]: ${e.shape[f]} should be equal to indices.shape[${f}]: ${t.shape[f]}.`);let i=e.shape[a],o=[],u=1,d=1,c=1;for(let f=0;f<n;++f)o.push(e.shape[f]),u*=e.shape[f];for(let f=n;f<a;f++)o.push(e.shape[f]),d*=e.shape[f];for(let f=n;f<r;f++)o.push(t.shape[f]);for(let f=a+1;f<s;f++)o.push(e.shape[f]),c*=e.shape[f];return{batchSize:u,sliceSize:c,outerSize:d,dimSize:i,outputShape:o}}function c8(e){try{return e.map(t=>Zy(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function d8(e){return e.map(t=>Dm(t))}var qs={};rt(qs,{nonMaxSuppressionV3Impl:()=>rR,nonMaxSuppressionV4Impl:()=>sR,nonMaxSuppressionV5Impl:()=>iR,whereImpl:()=>j$});Cq();var BR={kernelName:Kd,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(e,_c(Te(a,"float32"),-1))}}},h8={kernelName:iu,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>{let n=Vt(Te(a,"float32")),r=en($e(We(1),n));return ta(Fe(e,r))}}}},p8={kernelName:ou,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>{let n=en($e(Vt(Te(a,"float32")),1));return Fe(e,n)}}}},f8={kernelName:Oo,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t,r=Ht(a.shape,n.shape);return{a:()=>{let s=e,i=Ra(a.shape,r);return i.length>0&&(s=ze(s,i)),te(s,a.shape)},b:()=>{let s=e,i=Ra(n.shape,r);return i.length>0&&(s=ze(s,i)),te(s,n.shape)}}}},m8={kernelName:lu,saveAllInputs:!0,gradFunc:(e,t)=>{let a={};return t.forEach((n,r)=>{a[r]=()=>e.clone()}),a}},g8={kernelName:Zd,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>St(a)}}},y8={kernelName:Qd,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>St(a)}}},b8={kernelName:uu,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Fe(e,en($e(We(1),Vt(Te(a,"float32")))))}}},v8={kernelName:cu,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>{let n=en(ge(We(1),Vt(Te(a,"float32"))));return Fe(e,n)}}}},x8={kernelName:pu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t,r=Ht(a.shape,n.shape);return{a:()=>{let s=ge(Vt(a),Vt(n)),i=Z(e,Fe(n,s)),o=Ra(a.shape,r);return o.length>0&&(i=ze(i,o)),te(i,a.shape)},b:()=>{let s=ge(Vt(a),Vt(n)),i=ta(Z(e,Fe(a,s))),o=Ra(n.shape,r);return o.length>0&&(i=ze(i,o)),te(i,n.shape)}}}},w8={kernelName:du,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Fe(e,ge(Vt(Te(a,"float32")),1))}}},k8={kernelName:hu,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Fe(e,$e(We(1),Vt(Te(a,"float32"))))}}};function S8(e,t,a,n,r,s){let i=O(e,"dy","avgPool3dGrad"),o=O(t,"input","avgPool3dGrad"),u=i,d=o,c=!1;o.rank===4&&(c=!0,u=te(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=te(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),U(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),U(d.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Rn("avgPool3dGrad",r,s);let f={dy:u,input:d},m={filterSize:a,strides:n,pad:r,dimRoundingMode:s},g=j.runKernel(dm,f,m);return c?te(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var I8=K({avgPool3dGrad_:S8}),N8={kernelName:Jd,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,{filterSize:r,strides:s,pad:i,dimRoundingMode:o}=a;return{x:()=>I8(e,n,r,s,i,o)}}};function T8(e,t,a,n,r){let s=O(e,"dy","avgPoolGrad"),i=O(t,"input","avgPoolGrad");U(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let o=i,u=s,d=!1;i.rank===3&&(d=!0,o=te(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=te(s,[1,s.shape[0],s.shape[1],s.shape[2]])),U(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),U(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let c={dy:u,input:o},f={filterSize:a,strides:n,pad:r},m=j.runKernel(cm,c,f);return d?te(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var _8=K({avgPoolGrad_:T8}),C8={kernelName:fu,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,{filterSize:r,strides:s,pad:i}=a;return{x:()=>_8(e,n,r,s,i)}}},E8={kernelName:mu,inputsToSave:["a","b"],gradFunc:(e,t,a)=>{let[n,r]=t,{transposeA:s,transposeB:i}=a;return!s&&!i?{a:()=>lt(e,r,!1,!0),b:()=>lt(n,e,!0,!1)}:!s&&i?{a:()=>lt(e,r,!1,!1),b:()=>lt(e,n,!0,!1)}:s&&!i?{a:()=>lt(r,e,!1,!0),b:()=>lt(n,e,!1,!1)}:{a:()=>lt(r,e,!0,!0),b:()=>lt(e,n,!0,!0)}}},A8={kernelName:eh,gradFunc:(e,t,a)=>{let{blockShape:n,crops:r}=a;return{x:()=>Hm(e,n,r)}}},$8={kernelName:IA,gradFunc:(e,t,a)=>{let n=a,r=n.inputShape,s=n.shape,i=Array.from(s);for(let u=r.length-1;u>=0;u--)if(r[u]===s[u])i[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${s}].`);let o=[];for(let u=0;u<i.length;u++)i[u]>1&&o.push(u);return{x:()=>ze(e,o,!0)}}},R8={kernelName:gu,gradFunc:e=>({x:()=>e.clone()})},D8={kernelName:yu,gradFunc:e=>({x:()=>St(e)})},M8={kernelName:zo,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,{clipValueMin:r,clipValueMax:s}=a;return{x:()=>Ja(Gr(Ti(n,r),Po(n,s)),e,St(e))}}},F8={kernelName:pm,inputsToSave:["x"],gradFunc:BR.gradFunc},O8={kernelName:nh,saveAllInputs:!0,gradFunc:(e,t,a)=>{let n=t.map(o=>o.shape),{axis:r}=a,s=qr(r,t[0].shape)[0],i=n.map(o=>o[s]);return Wn(e,i,s).map(o=>()=>o)}},z8={kernelName:bu,inputsToSave:["x","filter"],gradFunc:(e,t,a)=>{let[n,r]=t,{dilations:s,strides:i,pad:o,dataFormat:u}=a;return U(Io(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>dk(n.shape,e,r,i,o,u),filter:()=>Kk(n,e,r.shape,i,o,u)}}},L8={kernelName:vu,inputsToSave:["dy","filter"],gradFunc:(e,t,a)=>{let[n,r]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:u}=a;return{dy:()=>Cn(e,r,s,i,o,1,u),filter:()=>Kk(e,n,r.shape,s,i,o,u)}}};function B8(e,t,a,n,r){let s=e;e.rank===4&&(s=te(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=te(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),U(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),U(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),U(a.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${a}.`),U(s.shape[4]===a[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${a[3]}.`),U(i.shape[4]===a[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${a[4]}).`);let o={x:s,dy:i},u={strides:n,pad:r,filterShape:a};return j.runKernel(rh,o,u)}var U8=K({conv3DBackpropFilter_:B8}),P8={kernelName:xu,inputsToSave:["x","filter"],gradFunc:(e,t,a)=>{let{dilations:n,strides:r,pad:s}=a;U(Io(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[i,o]=t;return{x:()=>o$(i.shape,e,o,r,s),filter:()=>U8(i,e,o.shape,r,s)}}},W8={kernelName:wu,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(ta(sv(Te(a,"float32"))),e)}}},V8={kernelName:ku,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(iv(Te(a,"float32")),e)}}},G8={kernelName:Su,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,{axis:r,exclusive:s,reverse:i}=a;return{x:()=>{let o=p$([r],n.rank),u=jb(e,r,s,!i);return o!=null&&(u=ut(u,o)),u}}}},H8={kernelName:Iu,inputsToSave:["x","filter"],gradFunc:(e,t,a)=>{let{dilations:n,strides:r,pad:s,dimRoundingMode:i}=a,o=n??[1,1];U(Io(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[u,d]=t;return U(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),U(d.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${d.rank}.`),U(u.shape[3]===d.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),U(Gs(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Rn("depthwiseConv2d",s,i),{x:()=>tR(u.shape,e,d,r,s,o,i),filter:()=>eR(u,e,d.shape,r,s,o,i)}}},q8={kernelName:Nu,inputsToSave:["x","filter"],gradFunc:(e,t,a)=>{let[n,r]=t,s={x:n,filter:r,dy:e},i={x:n,filter:r,dy:e};return{x:()=>j.runKernel(Ad,s,a),filter:()=>j.runKernel($d,i,a)}}},j8={kernelName:_u,outputsToSave:[!0],gradFunc:(e,t)=>{let[a]=t,n={dy:e,y:a};return{x:()=>j.runKernel(uh,n)}}},K8={kernelName:Cu,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t,n=Z(bn(ta(Vt(a))),2/Math.sqrt(Math.PI));return{x:()=>Z(e,n)}}},X8={kernelName:Eu,outputsToSave:[!0],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(e,a)}}},Y8={kernelName:dh,inputsToSave:["input"],gradFunc:(e,t)=>{let[a]=t;return{input:()=>te(e,a.shape)}}},Z8={kernelName:Au,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(e,bn(a))}}},Q8={kernelName:$u,gradFunc:e=>({x:()=>St(e)})},J8={kernelName:Ru,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t,r=Ht(a.shape,n.shape);return{a:()=>{let s=Fe(e,Te(n,"float32")),i=Ra(a.shape,r);return i.length>0?te(ze(s,i),a.shape):s},b:()=>{let s=Z(e,Te(a,"float32")),i=Ra(n.shape,r);i.length>0&&(s=te(ze(s,i),n.shape));let o=Vt(n);return ta(Fe(s,Te(o,"float32")))}}}},eK={kernelName:Du,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,a)=>{let{varianceEpsilon:n}=a,[r,s,i,o]=t,u=o??We(1),d=Ra(s.shape,r.shape),c=[];if(s.rank===1){for(let v=0;v<r.shape.length-1;++v)c.push(r.shape[v]);c.push(1)}let f=$e(r,s),m=Z(e,u),g=nv(ge(i,We(n))),b=Z(Z(Z(g,g),g),We(-.5));return{x:()=>s.rank===1?te(Z(Z(e,sr(te(g,[1,1,1,s.shape[0]]),c)),u),r.shape):te(Z(Z(e,g),u),r.shape),mean:()=>{let v=Z(Z(g,We(-1)),m);return s.rank===1&&(v=ze(v,d)),te(v,s.shape)},variance:()=>{let v=Z(Z(b,f),m);return s.rank===1&&(v=ze(v,d)),te(v,s.shape)},scale:()=>{let v=Z(f,g),x=Z(e,v);return s.rank===1&&(x=ze(x,d)),te(x,s.shape)},offset:()=>{let v=e;return s.rank===1&&(v=ze(v,d)),te(v,s.shape)}}}},tK={kernelName:ph,inputsToSave:["x","indices"],gradFunc:(e,t,a)=>{let[n,r]=t,{axis:s,batchDims:i}=a,o=qr(s,n.shape)[0],u=(d,c,f)=>()=>{let m=d.shape,g=c.size,b=m.slice(0,o),v=b.length,x=m.slice(s,m.length).slice(1),k=x.length,S=BC(0,v),N=BC(v+1,v+1+k),T=UC([b,[g],x]),_=te(f,T),R=te(c,[g]),M=UC([[v],S,N]),F=ut(_,M),B=fv(F,R,d.shape[o]),V=vk(M);return B=ut(B,V),B};if(i===1){let d=n.shape[0],c=n.split(d,0);return{x:()=>$a(c.map((f,m)=>u(f,r.slice(m,1),e.slice(m,1))())).reshape(n.shape),indices:()=>r}}else return{x:u(n,r,e),indices:()=>r}}};function BC(e,t){let a=[];for(let n=e;n<t;++n)a.push(n);return a}function UC(e){let t=[];for(let a=0;a<e.length;++a)for(let n=0;n<e[a].length;++n)t.push(e[a][n]);return t}var aK={kernelName:Mu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t;return{a:()=>St(a),b:()=>St(n)}}},nK={kernelName:Fu,gradFunc:e=>({x:()=>Te(e,"float32")})},rK={kernelName:Ou,gradFunc:e=>({x:()=>St(e)})},sK={kernelName:zu,gradFunc:e=>({x:()=>St(e)})},iK={kernelName:Lu,gradFunc:e=>({x:()=>St(e)})},oK={kernelName:Bu,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,{alpha:r}=a,s=Dn(n,0);return{x:()=>Ja(s,e,Z(e,r))}}},lK={kernelName:Pu,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Fe(e,ge(a,1))}}},uK={kernelName:Uu,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Fe(e,Te(a,"float32"))}}},cK={kernelName:TA,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,a)=>{let[n]=t,{axis:r}=a;return{logits:()=>{let s=bn(n);return $e(e,Z(ze(e,r,!0),s))}}}};function dK(e,t,a,n=5,r=1,s=1,i=.5){let o={x:e,y:t,dy:a},u={depthRadius:n,bias:r,alpha:s,beta:i};return j.runKernel(kh,o,u)}var hK=K({localResponseNormalizationBackprop_:dK}),pK={kernelName:Wu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,a)=>{let[n,r]=t,{depthRadius:s,bias:i,alpha:o,beta:u}=a;return{x:()=>hK(n,r,e,s,i,o,u)}}};function UR(e,t,a,n){return t.rank<a.rank&&(t=te(t,Kl(t.shape,n))),e.rank<a.rank&&(e=te(e,Kl(e.shape,n))),{x:()=>Z(e,Te(or(a,t),e.dtype))}}var PC={kernelName:Vu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,a)=>{let n=a,{reductionIndices:r}=n,s=t[0],i=t[1],o=qr(r,s.shape),u=UR(e,i,s,o);return{x:()=>u.x()}}},fK={kernelName:Gu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t;return{a:()=>Z(e,Te(Ti(a,n),"float32")),b:()=>Z(e,Te(Md(a,n),"float32"))}}};function mK(e,t,a,n,r,s,i){let o=O(e,"dy","maxPool3dGrad"),u=O(t,"input","maxPool3dGrad"),d=O(a,"output","maxPool3dGrad"),c=o,f=u,m=d,g=!1;u.rank===4&&(g=!0,c=te(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),f=te(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=te(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),U(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),U(f.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${f.rank}.`),U(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Rn("maxPool3dGrad",s,i);let b={dy:c,input:f,output:m},v={filterSize:n,strides:r,pad:s,dimRoundingMode:i},x=j.runKernel(bm,b,v);return g?te(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}var gK=K({maxPool3dGrad_:mK}),yK={kernelName:Sh,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,a)=>{let[n,r]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=a;return{x:()=>gK(e,n,r,s,i,o,u)}}};function bK(e,t,a,n,r,s,i){let o=O(e,"dy","maxPoolGrad"),u=O(t,"input","maxPoolGrad"),d=O(a,"output","maxPoolGrad");U(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),U(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),U(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Rn("maxPoolGrad",s,i);let c={dy:o,input:u,output:d},f={filterSize:n,strides:r,pad:s,dimRoundingMode:i};return j.runKernel(ym,c,f)}var vK=K({maxPoolGrad_:bK}),xK={kernelName:Hu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,a)=>{let[n,r]=t,{filterSize:s,strides:i,pad:o}=a;return{x:()=>vK(e,n,r,s,i,o)}}},wK={kernelName:qu,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,{axis:r}=a,s=qr(r,n.shape),i=h$(n.shape,s)[1],o=zt(i);return{x:()=>{let u=n.shape.slice();s.forEach(c=>{u[c]=1});let d=te(e,u);return Fe(Z(d,Pn(n.shape,"float32")),o)}}}},kK={kernelName:ju,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,a)=>{let n=a,{axis:r}=n,[s,i]=t,o=qr(r,s.shape),u=UR(e,i,s,o);return{x:()=>u.x()}}},SK={kernelName:Ku,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t;return{a:()=>Z(e,Te(Po(a,n),"float32")),b:()=>Z(e,Te(Dn(a,n),"float32"))}}},IK={kernelName:Xu,inputsToSave:["x"],gradFunc:(e,t,a)=>{let n=t[0],{paddings:r}=a,s=r.map(i=>i[0]);return{x:()=>bt(e,s,n.shape)}}},NK={kernelName:Yu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t,r=Ht(a.shape,n.shape);return{a:()=>{let s=Ra(a.shape,r);return s.length>0?te(ze(e,s),a.shape):e},b:()=>{let s=Z(e,ta(Jh(Fe(a,n)))),i=Ra(n.shape,r);return i.length>0?te(ze(s,i),n.shape):s}}}},TK={kernelName:Zu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t,r=Ht(a.shape,n.shape);return{a:()=>{let s=Z(e,Te(n,"float32")),i=Ra(a.shape,r);return i.length>0?te(ze(s,i),a.shape):s},b:()=>{let s=Z(e,Te(a,"float32")),i=Ra(n.shape,r);return i.length>0?te(ze(s,i),n.shape):s}}}},_K={kernelName:Nh,gradFunc:e=>({x:()=>ta(e)})},CK={kernelName:Qu,inputsToSave:["indices"],gradFunc:(e,t)=>{let a=t[0];return{indices:()=>da(a.shape,"float32")}}},EK={kernelName:Ah,gradFunc:e=>({x:()=>St(e)})},AK={kernelName:$h,saveAllInputs:!0,gradFunc:(e,t,a)=>{let{axis:n}=a;return ya(e,n).map(r=>()=>r)}},WC={kernelName:Ju,inputsToSave:["x"],gradFunc:(e,t,a)=>{let n=t[0],{paddings:r}=a,s=r.map(i=>i[0]);return{x:()=>bt(e,s,n.shape)}}},$K={kernelName:ec,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[a,n,r]=t,s=a,i=n,o=Ht(s.shape,i.shape);return{a:()=>{let u=Te(i,"float32"),d=Z(e,Z(u,Ps(s,$e(u,We(1))))),c=Ra(s.shape,o);return c.length>0&&(d=ze(d,c)),te(d,s.shape)},b:()=>{let u=Dn(s,0),d=Ja(u,lr(s),St(s)),c=Z(e,Z(r,d)),f=Ra(i.shape,o);return f.length>0&&(c=ze(c,f)),te(c,i.shape)}}}},RK={kernelName:tc,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[a,n]=t,r=Dn(a,0);return{x:()=>Ja(r,e,Z(e,n)),alpha:()=>{let s=Ja(r,St(e),Z(e,a)),i=Ra(n.shape,e.shape);return i.length>0&&(s=ze(s,i)),te(s,n.shape)}}}};function DK(e,t,a){let n=e.shape.slice();n[a]=1;let r=te(t,n),s=Yf(e,a,!0,!1),i=Yf(e,a,!0,!0),o=Z(s,i);return Z(r,o)}function MK(e,t,a){let n=e.shape.length,r=n-a.length,s=D.getAxesPermutation(a,n),i=e;s!=null&&(i=ut(e,s));let o=i.shape.slice(),u=o.splice(n-a.length,a.length).reduce((f,m)=>f*m,1);o.push(u);let d=i.reshape(o),c=DK(d,t,r);if(c=c.reshape(i.shape),s!=null){let f=D.getUndoAxesPermutation(s);c=ut(c,f)}return c}var FK={kernelName:ac,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,{axis:r}=a,s=[];return r==null?s=n.shape.map((i,o)=>o):typeof r=="number"?s=[r]:s=r,{x:()=>MK(n,e,s)}}},OK={kernelName:Tu,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t,r=Ht(a.shape,n.shape);return{a:()=>{let s=Fe(e,Te(n,"float32")),i=Ra(a.shape,r);return i.length>0?te(ze(s,i),a.shape):s},b:()=>{let s=Z(e,Te(a,"float32")),i=Ra(n.shape,r);i.length>0&&(s=te(ze(s,i),n.shape));let o=Vt(n);return ta(Fe(s,Te(o,"float32")))}}}},zK={kernelName:nc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Fe(e,ta(Vt(a)))}}},LK={kernelName:oc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t,n=Z(Po(a,6),_c(a));return{x:()=>Z(e,Te(n,"float32"))}}},BK={kernelName:rc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(e,Te(_c(a),"float32"))}}},UK={kernelName:Rh,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>te(e,a.shape)}}},PK={kernelName:ic,inputsToSave:["images"],gradFunc:(e,t,a)=>{let[n]=t,r={dy:e,images:n};return{images:()=>j.runKernel(Mh,r,a)}}},WK={kernelName:sc,inputsToSave:["images"],gradFunc:(e,t,a)=>{let[n]=t,r={dy:e,images:n};return{images:()=>j.runKernel(Dh,r,a)}}},VK={kernelName:lc,gradFunc:(e,t,a)=>{let{dims:n}=a,r=qr(n,e.shape);return{x:()=>_r(e,r)}}},GK={kernelName:uc,gradFunc:e=>({x:()=>St(e)})},HK={kernelName:cc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>ta(Fe(e,Z(Ps(a,1.5),2)))}}},qK={kernelName:Lh,inputsToSave:["condition"],gradFunc:(e,t)=>{let[a]=t;return{condition:()=>Te(St(a),"float32"),t:()=>Z(e,Te(a,e.dtype)),e:()=>Z(e,Te(Vm(a),e.dtype))}}},jK={kernelName:dc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>{let n=Dn(a,We(0)),r=We(OR),s=We(zR),i=Z(e,s),o=Z(Z(e,r),bn(Te(a,"float32")));return Ja(n,i,o)}}}},KK={kernelName:mc,outputsToSave:[!0],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(e,Z(a,$e(We(1),a)))}}},XK={kernelName:fc,gradFunc:e=>({x:()=>St(e)})},YK={kernelName:hc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(Lm(Te(a,"float32")),e)}}},ZK={kernelName:pc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(qb(Te(a,"float32")),e)}}},QK={kernelName:Bh,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,{begin:r,size:s}=a,i=n.shape,[o,u]=MR(n,r,s),d=[];for(let c=0;c<e.rank;c++)d.push([o[c],i[c]-o[c]-u[c]]);return{x:()=>ms(e,d)}}},JK={kernelName:vc,outputsToSave:[!0],gradFunc:(e,t,a)=>{let[n]=t,{dim:r}=a,s=!0,i=Z(e,n);return{logits:()=>$e(i,Z(ze(i,[r],s),n))}}},e7={kernelName:gc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(e,Vr(a))}}},VC={kernelName:Uh,gradFunc:(e,t,a)=>{let{blockShape:n,paddings:r}=a;return{x:()=>zm(e,n,r)}}},GC={kernelName:Ph,gradFunc:(e,t,a)=>{let{axis:n}=a;return{x:()=>Gt(e,n)}}},t7={kernelName:yc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Fe(e,Z(en(Te(a,"float32")),2))}}},a7={kernelName:Im,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z(e,Z(Te(a,"float32"),2))}}},n7={kernelName:xc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t,r=We(2);return{a:()=>Z(e,Z(r,$e(a,n))),b:()=>Z(e,Z(r,$e(n,a)))}}},r7={kernelName:Bo,gradFunc:e=>({x:()=>St(e)})},s7={kernelName:wc,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[a,n]=t,r=Ht(a.shape,n.shape);return{a:()=>{let s=e,i=Ra(a.shape,r);return i.length>0&&(s=ze(s,i)),te(s,a.shape)},b:()=>{let s=e,i=Ra(n.shape,r);return i.length>0&&(s=ze(s,i)),te(ta(s),n.shape)}}}},i7={kernelName:bc,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,r=n.shape.slice(),{axis:s}=a;qr(s,n.shape).forEach(u=>{r[u]=1});let i=te(e,r),o=Z(i,Pn(n.shape,"float32"));return{x:()=>o}}},o7={kernelName:kc,inputsToSave:["x"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Fe(e,Vt(Lm(a)))}}},l7={kernelName:Sc,outputsToSave:[!0],gradFunc:(e,t)=>{let[a]=t;return{x:()=>Z($e(We(1),Vt(a)),e)}}},u7={kernelName:Lo,inputsToSave:["x"],gradFunc:(e,t,a)=>{let[n]=t,{reps:r}=a;return{x:()=>{let s=St(n);if(n.rank===1)for(let i=0;i<r[0];++i)s=ge(s,bt(e,[i*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)s=ge(s,bt(e,[i*n.shape[0],o*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let u=0;u<r[2];++u)s=ge(s,bt(e,[i*n.shape[0],o*n.shape[1],u*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let i=0;i<r[0];++i)for(let o=0;o<r[1];++o)for(let u=0;u<r[2];++u)for(let d=0;d<r[3];++d)s=ge(s,bt(e,[i*n.shape[0],o*n.shape[1],u*n.shape[2],d*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return s}}}},c7={kernelName:yi,gradFunc:(e,t,a)=>{let n=a,{perm:r}=n,s=vk(r);return{x:()=>ut(e,s)}}},d7={kernelName:jh,gradFunc:(e,t,a)=>{let n=a,{axis:r}=n;return{value:()=>$a(e,r)}}},h7={kernelName:Am,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[a]=t;return{x:()=>p7(e,a)}}};function p7(e,t){let a=Hs(t,St(t)),n=ep(e,a),r=Ti(t,We(0,"int32")),s=n.rank-r.rank;for(let o=0;o<s;++o)r=Za(r,o+1);r=Gr(r,Pn(n.shape,"bool"));let i=St(n);return Ja(r,n,i)}var f7={kernelName:Kh,gradFunc:e=>({x:()=>St(e)})},m7=[BR,h8,p8,f8,m8,g8,y8,b8,v8,x8,w8,k8,N8,C8,E8,A8,$8,R8,D8,M8,F8,O8,L8,z8,P8,W8,V8,G8,H8,q8,OK,j8,K8,X8,Y8,Z8,J8,Q8,eK,tK,aK,nK,rK,sK,iK,oK,lK,uK,cK,pK,PC,PC,fK,yK,xK,wK,kK,SK,IK,NK,TK,_K,CK,EK,AK,WC,WC,$K,RK,FK,zK,LK,BK,UK,PK,WK,VK,GK,HK,qK,jK,KK,XK,YK,ZK,QK,JK,e7,VC,VC,GC,GC,t7,n7,a7,r7,s7,i7,o7,l7,u7,c7,d7,h7,f7];for(let e of m7)_A(e);be().prototype.abs=function(){return this.throwIfDisposed(),Ca(this)};be().prototype.acos=function(){return this.throwIfDisposed(),q1(this)};be().prototype.acosh=function(){return this.throwIfDisposed(),j1(this)};be().prototype.add=function(e){return this.throwIfDisposed(),ge(this,e)};be().prototype.all=function(e,t){return this.throwIfDisposed(),Vb(this,e,t)};be().prototype.any=function(e,t){return this.throwIfDisposed(),jf(this,e,t)};be().prototype.argMax=function(e){return this.throwIfDisposed(),ql(this,e)};be().prototype.argMin=function(e){return this.throwIfDisposed(),K1(this,e)};be().prototype.asScalar=function(){return this.throwIfDisposed(),U(this.size===1,()=>"The array must have only 1 element."),te(this,[])};be().prototype.asType=function(e){return this.throwIfDisposed(),Te(this,e)};be().prototype.as1D=function(){return this.throwIfDisposed(),te(this,[this.size])};be().prototype.as2D=function(e,t){return this.throwIfDisposed(),te(this,[e,t])};be().prototype.as3D=function(e,t,a){return this.throwIfDisposed(),te(this,[e,t,a])};be().prototype.as4D=function(e,t,a,n){return this.throwIfDisposed(),te(this,[e,t,a,n])};be().prototype.as5D=function(e,t,a,n,r){return this.throwIfDisposed(),te(this,[e,t,a,n,r])};be().prototype.asin=function(){return this.throwIfDisposed(),X1(this)};be().prototype.asinh=function(){return this.throwIfDisposed(),Y1(this)};be().prototype.atan=function(){return this.throwIfDisposed(),Z1(this)};be().prototype.atan2=function(e){return this.throwIfDisposed(),Q1(this,e)};be().prototype.atanh=function(){return this.throwIfDisposed(),J1(this)};be().prototype.avgPool=function(e,t,a,n){return this.throwIfDisposed(),Ni(this,e,t,a,n)};be().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),zm(this,e,t)};be().prototype.batchNorm=function(e,t,a,n,r){return this.throwIfDisposed(),Ic(this,e,t,a,n,r)};be().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Ml(this,e)};be().prototype.cast=function(e){return this.throwIfDisposed(),Te(this,e)};be().prototype.ceil=function(){return this.throwIfDisposed(),ik(this)};be().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),yn(this,e,t)};be().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof ht&&(e=[e]),Gt([this,...e],t)};be().prototype.conv1d=function(e,t,a,n,r,s){return this.throwIfDisposed(),Gb(this,e,t,a,n,r,s)};be().prototype.conv2dTranspose=function(e,t,a,n,r){return this.throwIfDisposed(),Hb(this,e,t,a,n,r)};be().prototype.conv2d=function(e,t,a,n,r,s){return this.throwIfDisposed(),Cn(this,e,t,a,n,r,s)};be().prototype.cos=function(){return this.throwIfDisposed(),Lm(this)};be().prototype.cosh=function(){return this.throwIfDisposed(),qb(this)};be().prototype.cumprod=function(e,t,a){return this.throwIfDisposed(),Yf(this,e,t,a)};be().prototype.cumsum=function(e,t,a){return this.throwIfDisposed(),jb(this,e,t,a)};be().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),fk(this,e,t)};be().prototype.depthwiseConv2d=function(e,t,a,n,r,s){return this.throwIfDisposed(),Nc(this,e,t,a,n,r,s)};be().prototype.dilation2d=function(e,t,a,n,r){return this.throwIfDisposed(),mk(this,e,t,a,n,r)};be().prototype.divNoNan=function(e){return this.throwIfDisposed(),gk(this,e)};be().prototype.div=function(e){return this.throwIfDisposed(),Fe(this,e)};be().prototype.dot=function(e){return this.throwIfDisposed(),yk(this,e)};be().prototype.elu=function(){return this.throwIfDisposed(),Zh(this)};be().prototype.equal=function(e){return this.throwIfDisposed(),or(this,e)};be().prototype.erf=function(){return this.throwIfDisposed(),Kb(this)};be().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),xk(this,e,t)};be().prototype.exp=function(){return this.throwIfDisposed(),bn(this)};be().prototype.expandDims=function(e){return this.throwIfDisposed(),Za(this,e)};be().prototype.expm1=function(){return this.throwIfDisposed(),wk(this)};be().prototype.fft=function(){return this.throwIfDisposed(),Km(this)};be().prototype.flatten=function(){return this.throwIfDisposed(),te(this,[this.size])};be().prototype.floor=function(){return this.throwIfDisposed(),Jh(this)};be().prototype.floorDiv=function(e){return this.throwIfDisposed(),Wb(this,e)};be().prototype.gather=function(e,t,a){return this.throwIfDisposed(),ep(this,e,t,a)};be().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Ti(this,e)};be().prototype.greater=function(e){return this.throwIfDisposed(),Dn(this,e)};be().prototype.ifft=function(){return this.throwIfDisposed(),Ld(this)};be().prototype.irfft=function(){return this.throwIfDisposed(),lv(this)};be().prototype.isFinite=function(){return this.throwIfDisposed(),kk(this)};be().prototype.isInf=function(){return this.throwIfDisposed(),Sk(this)};be().prototype.isNaN=function(){return this.throwIfDisposed(),Ik(this)};be().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Um(this,e)};be().prototype.lessEqual=function(e){return this.throwIfDisposed(),Po(this,e)};be().prototype.less=function(e){return this.throwIfDisposed(),Md(this,e)};be().prototype.localResponseNormalization=function(e,t,a,n){return this.throwIfDisposed(),Nk(this,e,t,a,n)};be().prototype.logSigmoid=function(){return this.throwIfDisposed(),Tk(this)};be().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Zb(this,e)};be().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Wm(this,e,t)};be().prototype.log=function(){return this.throwIfDisposed(),lr(this)};be().prototype.log1p=function(){return this.throwIfDisposed(),Pm(this)};be().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Gr(this,e)};be().prototype.logicalNot=function(){return this.throwIfDisposed(),Vm(this)};be().prototype.logicalOr=function(e){return this.throwIfDisposed(),Qb(this,e)};be().prototype.logicalXor=function(e){return this.throwIfDisposed(),_k(this,e)};be().prototype.matMul=function(e,t,a){return this.throwIfDisposed(),lt(this,e,t,a)};be().prototype.maxPool=function(e,t,a,n){return this.throwIfDisposed(),Ka(this,e,t,a,n)};be().prototype.max=function(e,t){return this.throwIfDisposed(),Ir(this,e,t)};be().prototype.maximum=function(e){return this.throwIfDisposed(),Hs(this,e)};be().prototype.mean=function(e,t){return this.throwIfDisposed(),ca(this,e,t)};be().prototype.min=function(e,t){return this.throwIfDisposed(),Dd(this,e,t)};be().prototype.minimum=function(e){return this.throwIfDisposed(),To(this,e)};be().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Ek(this,e,t)};be().prototype.mod=function(e){return this.throwIfDisposed(),Ak(this,e)};be().prototype.mul=function(e){return this.throwIfDisposed(),Z(this,e)};be().prototype.neg=function(){return this.throwIfDisposed(),ta(this)};be().prototype.norm=function(e,t,a){return this.throwIfDisposed(),Qh(this,e,t,a)};be().prototype.notEqual=function(e){return this.throwIfDisposed(),Xl(this,e)};be().prototype.oneHot=function(e,t=1,a=0){return this.throwIfDisposed(),Fd(this,e,t,a)};be().prototype.onesLike=function(){return this.throwIfDisposed(),ur(this)};be().prototype.pad=function(e,t){return this.throwIfDisposed(),ms(this,e,t)};be().prototype.pool=function(e,t,a,n,r,s){return this.throwIfDisposed(),$k(this,e,t,a,n,r,s)};be().prototype.pow=function(e){return this.throwIfDisposed(),Ps(this,e)};be().prototype.prelu=function(e){return this.throwIfDisposed(),qm(this,e)};be().prototype.prod=function(e,t){return this.throwIfDisposed(),Rk(this,e,t)};be().prototype.reciprocal=function(){return this.throwIfDisposed(),zk(this)};be().prototype.relu=function(){return this.throwIfDisposed(),Ot(this)};be().prototype.relu6=function(){return this.throwIfDisposed(),tv(this)};be().prototype.reshapeAs=function(e){return this.throwIfDisposed(),te(this,e.shape)};be().prototype.reshape=function(e){return this.throwIfDisposed(),te(this,e)};be().prototype.resizeBilinear=function(e,t,a){return this.throwIfDisposed(),oR(this,e,t,a)};be().prototype.resizeNearestNeighbor=function(e,t,a){return this.throwIfDisposed(),lR(this,e,t,a)};be().prototype.reverse=function(e){return this.throwIfDisposed(),_r(this,e)};be().prototype.rfft=function(){return this.throwIfDisposed(),Xm(this)};be().prototype.round=function(){return this.throwIfDisposed(),av(this)};be().prototype.rsqrt=function(){return this.throwIfDisposed(),nv(this)};be().prototype.selu=function(){return this.throwIfDisposed(),rv(this)};be().prototype.separableConv2d=function(e,t,a,n,r,s){return this.throwIfDisposed(),tp(this,e,t,a,n,r,s)};be().prototype.sigmoid=function(){return this.throwIfDisposed(),Vr(this)};be().prototype.sign=function(){return this.throwIfDisposed(),Lk(this)};be().prototype.sin=function(){return this.throwIfDisposed(),sv(this)};be().prototype.sinh=function(){return this.throwIfDisposed(),iv(this)};be().prototype.slice=function(e,t){return this.throwIfDisposed(),bt(this,e,t)};be().prototype.softmax=function(e){return this.throwIfDisposed(),Vo(this,e)};be().prototype.softplus=function(){return this.throwIfDisposed(),Tc(this)};be().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Hm(this,e,t)};be().prototype.split=function(e,t){return this.throwIfDisposed(),Wn(this,e,t)};be().prototype.sqrt=function(){return this.throwIfDisposed(),en(this)};be().prototype.square=function(){return this.throwIfDisposed(),Vt(this)};be().prototype.squaredDifference=function(e){return this.throwIfDisposed(),uv(this,e)};be().prototype.squeeze=function(e){return this.throwIfDisposed(),Go(this,e)};be().prototype.stack=function(e,t){this.throwIfDisposed();let a=e instanceof ht?[this,e]:[this,...e];return $a(a,t)};be().prototype.step=function(e){return this.throwIfDisposed(),_c(this,e)};be().prototype.stridedSlice=function(e,t,a,n,r,s,i,o){return this.throwIfDisposed(),Bk(this,e,t,a,n,r,s,i,o)};be().prototype.sub=function(e){return this.throwIfDisposed(),$e(this,e)};be().prototype.sum=function(e,t){return this.throwIfDisposed(),ze(this,e,t)};be().prototype.tan=function(){return this.throwIfDisposed(),Uk(this)};be().prototype.tanh=function(){return this.throwIfDisposed(),No(this)};be().prototype.tile=function(e){return this.throwIfDisposed(),sr(this,e)};be().prototype.toBool=function(){return this.throwIfDisposed(),Te(this,"bool")};be().prototype.toFloat=function(){return this.throwIfDisposed(),Te(this,"float32")};be().prototype.toInt=function(){return this.throwIfDisposed(),Te(this,"int32")};be().prototype.topk=function(e,t){return this.throwIfDisposed(),Wk(this,e,t)};be().prototype.transpose=function(e){return this.throwIfDisposed(),ut(this,e)};be().prototype.unique=function(e){return this.throwIfDisposed(),Vk(this,e)};be().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),fv(this,e,t)};be().prototype.unstack=function(e){return this.throwIfDisposed(),ya(this,e)};be().prototype.where=function(e,t){return this.throwIfDisposed(),Ja(e,this,t)};be().prototype.zerosLike=function(){return this.throwIfDisposed(),St(this)};var uo=class PR extends Error{constructor(t){super(t),Object.setPrototypeOf(this,PR.prototype)}},Fs=class WR extends Error{constructor(t){super(t),Object.setPrototypeOf(this,WR.prototype)}},ne=class VR extends Error{constructor(t){super(t),Object.setPrototypeOf(this,VR.prototype)}},mt=class GR extends Error{constructor(t){super(t),Object.setPrototypeOf(this,GR.prototype)}},g7=class HR extends Error{constructor(t){super(t),Object.setPrototypeOf(this,HR.prototype)}},qR=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let a=this.cache.keys().next().value;this.cache.delete(a)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let a=this.cache.keys().next().value;this.cache.delete(a)}this.maxEntries=e}};function Zl(e,t){if(Array.isArray(e)){let a=[];for(let n=0;n<t;n++)a=a.concat(e);return a}else{let a=new Array(t);return a.fill(e),a}}function Ds(e,t){if(!e)throw new g7(t)}function HC(e,t){let a=0;for(let n of e)n===t&&a++;return a}function Un(e){return e.length===1?e[0]:e}function Ft(e){return Array.isArray(e)?e:[e]}function pi(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function El(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,a)=>a.toUpperCase())}var Br={};function lS(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Ww(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>Ww(t));else{let t=Object.keys(e);for(let a of t){let n=e[a];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?e[a]=n.value:Ww(n))}}}function Zm(e,t={},a={},n="object",r=!1){if(typeof e=="string"){let s=e,i;if(s in a)i=a[s];else if(s in Br)i=Br[s];else if(i=t[s],i==null)throw new ne(`Unknown ${n}: ${e}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=e;if(s.className==null||s.config==null)throw new ne(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,o,u;if(i in a?[o,u]=a[i]:i in Br?[o,u]=Br.className:i in t&&([o,u]=t[i]),o==null)throw new ne(`Unknown ${n}: ${i}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let d={};for(let g of Object.keys(Br))d[g]=Br[g];for(let g of Object.keys(a))d[g]=a[g];let c=s.config;c.customObjects=d;let f=Object.assign({},Br);for(let g of Object.keys(a))Br[g]=a[g];Ww(s.config);let m=u(o,s.config,a,r);return Br=Object.assign({},f),m}else{let d=Object.assign({},Br);for(let f of Object.keys(a))Br[f]=a[f];let c=new o(s.config);return Br=Object.assign({},d),c}}}function y7(e,t){return e<t?-1:e>t?1:0}function ky(e,t){return-1*y7(e,t)}function bo(e){if(e==null)return e;let t=[];for(let a of e)t.indexOf(a)===-1&&t.push(a);return t}function b7(e){if(e==null)throw new ne(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Cc(e,t,a){if(a!=null&&e.indexOf(a)<0)throw new ne(`${a} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function uS(e,t,a=0,n=1/0){return Ds(a>=0),Ds(n>=a),Array.isArray(e)&&e.length>=a&&e.length<=n&&e.every(r=>typeof r===t)}function Qa(e,t){Array.isArray(e)?(C.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((a,n)=>Qa(a,`element ${n+1} of ${t}`))):C.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${jR(e)}.`)}function jR(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>jR(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function v7(e,t,a){let n=a!=null?a():C.now(),r;return(...s)=>{let i=a!=null?a():C.now();return i-n<t||(n=i,r=e(...s)),r}}function KR(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var x7=0;function XR(){return x7++}var Sy={};function wv(e=""){return e in Sy||(Sy[e]=0),Sy[e]+=1,e+Sy[e].toString()}var w7=["channelsFirst","channelsLast"],k7=["nearest","bilinear"],S7=["valid","same","causal"],I7=["max","avg"],N7=["sum","mul","concat","ave"],bd=new Map;function Sa(e){Cc(w7,"DataFormat",e)}function T7(e){Cc(k7,"InterpolationFormat",e)}function Cr(e){Cc(S7,"PaddingMode",e)}function YR(e){Cc(I7,"PoolMode",e)}var Lf=[],qC="/";function Fl(e,t){Lf.push(e);try{let a=t();return Lf.pop(),a}catch(a){throw Lf.pop(),a}}function _7(){return Lf.length===0?"":Lf.join(qC)+qC}function ZR(e){if(!JR(e))throw new Error("Not a valid tensor name: '"+e+"'");return _7()+e}function QR(e){if(!JR(e))throw new Error("Not a valid tensor name: '"+e+"'");bd.has(e)||bd.set(e,0);let t=bd.get(e);if(bd.set(e,bd.get(e)+1),t>0){let a=`${e}_${t}`;return bd.set(a,1),a}else return e}var C7=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function JR(e){return!!e.match(C7)}function E7(e){return e===parseInt(e.toString(),10)}function vo(e,t,a){t==null&&(t=0),a==null&&(a=e.length);let n=1;for(let r=t;r<a;++r)n*=e[r];return n}function Ud(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let a=0;a<e.length;a++){let n=e[a];n<t&&(t=n)}return t}function Co(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let a=0;a<e.length;a++){let n=e[a];n>t&&(t=n)}return t}function ds(e,t){if(t<e)throw new ne(`end (${t}) < begin (${e}) is forbidden.`);let a=[];for(let n=e;n<t;++n)a.push(n);return a}var uw;function Ua(){return uw==null&&(uw=W1().epsilon()),uw}function hs(){return"channelsLast"}function ki(e,t){return Te(e,t)}function Qm(e,t=-1){let a=e.shape.slice();return t<0&&(t=a.length+t+1),a.splice(t,0,1),te(e,a)}function A7(e,t){return ae(()=>{if(e.shape.length!==2)throw new ne(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let a=Qm(e,1);return Vw(a,[1,t,1])})}function $7(e){let t=[vo(e.shape)];return te(e,t)}function R7(e){if(e.rank<=1)throw new ne(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],vo(e.shape,1)];return te(e,t)}function Ol(e,t,a){return ae(()=>{switch(e.rank){case 1:return jm(e,t,a);case 2:return ov(e,[t,0],[a,e.shape[1]]);case 3:return ap(e,[t,0,0],[a,e.shape[1],e.shape[2]]);case 4:return zd(e,[t,0,0,0],[a,e.shape[1],e.shape[2],e.shape[3]]);case 5:return bt(e,[t,0,0,0,0],[a,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return bt(e,[t,0,0,0,0,0],[a,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new ne(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function cw(e,t,a){return ae(()=>{switch(e.rank){case 1:return jm(e,t,a);case 2:return ov(e,[0,t],[e.shape[0],a]);case 3:return ap(e,[0,0,t],[e.shape[0],e.shape[1],a]);case 4:return zd(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],a]);default:throw new ne(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Iy(e,t,a,n){return ae(()=>{switch(e.rank){case 1:return jm(e,t,a);case 2:switch(n){case 1:return Ol(e,t,a);case 2:return cw(e,t,a);default:throw new ne(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return Ol(e,t,a);case 2:return ap(e,[0,t,0],[e.shape[0],a,e.shape[2]]);case 3:return cw(e,t,a);default:throw new ne(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return Ol(e,t,a);case 2:return zd(e,[0,t,0,0],[e.shape[0],a,e.shape[2],e.shape[3]]);case 3:return zd(e,[0,0,t,0],[e.shape[0],e.shape[1],a,e.shape[3]]);case 4:return cw(e,t,a);default:throw new ne(`The axis is not within the rank of the tensor ${n}`)}default:throw new ne(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function cS(e,t=-1){let a;return t<0&&(a=e[0].rank,a!==0?t=a:t=0),t===e[0].rank&&(t=-1),Gt(e,t)}function jC(e,t){switch(e.rank){case 1:return ok([e,t]);case 2:return lk([e,t],0);case 3:return uk([e,t],0);case 4:return ck([e,t],0);default:throw new ne(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Vw(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new ne(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return sr(e,t)}function kv(e,t=0,a=1,n,r){return ev(e,t,a,n,r)}function Bs(e,t,a,n){if(e.rank<2||t.rank<2)throw new mt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let r=e.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(r!==s)throw new mt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Bd.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:n?Gw(e.rank,n,hs()):null,activation:a});{let r=e.shape.slice(),s=r.pop();e=te(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),u=i.pop(),d=[...i,o],c=Array.from({length:t.rank},(m,g)=>g===0?t.rank-2:g<=t.rank-2?g-1:g);t=te(ut(t,c),[u,-1]);let f=[...r,...d];return te(Bd.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:n?Gw(e.rank,n,hs()):null,activation:a}),f)}}function eD(e,t,a){return ae(()=>(Array.isArray(t)?t=Mt(t,"int32"):t=Te(t,"int32"),ep(e,t,a)))}function Jm(e){return Z(e,e)}function Gw(e,t,a){let n=t.shape;if(t.rank!==1&&t.rank!==e)throw new ne(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(a==="channelsFirst")return n.length===1?te(t,[1,n[0],1,1,1]):te(t,[1,n[3],n[0],n[1],n[2]]);if(a==="channelsLast")return n.length===1?te(t,[1,1,1,1,n[0]]):te(t,[1].concat(n))}else if(e===4){if(a==="channelsFirst")return n.length===1?te(t,[1,n[0],1,1]):te(t,[1,n[2],n[0],n[1]]);if(a==="channelsLast")return n.length===1?te(t,[1,1,1,n[0]]):te(t,[1].concat(n))}else if(e===3){if(a==="channelsFirst")return n.length===1?te(t,[1,n[0],1]):te(t,[1,n[1],n[0]]);if(a==="channelsLast")return n.length===1?te(t,[1,1,n[0]]):te(t,[1].concat(n))}else if(e<3)return t;throw new ne(`Unsupported input rank by biasAdd: ${t.rank}`)}function gs(e,t,a){return ae(()=>(a==null&&(a=hs()),Sa(a),ge(e,Gw(e.rank,t,a))))}function D7(e,t=1){if(t!==1)throw new mt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Zh(e)}function M7(e){return ae(()=>Fe(e,ge(Ca(e),1)))}function tD(e,t,a,n){return ae(()=>qk(e,t,a,n))}function F7(e){return ae(()=>{let t=ge(.5,Z(.2,e));return yn(t,0,1)})}function eg(e,t,a=!1){return a?e():t()}var O7=["fanIn","fanOut","fanAvg"],z7=["normal","uniform","truncatedNormal"];function L7(e){Cc(O7,"FanMode",e)}function B7(e){Cc(z7,"Distribution",e)}var jr=class extends ke.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},dS=class extends jr{apply(e,t){return da(e,t)}};dS.className="Zeros";ke.registerClass(dS);var Sv=class extends jr{apply(e,t){return Pn(e,t)}};Sv.className="Ones";ke.registerClass(Sv);var hS=class extends jr{constructor(e){if(super(),typeof e!="object")throw new ne(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new ne(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ae(()=>Z(We(this.value),Pn(e,t)))}getConfig(){return{value:this.value}}};hS.className="Constant";ke.registerClass(hS);var pS=class extends jr{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Wo(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};pS.className="RandomUniform";ke.registerClass(pS);var fS=class extends jr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new mt(`randomNormal does not support dType ${t}.`);return kv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};fS.className="RandomNormal";ke.registerClass(fS);var mS=class extends jr{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new mt(`truncatedNormal does not support dType ${t}.`);return pv(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};mS.className="TruncatedNormal";ke.registerClass(mS);var gS=class extends jr{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return ae(()=>{if(e.length!==2||e[0]!==e[1])throw new ne("Identity matrix initializer can only be used for 2D square matrices.");return Z(this.gain,Xb(e[0]))})}getConfig(){return{gain:this.gain}}};gS.className="Identity";ke.registerClass(gS);function U7(e,t="channelsLast"){let a,n;if(Sa(t),e.length===2)a=e[0],n=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let r=vo(e,2);a=e[1]*r,n=e[0]*r}else if(t==="channelsLast"){let r=vo(e,0,e.length-2);a=e[e.length-2]*r,n=e[e.length-1]*r}}else{let r=vo(e);a=Math.sqrt(r),n=Math.sqrt(r)}return[a,n]}var Hn=class extends jr{constructor(e){if(super(),e.scale<0)throw new ne(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,L7(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,B7(this.distribution),this.seed=e.seed}apply(e,t){let a=U7(e),n=a[0],r=a[1],s=this.scale;if(this.mode==="fanIn"?s/=Math.max(1,n):this.mode==="fanOut"?s/=Math.max(1,r):s/=Math.max(1,(n+r)/2),this.distribution==="normal"){let i=Math.sqrt(s);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new mt(`${this.getClassName()} does not support dType ${t}.`);return pv(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*s);return Wo(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Hn.className="VarianceScaling";ke.registerClass(Hn);var Iv=class extends Hn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Iv.className="GlorotUniform";ke.registerClass(Iv);var Nv=class extends Hn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Nv.className="GlorotNormal";ke.registerClass(Nv);var Tv=class extends Hn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Tv.className="HeNormal";ke.registerClass(Tv);var _v=class extends Hn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};_v.className="HeUniform";ke.registerClass(_v);var Cv=class extends Hn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Cv.className="LeCunNormal";ke.registerClass(Cv);var Ev=class extends Hn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Hn.className}};Ev.className="LeCunUniform";ke.registerClass(Ev);var yS=class extends jr{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ae(()=>{if(e.length<2)throw new mt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let a=C.sizeFromShape(e.slice(0,-1)),n=e[e.length-1],r=a*n;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);let s=[Math.max(n,a),Math.min(n,a)],i=kv(s,0,1,t,this.seed),o=Yk.qr(i,!1),u=o[0],d=o[1].flatten().stridedSlice([0],[Math.min(n,a)*Math.min(n,a)],[Math.min(n,a)+1]);return u=Z(u,d.sign()),a<n&&(u=u.transpose()),Z(We(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};yS.className="Orthogonal";ke.registerClass(yS);var KC={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function XC(e,t={}){return Zm(e,ke.SerializationMap.getMap().classNameMap,t,"initializer")}function ha(e){return lS(e)}function oa(e){if(typeof e=="string"){let t=e in KC?KC[e]:e;if(t==="GlorotNormal")return new Nv;if(t==="GlorotUniform")return new Iv;if(t==="HeNormal")return new Tv;if(t==="HeUniform")return new _v;if(t==="LeCunNormal")return new Cv;if(t==="LeCunUniform")return new Ev;{let a={};return a.className=t,a.config={},XC(a)}}else return e instanceof jr?e:XC(e)}function Hw(e){return Array.isArray(e)&&Array.isArray(e[0])}function eb(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Qe(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new ne(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function Ct(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new ne(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function tb(e){let t=0;for(let a of e)a.shape.length===0?t+=1:t+=a.shape.reduce((n,r)=>n*r);return t}var YC="Variable",aD=class{constructor(e,t="float32",a=YC,n=!0,r=null){this.dtype=t??"float32",this.shape=e.shape,this.id=XR(),a=a??YC,this.originalName=ZR(a),this.name=QR(this.originalName),this.trainable_=n,this.constraint=r,this.val=Gk(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),P7(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function P7(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function qw(e){return e.map(t=>t.read())}function bS(e){e.forEach(t=>{t[0].write(t[1])})}var Ea=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},ps=class{constructor(e,t,a,n,r,s,i){this.dtype=e,this.shape=t,this.sourceLayer=a,this.inputs=n,this.callArgs=r,this.outputTensorIndex=i,this.id=XR(),s!=null&&(this.originalName=ZR(s),this.name=QR(this.originalName)),this.rank=t.length}},W7=0,Av=class{constructor(e,t){this.callArgs=t,this.id=W7++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let a of e.inboundLayers)a!=null&&a.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},V7=0,gt=class extends ke.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=V7++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let a=this.getClassName();t=pi(a)+"_"+wv(a)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let a;if(e.batchInputShape!=null)a=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),a=[r].concat(e.inputShape)}this.batchInputShape=a;let n=e.dtype;n==null&&(n=e.inputDType),n==null&&(n="float32"),this.dtype=n}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Fs(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new ne(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Un(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Un(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new uo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new uo(`Layer ${this.name} is not connected, no input to return.`);return Un(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new uo(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new uo(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Un(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=Ft(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let a=Ft(this.inputSpec);if(t.length!==a.length)throw new ne(`Layer ${this.name} expects ${a.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let n=0;n<t.length;n++){let r=t[n],s=a[n];if(s==null)continue;let i=r.rank;if(s.ndim!=null&&i!==s.ndim)throw new ne(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new ne(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new ne(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&r.dtype!==s.dtype)throw new ne(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){let o=r.shape;for(let u in s.axes){let d=Number(u),c=s.axes[u],f=d>=0?o[d]:o[o.length+d];if(c!=null&&[c,null].indexOf(f)===-1)throw new ne(`Input ${n} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${c} but got shape ${o}.`)}}if(s.shape!=null)for(let o=0;o<s.shape.length;++o){let u=s.shape[o],d=r.shape[o];if(u!=null&&d!=null&&u!==d)throw new ne(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let a=Ft(e),n=q7(e),r=j7(e);if(n===r)throw new ne("Arguments to apply() must be all SymbolicTensors or all Tensors");return Fl(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let s=[];for(let i of Ft(e))s.push(i.shape);this.build(Un(s)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);let i=Ft(s),o=[];for(let u of i)a.indexOf(u)!==-1&&(u=u.clone()),o.push(u);if(s=Un(o),this.activityRegularizer!=null)throw new mt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}else{let s=G7(e),i=this.computeOutputShape(s),o,u=H7(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?s[0]:s),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((d,c)=>new ps(u,d,this,Ft(e),t,this.name,c)):o=new ps(u,i,this,Ft(e),t,this.name),this.addInboundNode(e,o,null,null,s,i,t),this._refCount++,this.activityRegularizer!=null)throw new mt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((a,n)=>{a!=null&&e[n]!=null&&e[n]!==a&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new uo(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let a=JSON.stringify(t.outputShapes);e.indexOf(a)===-1&&e.push(a)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new uo(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Fs(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return tb(this.weights)}build(e){this.built=!0}getWeights(e=!1){return qw(e?this.trainableWeights:this.weights)}setWeights(e){ae(()=>{let t=this.weights;if(t.length!==e.length)throw new ne(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let a=[],n=qw(t);for(let r=0;r<n.length;++r){let s=n[r],i=t[r],o=e[r];if(!C.arraysEqual(s.shape,o.shape))throw new ne(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);a.push([i,o])}bS(a)})}addWeight(e,t,a,n,r,s,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new ne(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),a==null&&(a="float32"),this.fastWeightInitDuringBuild&&(n=o!=null?o():oa("zeros"));let u=n.apply(t,a),d=new aD(u,a,e,s,i);return u.dispose(),r!=null&&this.addLoss(()=>r.apply(d.read())),s==null&&(s=!0),s?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ft(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(a=>{if(a!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,a){if(!this.supportsMasking)return;let n=this.computeMask(e,a),r=Ft(t),s=Ft(n);if(r.length!==s.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let i=0;i<r.length;i++)r[i].kerasMask=s[i]}addInboundNode(e,t,a,n,r,s,i=null){let o=Ft(e);t=Ft(t),a=Ft(a),n=Ft(n),r=eb(r),s=eb(s);let u=[],d=[],c=[];for(let f of o)u.push(f.sourceLayer),d.push(f.nodeIndex),c.push(f.tensorIndex);new Av({outboundLayer:this,inboundLayers:u,nodeIndices:d,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:a,outputMasks:n,inputShapes:r,outputShapes:s},i);for(let f=0;f<t.length;f++)t[f].sourceLayer=this,t[f].nodeIndex=this.inboundNodes.length-1,t[f].tensorIndex=f}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function G7(e){e=Ft(e);let t=[];for(let a of e)t.push(a.shape);return Un(t)}function H7(e){return"float32"}function nD(e,t,a){if((t==null||a!=null&&a>0)&&(t=e.sourceLayer,a=e.nodeIndex),t.inboundNodes.length===0)return[e];{let n=t.inboundNodes[a];if(n.inboundLayers.length===0)return n.inputTensors;{let r=[];for(let s=0;s<n.inboundLayers.length;s++){let i=n.inputTensors[s],o=n.inboundLayers[s],u=n.nodeIndices[s],d=nD(i,o,u);for(let c of d)r.indexOf(c)===-1&&r.push(c)}return r}}}function q7(e){let t=!0;for(let a of Ft(e))if(!(a instanceof ps)){t=!1;break}return t}function j7(e){let t=!0;for(let a of Ft(e))if(a instanceof ps){t=!1;break}return t}var rp=class extends gt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:wv("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new ne("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new ne("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new ne("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let a=e.dtype||"float32";this.batchInputShape=t,this.dtype=a,this.inputSpec=[{shape:t}];let n=new ps(this.dtype,this.batchInputShape,this,[],{},this.name);n.nodeIndex=0,n.tensorIndex=0,new Av({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[n],outputTensors:[n],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new ne(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};rp.className="InputLayer";ke.registerClass(rp);function rD(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new ne("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let a=e.dtype;return a==null&&(a="float32"),new rp({batchInputShape:t,name:e.name,dtype:a,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function K7(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return Te(t,e.dtype)}catch{throw new ne(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Id=class sD{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof sD)for(let a in t.id2Value)this.id2Value[a]=t.id2Value[a],a in t.id2Mask&&(this.id2Mask[a]=t.id2Mask[a]);else{if(t==null)return;for(let a of t)this.add(a.key,a.value)}}add(t,a,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=K7(t,a),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new ne(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ps){if(this.id2Value[t.id]==null)throw new ne(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let a=this.name2Id[t];if(a==null)throw new ne(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[a]}}getMask(t){if(t instanceof ps){if(this.id2Value[t.id]==null)throw new ne(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let a=this.name2Id[t];if(a==null)throw new ne(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[a]}}disposeMasks(){this.id2Mask!=null&&nt(this.id2Mask)}},ab=new qR,nb=new qR;function X7(e){ab!=null&&ab.setMaxEntries(e),nb!=null&&nb.setMaxEntries(e)}function Ef(e,t,a,n){let r=a==null?!1:a.training,s=Array.isArray(e),i=s?e:[e],o=i.map(b=>b.name),u=[],d=t.names();for(let b of o)d.indexOf(b)!==-1?u.push(t.getValue(b)):u.push(null);let c=o.join(",")+"|"+t.names().sort().join(","),f=ab.get(c),m;if(f==null){let b=Y7(i,t);f=b.sorted,m=b.recipientCounts,ab.put(c,f),nb.put(c,m)}m={},r||Object.assign(m,nb.get(c));let g=new Id(t);for(let b=0;b<f.length;++b){let v=f[b],x=v.sourceLayer;if(x instanceof rp)continue;let k=[],S=[],N=[],T=!1;for(let B of v.inputs){let V=g.getValue(B),P=g.getMask(B);k.push(V),S.push(P),P!=null&&(T=!0),r||(m[B.name]--,m[B.name]===0&&!t.hasKey(B)&&o.indexOf(B.name)===-1&&!V.isDisposed&&B.sourceLayer.stateful!==!0&&N.push(V))}T&&(a=a||{},a.mask=S[0]);let _=Ft(x.apply(k,a)),R=null;x.supportsMasking&&(R=x.computeMask(k,S));let M=Q7(v),F=Array.isArray(M)?M:[M];for(let B=0;B<F.length;++B){g.hasKey(F[B])||g.add(F[B],_[B],Array.isArray(R)?R[0]:R);let V=o.indexOf(F[B].name);V!==-1&&(u[V]=_[B])}r||nt(N)}return g.disposeMasks(),s?u:u[0]}function Y7(e,t){C.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let a=[],n={};if(e.length===1){let r=ZC(e[0],t);a=r.sorted,n=r.recipientMap}else{let r=new Set;for(let s of e){let{sorted:i,recipientMap:o}=ZC(s,t);for(let u of i)r.has(u.name)||(a.push(u),r.add(u.name));for(let u in o)n[u]==null&&(n[u]=new Set),o[u].forEach(d=>n[u].add(d))}}return{sorted:a,recipientCounts:Z7(n)}}function Z7(e){let t={};for(let a in e)t[a]=e[a].size;return t}function ZC(e,t){let a=new Set,n=[],r={};for(let o of t.names())a.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let o=s[s.length-1];if(a.has(o.name)){s.pop();continue}let u=i[i.length-1]===s.length-1;if(o.inputs.length===0||u)s.pop(),n.push(o),a.add(o.name),u&&i.pop();else{i.push(s.length-1);for(let d of o.inputs)r[d.name]==null&&(r[d.name]=new Set),r[d.name].add(o.name),!a.has(d.name)&&s.push(d)}}return{sorted:n,recipientMap:r}}function Q7(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let a=null;for(let n=0;n<e.sourceLayer.inboundNodes.length;++n)for(let r of e.sourceLayer.inboundNodes[n].outputTensors)if(r.id===e.id){a=n;break}t=e.sourceLayer.getOutputAt(a)}return t}var J7=ie();J7.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,X7);var iD={};rt(iD,{maxNorm:()=>eX,minMaxNorm:()=>nX,nonNeg:()=>aX,unitNorm:()=>tX});function vS(e,t){return ae(()=>en(ze(Z(e,e),t,!0)))}var tg=class extends ke.Serializable{getConfig(){return{}}},xS=class extends tg{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ae(()=>{let t=vS(e,this.axis),a=yn(t,0,this.maxValue);return Z(e,Fe(a,ge(Ua(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};xS.className="MaxNorm";ke.registerClass(xS);var wS=class extends tg{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ae(()=>Fe(e,ge(Ua(),vS(e,this.axis))))}getConfig(){return{axis:this.axis}}};wS.className="UnitNorm";ke.registerClass(wS);var kS=class extends tg{apply(e){return Ot(e)}};kS.className="NonNeg";ke.registerClass(kS);var SS=class extends tg{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ae(()=>{let t=vS(e,this.axis),a=ge(Z(this.rate,yn(t,this.minValue,this.maxValue)),Z(1-this.rate,t));return Z(e,Fe(a,ge(Ua(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};SS.className="MinMaxNorm";ke.registerClass(SS);var QC={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Wa(e){return lS(e)}function JC(e,t={}){return Zm(e,ke.SerializationMap.getMap().classNameMap,t,"constraint")}function Va(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in QC?QC[e]:e,config:{}};return JC(t)}else return e instanceof tg?e:JC(e)}function eX(e){return new xS(e)}function tX(e){return new wS(e)}function aX(){return new kS}function nX(e){return new SS(e)}var oD={};rt(oD,{constant:()=>iX,glorotNormal:()=>pX,glorotUniform:()=>hX,heNormal:()=>fX,heUniform:()=>mX,identity:()=>cX,leCunNormal:()=>gX,leCunUniform:()=>yX,ones:()=>sX,orthogonal:()=>bX,randomNormal:()=>lX,randomUniform:()=>oX,truncatedNormal:()=>uX,varianceScaling:()=>dX,zeros:()=>rX});function rX(){return new dS}function sX(){return new Sv}function iX(e){return new hS(e)}function oX(e){return new pS(e)}function lX(e){return new fS(e)}function uX(e){return new mS(e)}function cX(e){return new gS(e)}function dX(e){return new Hn(e)}function hX(e){return new Iv(e)}function pX(e){return new Nv(e)}function fX(e){return new Tv(e)}function mX(e){return new _v(e)}function gX(e){return new Cv(e)}function yX(e){return new Ev(e)}function bX(e){return new yS(e)}var lD={};rt(lD,{Layer:()=>gt,RNN:()=>Ei,RNNCell:()=>ng,activation:()=>X9,add:()=>rY,alphaDropout:()=>PY,average:()=>sY,averagePooling1d:()=>F2,averagePooling2d:()=>O2,averagePooling3d:()=>z2,avgPool1d:()=>fY,avgPool2d:()=>gY,avgPool3d:()=>bY,avgPooling1d:()=>mY,avgPooling2d:()=>yY,avgPooling3d:()=>vY,batchNormalization:()=>dY,bidirectional:()=>DY,categoryEncoding:()=>qY,centerCrop:()=>GY,concatenate:()=>iY,conv1d:()=>U9,conv2d:()=>P9,conv2dTranspose:()=>W9,conv3d:()=>V9,conv3dTranspose:()=>G9,convLstm2d:()=>EY,convLstm2dCell:()=>AY,cropping2D:()=>q9,dense:()=>Y9,depthwiseConv2d:()=>K9,dot:()=>cY,dropout:()=>Z9,elu:()=>M9,embedding:()=>nY,flatten:()=>J9,gaussianDropout:()=>UY,gaussianNoise:()=>BY,globalAveragePooling1d:()=>xY,globalAveragePooling2d:()=>wY,globalMaxPool1d:()=>FY,globalMaxPool2d:()=>OY,globalMaxPooling1d:()=>cM,globalMaxPooling2d:()=>dM,gru:()=>SY,gruCell:()=>IY,input:()=>TD,inputLayer:()=>D9,layerNormalization:()=>hY,leakyReLU:()=>O9,lstm:()=>NY,lstmCell:()=>TY,masking:()=>WY,maxPool1d:()=>zY,maxPool2d:()=>LY,maxPooling1d:()=>hM,maxPooling2d:()=>pM,maxPooling3d:()=>kY,maximum:()=>oY,minimum:()=>lY,multiply:()=>uY,permute:()=>aY,prelu:()=>z9,randomWidth:()=>jY,reLU:()=>F9,repeatVector:()=>eY,rescaling:()=>VY,reshape:()=>tY,resizing:()=>HY,rnn:()=>$Y,separableConv2d:()=>H9,simpleRNN:()=>_Y,simpleRNNCell:()=>CY,softmax:()=>L9,spatialDropout1d:()=>Q9,stackedRNNCells:()=>RY,thresholdedReLU:()=>B9,timeDistributed:()=>MY,upSampling2d:()=>j9,zeroPadding2d:()=>pY});async function oo(e){if(e==null)return;let t=[],a=[],n=[];for(let r in e){let s=e[r];if(typeof s!="number"){let i=s;t.push(i.data()),a.push(r),n.push(i)}}if(t.length>0){let r=await Promise.all(t);for(let s=0;s<r.length;++s)e[a[s]]=r[s][0];nt(n)}}function uD(e){if(e!=null)for(let t in e){let a=e[t];typeof a!="number"&&a.dispose()}}var eE;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(eE||(eE={}));var vX=125,Pd=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},cD=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let a of this.callbacks)await a.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let a of this.callbacks)await a.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let a of this.callbacks)await a.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let a of this.callbacks)await a.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},xX=class extends Pd{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let a=t.size==null?0:t.size;this.seen+=a;for(let n in t){let r=t[n];if(typeof r=="number")this.totals.hasOwnProperty(n)||(this.totals[n]=0),this.totals[n]=this.totals[n]+r*a;else{let s;n in this.totals?s=this.totals[n]:this.totals[n]=0;let i=ae(()=>ge(this.totals[n],Z(r,a)));this.totals[n]=i,s!=null&&s.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let a of this.params.metrics)this.totals[a]!=null&&(typeof this.totals[a]=="number"?t[a]=this.totals[a]/this.seen:ae(()=>{let n=Z(Fe(1,this.seen),this.totals[a]);t[a]=n,this.totals[a].dispose(),Ba(t[a])}))}},dD=class extends Pd{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let a in t)this.history[a]==null&&(this.history[a]=[]),this.history[a].push(t[a])}async syncData(){let e=[],t=[],a=[];for(let r in this.history){let s=this.history[r];for(let i=0;i<s.length;++i)if(typeof s[i]!="number"){let o=s[i];e.push(o.data()),t.push(r),a.push(i)}}let n=await Promise.all(e);for(let r=0;r<n.length;++r)this.history[t[r]][a[r]].dispose(),this.history[t[r]][a[r]]=n[r][0]}},hD=class extends Pd{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||iS,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=vX),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");C.isNumber(this.yieldEvery)&&(this.maybeWait=v7(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,a){let n=[];this.yield!=null&&(await oo(a),n.push(this.yield(e,t,a))),n.push(this.nextFrameFunc()),await Promise.all(n)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await oo(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let a=[];this.epochEnd!=null&&(await oo(t),a.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&a.push(this.nextFrameFunc()),await Promise.all(a)}async onBatchBegin(e,t){this.batchBegin!=null&&(await oo(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let a=[];this.batchEnd!=null&&(await oo(t),a.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?a.push(this.nextFrameFunc()):C.isNumber(this.yieldEvery)&&a.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(a)}async onTrainBegin(e){this.trainBegin!=null&&(await oo(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await oo(e),await this.trainEnd(e))}};function pD(e,t){return e==null&&(e={}),e instanceof Pd?[e]:Array.isArray(e)&&e[0]instanceof Pd?e:Ft(e).map(a=>new hD(a,t))}var IS=class Es{constructor(){}static registerCallbackConstructor(t,a){C.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Es.checkForDuplicate(a),Es.constructors[t]==null&&(Es.constructors[t]=[]),Es.constructors[t].push(a)}static checkForDuplicate(t){for(let a in Es.constructors)Es.constructors[+a].forEach(n=>{if(n===t)throw new ne("Duplicate callback constructor.")})}static clear(){Es.constructors={}}static createCallbacks(t){let a=[];for(let n in Es.constructors){let r=+n;t>=r&&a.push(...Es.constructors[r])}return a.map(n=>new n)}};IS.constructors={};function fD(e,t,a,n,r,s,i,o,u){let d=new dD,c=[new xX,...IS.createCallbacks(t)];e!=null&&c.push(...e),c.push(d);let f=new cD(c);return f.setParams({epochs:a,initialEpoch:n,samples:r,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:u}),{callbackList:f,history:d}}function us(e,t={},a=!1){return Zm(e,ke.SerializationMap.getMap().classNameMap,t,"layer",a)}function rb(e,t){return ae(()=>{e.dtype!=="float32"&&(e=Te(e,"float32"));let a=ze(Jm(e),t,!0),n=ir(a.shape,Ua()),r=en(Hs(a,n));return Fe(e,r)})}function Ec(e,t){return ae(()=>ca(Jm($e(t,e)),-1))}function $v(e,t){return ae(()=>ca(Ca($e(t,e)),-1))}function sp(e,t){return ae(()=>{let a=$e(e,t),n=yn(Ca(e),Ua(),Number.MAX_VALUE),r=Ca(Fe(a,n));return Z(100,ca(r,-1))})}function wX(e,t){return ae(()=>{let a=yn(t,Ua(),Number.MAX_VALUE),n=lr(ge(1,a)),r=yn(e,Ua(),Number.MAX_VALUE),s=lr(ge(1,r));return ca(Jm($e(n,s)),-1)})}function kX(e,t){return ae(()=>{let a=Hs(0,$e(1,Z(e,t)));return ca(Jm(a),-1)})}function SX(e,t){return ae(()=>{let a=Hs(0,$e(1,Z(e,t)));return ca(a,-1)})}function IX(e,t){return ae(()=>{let a=ze(Z(e,t),-1),n=Ir(Z($e(1,e),t),-1);return Hs(0,ge(1,$e(n,a)))})}function NX(e,t){return ae(()=>{let a=Math.log(2),n=$e(t,e),r=$e(ge(n,Tc(Z(-2,n))),a);return ca(r,-1)})}function Zf(e,t,a=!1){return ae(()=>{if(a)t=Vo(t);else{let n=ze(t,t.shape.length-1,!0);t=Fe(t,n)}return t=yn(t,Ua(),1-Ua()),ta(ze(Z(Te(e,"float32"),lr(t)),t.shape.length-1))})}function sb(e,t,a=!1){return ae(()=>{let n=Te(Jh($7(e)),"int32");t=yn(t,Ua(),1-Ua());let r=t.shape,s=te(Fd(n,r[r.length-1]),r);return Zf(s,t,a)})}function TX(e,t){if(!C.arraysEqual(e.shape,t.shape))throw new ne(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ae(()=>{let a=Ot(t),n=ta(Ca(t));return ge($e(a,Z(t,e)),Pm(bn(n)))})}function Rv(e,t){return ae(()=>{let a;return a=yn(t,Ua(),1-Ua()),a=lr(Fe(a,$e(1,a))),ca(TX(e,a),-1)})}function _X(e,t){return ae(()=>{let a=yn(e,Ua(),1),n=yn(t,Ua(),1);return ze(Z(e,lr(Fe(a,n))),-1)})}function CX(e,t){return ae(()=>{let a=lr(ge(Ua(),t));return ca($e(t,Z(e,a)),-1)})}function NS(e,t){return ae(()=>{let a=rb(e,-1),n=rb(t,-1),r=Z(a,n);return ta(ze(r,-1))})}var ib={meanSquaredError:Ec,meanAbsoluteError:$v,meanAbsolutePercentageError:sp,meanSquaredLogarithmicError:wX,squaredHinge:kX,hinge:SX,categoricalHinge:IX,logcosh:NX,categoricalCrossentropy:Zf,sparseCategoricalCrossentropy:sb,binaryCrossentropy:Rv,kullbackLeiblerDivergence:_X,poisson:CX,cosineProximity:NS};function dw(e){if(typeof e=="string"){if(e in ib)return ib[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ne(t)}else return e}function TS(e,t){return ae(()=>{let a=Z(.5,ur(t)),n=ki(Dn(t,a),e.dtype);return ca(or(e,n),-1)})}function _S(e,t){return ae(()=>ki(or(ql(e,-1),ql(t,-1)),"float32"))}function mD(e,t){return ae(()=>Te(ze(Gr(or(e,1),or(t,1))),"float32"))}function EX(e,t){return ae(()=>Te(ze(Gr(or(e,1),or(t,0))),"float32"))}function AX(e,t){return ae(()=>Te(ze(Gr(or(e,0),or(t,1))),"float32"))}function gD(e,t){return ae(()=>{let a=mD(e,t),n=AX(e,t),r=ge(a,n);return Te(Ja(Dn(r,0),Fe(a,r),0),"float32")})}function $X(e,t){return ae(()=>{let a=mD(e,t),n=EX(e,t),r=ge(a,n);return Te(Ja(Dn(r,0),Fe(a,r),0),"float32")})}function yD(e,t){return Rv(e,t)}function bD(e,t){return e.rank===t.rank&&(e=Go(e,[e.rank-1])),t=ql(t,-1),t.dtype!==e.dtype&&(t=Te(t,e.dtype)),Te(or(e,t),"float32")}function RX(e,t){return ae(()=>{let a=e.sub(t).square().sum(),n=e.sub(e.mean()).square().sum();return We(1).sub(a.div(n))})}var DX=Ec,MX=Ec,FX=$v,OX=$v,zX=sp,LX=sp,CS=Zf,BX=NS,vD=sb,ob={binaryAccuracy:TS,categoricalAccuracy:_S,precision:gD,categoricalCrossentropy:CS,sparseCategoricalCrossentropy:vD,mse:DX,MSE:MX,mae:FX,MAE:OX,mape:zX,MAPE:LX,cosine:BX};function UX(e){if(typeof e=="string"&&e in ob)return ob[e];if(typeof e!="string"&&e!=null)return e;throw new ne(`Unknown metric ${e}`)}function Ny(e){if(Ds(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let a of Object.keys(ib))if(ib[a]===e){t=a;break}if(t!==void 0)return t;for(let a of Object.keys(ob))if(ob[a]===e){t=a;break}return t!==void 0?t:e.name}}function PX(e){let t={Adagrad:()=>Nl.adagrad(.01),Adadelta:()=>Nl.adadelta(1,.95,Ua()),Adam:()=>Nl.adam(.001,.9,.999,Ua()),Adamax:()=>Nl.adamax(.002,.9,.999,Ua(),0),RMSProp:()=>Nl.rmsprop(.001,.9,0,Ua()),SGD:()=>Nl.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new ne(`Unknown Optimizer ${e}`)}function tE(e,t,a=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!jw(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(a){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function jw(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let a of t)if(typeof a!="string"||!jw(e[a]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!jw(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function WX(e,t,a,n=console.log){let r=GX(e),s=["Layer (type)","Input Shape","Output shape","Param #"];r?(t=t||90,a=a||[.32,.61,.89,1]):(t=t||115,a=a||[.24,.48,.7,.8,1]),a[a.length-1]<=1&&(a=a.map(c=>Math.floor(t*c)));let i;if(!r){s.push("Receives inputs"),i=[];for(let c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}n("_".repeat(t)),lb(s,a,n),n("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)r?HX(o[c],a,n):qX(o[c],a,i,n),n((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let u=VX(e),d=tb(e.nonTrainableWeights);n(`Total params: ${u+d}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${d}`),n("_".repeat(t))}function VX(e){let t;return e.collectedTrainableWeights!=null?t=tb(e.collectedTrainableWeights):t=tb(e.trainableWeights),t}function GX(e){let t=!0,a=[],n=[];for(let r in e.nodesByDepth)a.push(e.nodesByDepth[r]);for(let r of a){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){t=!1;break}n.push(...r)}if(t)for(let r of e.layers){let s=!1;for(let i of r.inboundNodes)if(n.indexOf(i)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function lb(e,t,a=console.log){let n="";for(let r=0;r<e.length;++r)r>0&&(n=n.slice(0,n.length-1)+" "),n+=e[r],n=n.slice(0,t[r]),n+=" ".repeat(t[r]-n.length);a(n)}function HX(e,t,a){let n,r;try{r=e.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{n=JSON.stringify(e.outputShape)}catch{n="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,r,n,e.countParams().toString()];lb(o,t,a)}function qX(e,t,a,n){let r,s;try{s=e.inboundNodes.map(f=>JSON.stringify(f.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let i=[];for(let f of e.inboundNodes)if(!(a!=null&&a.length>0&&a.indexOf(f)===-1))for(let m=0;m<f.inboundLayers.length;++m){let g=f.inboundLayers[m].name,b=f.nodeIndices[m],v=f.tensorIndices[m];i.push(`${g}[${b}][${v}]`)}let o=e.name,u=e.getClassName(),d=i.length===0?"":i[0],c=[`${o} (${u})`,s,r,e.countParams().toString(),d];lb(c,t,n);for(let f=1;f<i.length;++f)lb(["","","","",i[f]],t,n)}function xD(e,t,a){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof a=="string"}function Qf(e,t){if(e===null)return null;if(typeof e=="string")return El(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let a=[],n=e.length;for(let r=0;r<n;++r){let s=e[r];xD(t,r,s)?a.push(s):a.push(Qf(s,t))}return a}else{let a={};for(let n of Object.keys(e)){let r=e[n];if(n==="name"&&typeof r=="string")a[n]=r;else{let s=El(n);a[s]=Qf(r,s)}}return a}}function Kw(e,t){if(e==null)return null;if(typeof e=="string")return pi(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let a=[],n=e.length;for(let r=0;r<n;++r){let s=e[r];xD(t,r,s)?a.push(s):a.push(Kw(s,t))}return a}else{let a={};for(let n of Object.keys(e)){let r=e[n],s=pi(n);(n==="name"||n==="className")&&typeof r=="string"?a[s]=r:a[s]=Kw(r,n)}return a}}var ES="4.22.0",jX=e=>{let t=Object.keys(e);if(t.length===0)return!1;let a=t[0].split("/");return!isNaN(parseInt(a[a.length-1],10))},KX=class As extends gt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let S=this.getClassName().toLowerCase();this.name=wv(S)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],bo(this.inputs).length!==this.inputs.length)throw new ne(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(S=>S.name)}`);bo(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(S=>S.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let S of this.outputs){let N=S.sourceLayer,T=S.nodeIndex,_=S.tensorIndex;this.outputLayers.push(N),this.outputLayersNodeIndices.push(T),this.outputLayersTensorIndices.push(_)}for(let S of this.inputs){let N=S.sourceLayer,T=S.nodeIndex,_=S.tensorIndex;Ds(T===0,"input layer has >1 nodes"),Ds(_===0,"input layer has >1 tensors"),this.inputLayers.push(N),this.inputLayersNodeIndices.push(T),this.inputLayersTensorIndices.push(_)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let S=0;S<this.inputLayers.length;S++){let N=this.inputLayers[S];if(!(N instanceof rp))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${S} (0-based) originates from layer type ${N.getClassName()}.`);this.inputNames.push(N.name),this.feedInputShapes.push(N.batchInputShape),this.feedInputNames.push(N.name)}for(let S of this.outputLayers)this.outputNames.push(S.name);this.internalInputShapes=this.inputs.map(S=>S.shape),this.internalOutputShapes=this.outputs.map(S=>S.shape);let a={},n={},r={},s={},i={},o=[],u=(S,N,T,_,R,M)=>{(_==null||R==null||M==null)&&(_=S.sourceLayer,R=S.nodeIndex,M=S.tensorIndex);let F=_.inboundNodes[R];if(T.indexOf(F)!==-1)throw new Fs(`The tensor ${S.name} at layer "${_.name}" is part of a cycle.`);if(N.indexOf(F)!==-1)return;this.containerNodes.add(As.nodeKey(_,R)),_.id in i||(i[_.id]=Object.keys(i).length),T.indexOf(F)===-1&&T.push(F);let B=F.inboundLayers.length;for(let V=0;V<B;V++){let P=F.inputTensors[V],A=F.inboundLayers[V],G=F.nodeIndices[V],J=F.tensorIndices[V];u(P,N,T,A,G,J)}for(N.push(F);T.indexOf(F)>=0;)T.splice(T.indexOf(F),1);o.push(F)},d=[],c=[];for(let S of this.outputs)u(S,d,c);let f=o.slice().reverse();for(let S of f){n[S.id]=S,S.id in a||(a[S.id]=0);let N=a[S.id],T=r[S.outboundLayer.id]==null?0:r[S.outboundLayer.id];N=Math.max(N,T),r[S.outboundLayer.id]=N,s[S.outboundLayer.id]=S.outboundLayer,a[S.id]=N;for(let _=0;_<S.inboundLayers.length;_++){let R=S.inboundLayers[_],M=S.nodeIndices[_],F=R.inboundNodes[M],B=a[F.id]==null?0:a[F.id];a[F.id]=Math.max(N+1,B),n[F.id]=F}}let m={};for(let S in a){let N=a[S];N in m||(m[N]=[]),m[N].push(n[S])}let g={};for(let S in r){let N=r[S];N in g||(g[N]=[]),g[N].push(s[S])}let b=Object.keys(g).map(S=>parseInt(S,10)).sort(ky);this.layers=[];for(let S of b){let N=g[S];N.sort((T,_)=>{let R=i[T.id],M=i[_.id];return R<M?-1:R>M?1:0});for(let T of N)T instanceof As&&this.internalContainerRefs.push(T),this.layers.push(T)}this.layersByDepth=g,b=Object.keys(m).map(S=>parseInt(S,10)).sort(ky);let v=this.inputs.slice(),x=[];for(let S of b)for(let N of m[S]){let T=N.outboundLayer;if(T!=null){for(let _ of N.inputTensors)if(v.indexOf(_)===-1)throw new Fs(`Graph disconnected: cannot obtain value for tensor ${_} at layer "${T.name}". The following previous layers were accessed without issue: ${x}`);for(let _ of N.outputTensors)v.push(_);x.push(T.name)}}this.nodesByDepth=m;let k=this.layers.map(S=>S.name);for(let S of k){let N=k.filter(T=>T===S).length;if(N!==1)throw new Fs(`The name "${S}" is used ${N} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(k))}this.outboundNodes=[],this.inboundNodes=[],new Av({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(S=>null),outputMasks:this.outputs.map(S=>null),inputShapes:this.inputs.map(S=>S.shape),outputShapes:this.outputs.map(S=>S.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let a of this.layers)t.numDisposedVariables+=a.dispose().numDisposedVariables;for(let a of this.internalContainerRefs)t.numDisposedVariables+=a.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(a=>{a._trainableWeights.forEach(n=>n.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new ne("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let a of this.layers)t=t.concat(a.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let a of this.layers)t.push(...a.nonTrainableWeights);if(!this.trainable){let a=[];for(let n of this.layers)a.push(...n.trainableWeights);return a.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,a=!0){let n={},r=0,s=jX(t);s&&this.parseWeights(t);for(let o of this.layers)for(let[u,d]of o.weights.entries()){let c=s?`${d.name.split("/").slice(0,-1).join("/")+"/"}${u}`:d.originalName;if(n[c]!=null)throw new ne(`Duplicate weight name: ${c}`);n[c]=d,r++}let i=[];for(let o in t){let u=o;if(n[o]==null){let d=o.split("/");u=d.slice(0,-2).concat([d[d.length-1]]).join("/")}if(n[u]!=null)i.push([n[u],t[o]]);else if(a)throw new ne(`Provided weight data has no target variable: ${o}`);delete n[u]}if(a){let o=[];for(let u in n)o.push(u);if(o.length>0)throw new ne(`${o.length} of ${r} weights are not set: ${o}`)}bS(i)}parseWeights(t){for(let a in Object.keys(t)){let n=a.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");s!==a&&(t[s]=t[a],delete t[a])}}updatedConfig(){let t=this.getConfig(),a={};return a.className=this.getClassName(),a.config=t,a.kerasVersion=`tfjs-layers ${ES}`,a.backend="TensorFlow.js",a}toJSON(t,a=!0){let n=Kw(this.updatedConfig());return a?JSON.stringify(n):n}call(t,a){return ae(()=>{t=Ft(t);let n=new Id;for(let r=0;r<this.inputs.length;++r)n.add(this.inputs[r],t[r]);return Ef(this.outputs,n,a)})}computeMask(t,a){return ae(()=>{t=Ft(t);let n;return a==null?n=Zl(null,t.length):n=Ft(a),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){let a=eb(t);if(a.length!==this.inputLayers.length)throw new ne(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let o=0;o<a.length;o++){let u=this.inputLayers[o],d=a[o],c=u.name+"_0_0";n[c]=d}let r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(ky);if(r.length>1)for(let o of r){let u=this.nodesByDepth[o];for(let d of u){let c=d.outboundLayer;if(this.inputLayers.map(v=>v.id).indexOf(c.id)!==-1)continue;let f=[];for(let v=0;v<d.inboundLayers.length;v++){let x=d.inboundLayers[v],k=d.nodeIndices[v],S=d.tensorIndices[v],N=`${x.name}_${k}_${S}`,T=n[N];f.push(T)}let m=c.computeOutputShape(Un(f)),g=eb(m),b=c.inboundNodes.indexOf(d);for(let v=0;v<g.length;v++){let x=`${c.name}_${b}_${v}`;n[x]=g[v]}}}let s=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let u=this.outputLayers[o],d=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],f=`${u.name}_${d}_${c}`;i.push(f)}for(let o=0;o<i.length;o++){let u=i[o];Ds(u in n),s.push(n[u])}return Un(s)}runInternalGraph(t,a){a==null&&(a=Zl(null,t.length));let n={};for(let u=0;u<this.inputs.length;++u){let d=this.inputs[u],c=t[u],f=a[u];n[d.id]=[c,f]}let r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(ky);for(let u of r){let d=this.nodesByDepth[u];for(let c of d){let f=c.outboundLayer,m=c.inputTensors,g=c.outputTensors,b=new Array;for(let v of m)v.id in n&&b.push(n[v.id]);if(b.length===m.length){let v={},x,k,S,N;if(c.callArgs!=null&&(v=c.callArgs),b.length===1){let[T,_]=b[0];v.mask==null&&(v.mask=_),S=Ft(f.call(T,v)),N=Ft(f.computeMask(T,_)),x=[T],k=[_]}else x=b.map(T=>T[0]),k=b.map(T=>T[1]),v.mask==null&&(v.mask=k),S=Ft(f.call(x,v)),N=Ft(f.computeMask(x,k));if(f.activityRegularizer)throw new mt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let T=0;T<g.length;++T){let _=g[T],R=S[T],M=N[T];n[_.id]=[R,M]}}}}let s=[],i=[],o=[];for(let u of this.outputs){Ds(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[d,c]=n[u.id];o.push(d.shape),s.push(d),i.push(c)}return[s,i,o]}buildNodeConversionMap(t){let a={},n;for(let r of this.layers){n=r instanceof As?1:0;for(let s=0;s<r.inboundNodes.length;s++){let i=As.nodeKey(r,s);this.containerNodes.has(i)&&(a[i]=n,n+=1)}}return a}getLayer(t,a){if(a!=null)return this.findLayer(a);if(t==null)throw new ne("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let n of this.layers)if(n.name===t)return n;throw new ne(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new ne(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return ae(()=>{let t=[];for(let a of this.layers)for(let n=0;n<a.inboundNodes.length;++n){let r=As.nodeKey(a,n);this.containerNodes.has(r)&&t.push(...a.calculateLosses())}return t})}getConfig(){let t={name:this.name},a=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let o=i.getClassName(),u=i.getConfig(),d=[];for(let f=0;f<i.inboundNodes.length;f++){let m=i.inboundNodes[f],g=As.nodeKey(i,f),b={};if(this.containerNodes.has(g)){if(m.callArgs)try{JSON.stringify(m.callArgs),b=m.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),b={}}if(m.inboundLayers.length>0){let v=[];for(let x=0;x<m.inboundLayers.length;x++){let k=m.inboundLayers[x],S=m.nodeIndices[x],N=m.tensorIndices[x],T=As.nodeKey(k,S),_=a[T];_==null&&(_=0),v.push([k.name,_,N,b])}d.push(v)}}}let c={};c.name=i.name,c.className=o,c.config=u,c.inboundNodes=d,n.push(c)}t.layers=n;let r=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],u=this.inputLayersNodeIndices[i],d=As.nodeKey(o,u);if(!this.containerNodes.has(d))continue;let c=a[d];c==null&&(c=0);let f=this.inputLayersTensorIndices[i];r.push([o.name,c,f])}t.inputLayers=r;let s=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],u=this.outputLayersNodeIndices[i],d=As.nodeKey(o,u);if(!this.containerNodes.has(d))continue;let c=a[d];c==null&&(c=0);let f=this.outputLayersTensorIndices[i];s.push([o.name,c,f])}return t.outputLayers=s,t}static fromConfig(t,a,n={},r=!1){let s={},i={};function o(x,k){x.name in i?i[x.name].push(k):i[x.name]=[k]}function u(x,k){let S=[],N;for(let T of k){let _=T[0],R=T[1],M=T[2];if(N=T[3]==null?{}:T[3],!(_ in s)){o(x,k);return}let F=s[_];if(F.inboundNodes.length<=R){o(x,k);return}let B=F.inboundNodes[R];S.push(B.outputTensors[M])}S.length>0&&x.apply(Un(S),N)}function d(x){let k=x.name,S=us(x,a.customObjects!=null?a.customObjects:{});S.setFastWeightInitDuringBuild(r),s[k]=S,x.inboundNodes.forEach(N=>{if(!(N instanceof Array))throw new ne(`Corrupted configuration, expected array for nodeData: ${N}`);o(S,N)})}let c=a.name,f=a.layers;for(let x of f)d(x);for(;!b7(i);)for(let x of f){let k=s[x.name];if(k.name in i){let S=i[k.name];delete i[k.name];for(let N of S)u(k,N)}}let m=[],g=[],b=a.inputLayers;for(let x of b){let k=x[0],S=x[1],N=x[2];Ds(k in s);let T=s[k].inboundNodes[S].outputTensors;m.push(T[N])}let v=a.outputLayers;for(let x of v){let k=x[0],S=x[1],N=x[2];Ds(k in s);let T=s[k].inboundNodes[S].outputTensors;g.push(T[N])}return new t({inputs:m,outputs:g,name:c})}get stateful(){if(this._stateful)throw new ne("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){ae(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function XX(e,t,a){let n=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>null);if(n===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==n)throw new Error(`Provided ${a} is an array of ${e.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let r=[];return t.forEach(s=>{s in e?r.push(e[s]):r.push(null)}),r}else throw new Error(`The model has multiple (${n}) outputs, so ${a} must be either an array with ${n} elements or an object with ${t} keys. Provided ${a} not understood: ${JSON.stringify(e)}`)}function wD(e,t){return XX(e,t,"classWeight")}async function kD(e,t,a,n){if(a!=null){let r=ae(()=>{if(e.shape.length===1)return zs(e);if(e.shape.length===2){if(e.shape[1]>1)return ql(e,1);if(e.shape[1]===1)return te(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await r.data());nt(r);let i=[];return s.forEach(o=>{if(a[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(a[o])}),Mt(i,"float32")}else return null}function YX(e,t){return Z(e,t)}var ZX=32;function SD(e,t){let a,n,r=t;a=r.xs,n=r.ys,C.assert(a!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=aE("input",e.inputNames,a),i=aE("output",e.outputNames,n),o=s[0].shape[0];C.assert(s.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),C.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let u=0;u<s.length;u++)C.assert(s[u].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[u]} has ${s[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let u=0;u<i.length;u++)C.assert(i[u].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:s,ys:i}}function aE(e,t,a){if(a instanceof ht)return[a];if(Array.isArray(a))return C.assert(a.length===t.length,()=>`Received an array of ${a.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),a;{let n=[];for(let r of t){if(a[r]==null)throw new ne(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);n.push(a[r])}return n}}function QX(e){if(e.length===3)throw new mt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function JX(e,t,a){let n=a.batchesPerEpoch!=null;if(C.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),C.assert(a!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),C.assert(a.epochs!=null&&a.epochs>0&&Number.isInteger(a.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${a.epochs}`),C.assert(!n||a.batchesPerEpoch>0&&Number.isInteger(a.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${a.batchesPerEpoch}`),C.assert(a.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let r=a.validationData!=null,s,i;if(r)if(nE(a.validationData))C.assert(a.validationBatches==null||a.validationBatches>0&&Number.isInteger(a.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${a.validationBatches}`);else{let x=QX(a.validationData);s=x.xs,i=x.ys}let o=e.makeTrainFunction(),u=e.getDedupedMetricsNames(),d;r?d=u.slice().concat(u.map(x=>"val_"+x)):d=u.slice();let c=pD(a.callbacks,a.yieldEvery),f=a.verbose==null?1:a.verbose,{callbackList:m,history:g}=fD(c,f,a.epochs,null,null,e9(t,a),null,r,d);m.setModel(e),e.history=g,await m.onTrainBegin(),e.stopTraining_=!1;let b=a.initialEpoch==null?0:a.initialEpoch,v=await t.iterator();for(;b<a.epochs;){let x={};await m.onEpochBegin(b);let k=0,S=0;for(n||(v=await t.iterator());!n||k<a.batchesPerEpoch;){let N=await v.next();if(n&&N.done){console.warn(`You provided \`batchesPerEpoch\` as ${a.batchesPerEpoch}, but your dataset iterator ran out of data after ${k} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${a.batchesPerEpoch*a.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(N.value!=null){let{xs:T,ys:_}=SD(e,N.value),R={};R.batch=S,R.size=T[0].shape[0],await m.onBatchBegin(S,R);let M=[];if(a.classWeight!=null){let V=wD(a.classWeight,e.outputNames);for(let P=0;P<V.length;++P)M.push(await kD(_[P],null,V[P]))}let F=T.concat(_).concat(M),B=o(F);nt(F);for(let V=0;V<u.length;++V){let P=u[V],A=B[V];R[P]=A,Ba(A)}await m.onBatchEnd(S,R),uD(R),S++,k++}if(n?k>=a.batchesPerEpoch:N.done){if(r){let T;nE(a.validationData)?T=Ft(await e.evaluateDataset(a.validationData,{batches:a.validationBatches})):T=Ft(e.evaluate(s,i,{batchSize:a.validationBatchSize==null?ZX:a.validationBatchSize,verbose:0}));for(let _=0;_<e.metricsNames.length;++_)x[`val_${e.metricsNames[_]}`]=T[_]}break}if(e.stopTraining_)break}if(await m.onEpochEnd(b,x),b++,e.stopTraining_)break}return await m.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function e9(e,t){let a=null;return t.batchesPerEpoch!=null?a=t.batchesPerEpoch:Number.isFinite(e.size)&&(a=e.size),a}function nE(e){return typeof e.iterator=="function"}function t9(e){return typeof e.next=="function"}async function a9(e,t,a){a=a||{};let n=a.batches!=null,r=e.testFunction,s=[];if(a.verbose>0)throw new mt("Verbose mode is not implemented yet.");C.assert(!n||a.batches>0&&Number.isInteger(a.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(a.batches)}`);let i=t9(t)?t:await t.iterator(),o=0,u=0;for(;!n||u<a.batches;){let d=await i.next();if(s=ae(()=>{if(d.value){let{xs:c,ys:f}=SD(e,d.value),m=c.concat(f),g=ae(()=>r(m));if(nt(m),u===0)for(let v=0;v<g.length;++v)s.push(We(0));let b=m[0].shape[0];for(let v=0;v<g.length;++v){let x=g[v],k=s[v];s[v]=ae(()=>ge(s[v],Z(b,x))),u>0&&nt(k)}nt(g),o+=b,++u}return s}),d.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${a.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let d=0;d<s.length;++d){let c=s[d];s[d]=Fe(s[d],o),nt(c)}return Un(s)}function hw(e){C.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Sf(e,t,a){return e==null?[null]:Array.isArray(e)?e.map(n=>Ol(n,t,a-t)):Ol(e,t,a-t)}function Xw(e,t){return ae(()=>e==null?null:Array.isArray(e)?e.map(a=>Xw(a,t)):eD(e,t.dtype==="int32"?t:Te(t,"int32")))}function pw(e,t){let a=[],n=0,r=null;for(;n<e;)r=n+t,r>=e&&(r=e),a.push([n,r]),n=r;return a}function ID(e){let t=[];e instanceof ht&&(e=[e]);for(let a=0;a<e.length;++a){let n=e[a];if(n.rank===1)t.push(Qm(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function rs(e,t){if(e==null)return;let a=[];if(t instanceof ht)a.push(t.id);else if(Array.isArray(t))t.forEach(r=>a.push(r.id));else if(t!=null)for(let r in t){let s=t[r];a.push(s.id)}let n=[];if(e instanceof ht)a.indexOf(e.id)===-1&&n.push(e);else if(Array.isArray(e))e.forEach(r=>{a.indexOf(r.id)===-1&&n.push(r)});else if(e!=null)for(let r in e){let s=e[r];a.indexOf(s.id)===-1&&n.push(s)}n.forEach(r=>{r.isDisposed||r.dispose()})}function n9(e){return e instanceof ht}function Yw(e){return Array.isArray(e)}function rE(e){return!n9(e)&&!Yw(e)}function sE(e,t,a,n=!0,r=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(Yw(e)&&e.length>0)i=!0;else if(rE(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new ne(`Error when checking model ${r} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let s;if(rE(e)){e=e,s=[];for(let i of t){if(e[i]==null)throw new ne(`No data provided for "${i}". Need data for each key in: ${t}`);s.push(e[i])}}else if(Yw(e)){if(e=e,e.length!==t.length)throw new ne(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(e=e,t.length>1)throw new ne(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=ID(s),a!=null)for(let i=0;i<t.length;++i){if(a[i]==null)continue;let o=s[i];if(o.shape.length!==a[i].length)throw new ne(`Error when checking ${r}: expected ${t[i]} to have ${a[i].length} dimension(s). but got array with shape ${o.shape}`);for(let u=0;u<a[i].length;++u){if(u===0&&!n)continue;let d=o.shape[u],c=a[i][u];if(c!=null&&c>=0&&d!==c)throw new ne(`${r} expected a batch of elements where each example has shape [${a[i].slice(1,a[i].length)}] (i.e.,tensor shape [*,${a[i].slice(1,a[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function r9(e,t,a){let n=bo(e.map(s=>s.shape[0]));n.sort();let r=bo(t.map(s=>s.shape[0]));if(r.sort(),n.length>1)throw new ne(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>1)throw new ne(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(n.length>0&&r.length>0&&!C.arraysEqual(n,r))throw new ne(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}function s9(e,t,a){let n=[Ec,Rv,Zf];for(let r=0;r<e.length;++r){let s=e[r],i=t[r],o=a[r];if(i!=null){if(i===Zf&&s.shape[s.shape.length-1]===1)throw new ne(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(i)!==-1){let u=s.shape.slice(1),d=o.slice(1);for(let c=0;c<u.length;++c){let f=u[c],m=d[c];if(m!=null&&f!==m)throw new ne(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function iE(e,t,a,n=!0,r=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new ne(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new ne(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(a!=null)for(let i=0;i<t.length;++i){if(a[i]==null)continue;let o=s[i];if(o.shape.length!==a[i].length)throw new ne(`Error when checking ${r}: expected ${t[i]} to have ${a[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let u=0;u<a[i].length;++u){if(u===0&&!n)continue;let d=o.shape[u],c=a[i][u];if(c!=null&&c!==d)throw new ne(`Error when checking ${r}: expected ${t[i]} to have shape ${JSON.stringify(a[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function i9(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(n=>[]);let a;if(typeof e=="string"||typeof e=="function")a=[e];else if(Array.isArray(e)||typeof e=="object")a=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(a))return t.map(n=>a);{let n=[];for(let r of t){let s=a.hasOwnProperty(r)?a[r]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var o9="layers-model",bi=class extends KX{constructor(e){super(e),this.isTraining=!1}summary(e,t,a=console.log){if(!this.built)throw new ne("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");WX(this,e,t,a)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=PX(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Ci))throw new ne("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let s in e.loss)if(this.outputNames.indexOf(s)===-1)throw new ne(`Unknown entry in loss dictionary: "${s}". Only expected the following keys: ${this.outputNames}`);for(let s of this.outputNames)e.loss[s]==null&&console.warn(`Output "${s}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${s} during training`),t.push(dw(e.loss[s]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new ne(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(s=>dw(s))}else{let s=dw(e.loss);this.outputs.forEach(i=>{t.push(s)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let i=this.internalOutputShapes[s],o=this.outputNames[s];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[s])}let a=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Fl("loss",()=>{for(let s=0;s<this.outputs.length;++s){if(a.indexOf(s)!==-1)continue;let i=this.lossFunctions[s];this.outputs.length>1&&(this.metricsTensors.push([i,s]),this.metricsNames.push(this.outputNames[s]+"_loss"))}});let n=i9(e.metrics,this.outputNames),r=(s,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[s]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,s])};Fl("metric",()=>{for(let s=0;s<this.outputs.length;++s){if(a.indexOf(s)!==-1)continue;let i=n[s];(o=>{let u="",d,c,f;for(let m of o){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){let b=this.internalOutputShapes[s];b[b.length-1]===1||this.lossFunctions[s]===Rv?["accuracy","acc"].indexOf(m)!==-1?c=TS:["crossentropy","ce"].indexOf(m)!==-1&&(c=yD):this.lossFunctions[s]===sb?["accuracy","acc"].indexOf(m)!==-1?c=bD:["crossentropy","ce"].indexOf(m)!==-1&&(c=vD):["accuracy","acc"].indexOf(m)!==-1?c=_S:["crossentropy","ce"].indexOf(m)!==-1&&(c=CS);let v;["accuracy","acc"].indexOf(m)!==-1?v="acc":["crossentropy","ce"].indexOf(m)!==-1&&(v="ce"),f=c,d=u+v}else f=UX(m),d=u+Ny(m);let g;Fl(d,()=>{g=f}),r(s,d,g)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,a={}){let n=a.batchSize==null?32:a.batchSize;hw(n);let r=this.standardizeUserDataXY(e,t,!0,n);try{let s=r[0].concat(r[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,s,n,a.verbose,a.steps);return Un(o)}finally{rs(r[0],e),rs(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),a9(this,e,t)}checkNumSamples(e,t,a,n="steps"){let r;if(a!=null){if(r=null,t!=null)throw new ne(`If ${n} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new ne(`Either the input data should have a defined shape, or ${n} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new ne("`outputs` is an empty Array, which is not allowed.");let a=Array.isArray(t),n=a?t:[t],r=this.retrieveSymbolicTensors(n),s=new Id;if(e instanceof ht&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new ne(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)s.add(this.inputs[o],e[o])}else for(let o of this.inputs){let u=e[o.name];if(u==null)throw new ne(`No value is provided for the model's input ${o.name}`);s.add(o,u)}let i=Ef(r,s);return a?i:i[0]}retrieveSymbolicTensors(e){let t=Zl(null,e.length),a=e.length;for(let n of this.layers){let r=Array.isArray(n.output)?n.output:[n.output],s=r.map(i=>i.name);for(let i=0;i<e.length;++i){let o=s.indexOf(e[i]);if(o!==-1&&(t[i]=r[o],a--),a===0)break}if(a===0)break}if(a>0){let n=[];throw t.forEach((r,s)=>{r==null&&n.push(e[s])}),new ne(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,a=!1){return ae(()=>{let n=this.checkNumSamples(e);if(a)throw new mt("Verbose predictLoop() is not implemented yet.");let r=pw(n,t),s=this.outputs.map(i=>[]);for(let i=0;i<r.length;++i)ae(()=>{let o=r[i][0],u=r[i][1],d=Sf(e,o,u),c=[];if(Array.isArray(d))for(let m=0;m<d.length;++m)c.push({key:this.inputs[m],value:d[m]});else c.push({key:this.inputs[0],value:d});let f=new Id(c);return Ef(this.outputs,f)}).forEach((o,u)=>s[u].push(o));return Un(s.map(i=>Gt(i,0)))})}predict(e,t={}){let a=ID(e);iE(a,this.inputNames,this.feedInputShapes,!1);try{let n=t.batchSize==null?32:t.batchSize;return hw(n),this.predictLoop(a,n)}finally{rs(a,e)}}predictOnBatch(e){iE(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,a=!0,n){if(this.optimizer_==null)throw new Fs("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let r=[];for(let s=0;s<this.feedOutputShapes.length;++s){let i=this.feedOutputShapes[s];this.feedLossFns[s]===sb?r.push(i.slice(0,i.length-1).concat([1])):r.push(i)}if(e=sE(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=sE(t,this.feedOutputNames,r,!1,"target"),r9(e,t),s9(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&n!=null&&n>0&&e[0].shape[0]%n!==0)throw new ne(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,a,n,r=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,r,s);if(a!=null)throw new Error("sample weight is not supported yet.");let u=null;if(n!=null){let d=wD(n,this.outputNames);u=[];for(let c=0;c<d.length;++c)u.push(await kD(o[c],null,d[c]))}return[i,o,u]}testLoop(e,t,a,n=0,r){return ae(()=>{let s=this.checkNumSamples(t,a,r,"steps"),i=[];if(n>0)throw new mt("Verbose mode is not implemented yet.");if(r!=null)throw new mt("steps mode in testLoop() is not implemented yet");{let o=pw(s,a),u=Mt(ds(0,s));for(let d=0;d<o.length;++d){let c=o[d][0],f=o[d][1],m=Ol(u,c,f-c),g=Xw(t,m),b=e(g);if(d===0)for(let v=0;v<b.length;++v)i.push(We(0));for(let v=0;v<b.length;++v){let x=b[v];i[v]=ge(i[v],Z(f-c,x))}}for(let d=0;d<i.length;++d)i[d]=Fe(i[d],s)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let a=0;a<e.length;++a){let n=e[a],r=n;if(HC(e,n)>1){let s=HC(e.slice(0,a),n);r+=`_${s}`}t.push(r)}return t}makeTrainFunction(){return e=>{let t=[],a=e.slice(0,this.inputs.length),n=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),s=[],i=()=>{let u=[];for(let m=0;m<this.inputs.length;++m)u.push({key:this.inputs[m],value:a[m]});let d=new Id(u),c=Ef(this.outputs,d,{training:!0}),f;for(let m=0;m<this.lossFunctions.length;++m){let g=this.lossFunctions[m],b=g(n[m],c[m]);r[m]!=null&&(b=YX(b,r[m]));let v=ca(b);t.push(v),m===0?f=b:f=ge(f,b)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=t[m];else{let b=this.metricsTensors[m][0],v=this.metricsTensors[m][1];g=ca(b(n[v],c[v]))}Ba(g),s.push(g)}return f=ca(f),this.calculateLosses().forEach(m=>{f=ge(f,m)}),f},o=this.collectedTrainableWeights.map(u=>u.read());return[this.optimizer_.minimize(i,!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>ae(()=>{let t=[],a,n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let u=0;u<this.inputs.length;++u)s.push({key:this.inputs[u],value:n[u]});let i=new Id(s),o=Ef(this.outputs,i);for(let u=0;u<this.lossFunctions.length;++u){let d=this.lossFunctions[u],c=ca(d(r[u],o[u]));u===0?a=c:a=ge(a,c),t.push(a)}for(let u=0;u<this.metricsTensors.length;++u){let d=this.metricsTensors[u][0],c=this.metricsTensors[u][1],f=ca(d(r[c],o[c]));t.push(f)}return t})}async fit(e,t,a={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let n,r,s,i,o,u,d,c,f;try{let m=a.batchSize==null?32:a.batchSize;hw(m);let g=await this.standardizeUserData(e,t,a.sampleWeight,a.classWeight,!1,m);n=g[0],r=g[1],f=g[2];let b=!1,v;if(a.validationData!=null&&a.validationData.length>0){if(b=!0,a.validationData.length===2)o=a.validationData[0],u=a.validationData[1];else throw a.validationData.length===3?new mt("validationData including sample weights is not supported yet."):new ne(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${a.validationData} is invalid.`);let R=await this.standardizeUserData(o,u,null,null,!0,m);d=R[0],c=R[1],v=d.concat(c)}else if(a.validationSplit!=null&&a.validationSplit>0&&a.validationSplit<1){b=!0;let R=Math.floor(n[0].shape[0]*(1-a.validationSplit)),M=n[0].shape[0];d=Sf(n,R,M),s=n,n=Sf(n,0,R),c=Sf(r,R,M),i=r,r=Sf(r,0,R),v=d.concat(c)}else a.validationSteps!=null&&(b=!0);let x=n.concat(r).concat(f);this.checkTrainableWeightsConsistency();let k=this.makeTrainFunction(),S=this.getDedupedMetricsNames(),N,T;b?(this.makeTestFunction(),N=this.testFunction,T=S.slice().concat(S.map(R=>"val_"+R))):(N=null,v=[],T=S.slice());let _=pD(a.callbacks,a.yieldEvery);return await this.fitLoop(k,x,S,m,a.epochs,a.verbose,_,N,v,a.shuffle,T,a.initialEpoch,null,null)}finally{this.isTraining=!1,rs(n,e),rs(r,t),rs(s,e),rs(i,t),rs(d,o),rs(c,u),f!=null&&nt(f)}}async fitLoop(e,t,a,n,r,s,i,o,u,d,c,f,m,g){n==null&&(n=32),r==null&&(r=1),d==null&&(d=!0),f==null&&(f=0);let b=!1;if(o!=null&&u!=null&&(b=!0),g!=null&&(b=!0,m==null))throw new ne("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let v=this.checkNumSamples(t,n,m,"steps_per_epoch"),x;v!=null&&(x=ds(0,v)),s==null&&(s=1);let{callbackList:k,history:S}=fD(i,s,r,f,v,m,n,b,c);k.setModel(this),this.history=S,await k.onTrainBegin(),this.stopTraining_=!1;for(let N=f;N<r;++N){await k.onEpochBegin(N);let T={};if(m!=null)throw new mt("stepsPerEpoch mode is not implemented yet.");{if(d==="batch")throw new mt("batch shuffling is not implemneted yet");d&&C.shuffle(x);let _=Mt(x),R=pw(v,n);for(let M=0;M<R.length;++M){let F={};if(await k.onBatchBegin(M,F),ae(()=>{let B=R[M][0],V=R[M][1],P=Ol(_,B,V-B);F.batch=M,F.size=V-B;let A=Xw(t,P),G=e(A);for(let J=0;J<a.length;++J){let ee=a[J],W=G[J];F[ee]=W,Ba(W)}if(M===R.length-1&&b){let J=this.testLoop(o,u,n);for(let ee=0;ee<a.length;++ee){let W=a[ee],X=J[ee];Ba(X),T["val_"+W]=X}}}),await k.onBatchEnd(M,F),uD(F),this.stopTraining_)break}_.dispose()}if(await k.onEpochEnd(N,T),this.stopTraining_)break}return await k.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return JX(this,e,t)}async trainOnBatch(e,t){let a=await this.standardizeUserData(e,t),n=a[0],r=a[1],s=this.makeTrainFunction()(n.concat(r)),i=[];for(let o of s){let u=await o.data();i.push(u[0])}return nt(s),rs(a[0],e),rs(a[1],t),Un(i)}getNamedWeights(e){let t=[],a=e!=null&&e.trainableOnly,n=a?this.trainableWeights:this.weights,r=this.getWeights(a);for(let s=0;s<n.length;++s)a&&!n[s].trainable||t.push({name:n[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=$w().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-$w().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=pi(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>pi(t))}else{let t=Object.keys(this.loss);e={};let a=this.loss;for(let n of t)if(typeof a[n]=="string")e[n]=pi(a[n]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[pi(Ny(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>pi(Ny(e)));{let e={};for(let t in this.metrics)e[t]=pi(Ny(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=Qf(e.optimizer_config),a=us(t),n;if(typeof e.loss=="string")n=El(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(s=>El(s));else if(e.loss!=null){n={};for(let s in e.loss)n[s]=El(e.loss[s])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(s=>El(s));else if(e.metrics!=null){r={};for(let s in e.metrics)r[s]=El(e.metrics[s])}this.compile({loss:n,metrics:r,optimizer:a})}async save(e,t){if(typeof e=="string"){let r=dn.getSaveHandlers(e);if(r.length===0)throw new ne(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new ne(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new ne("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let a=await dn.encodeWeights(this.getNamedWeights(t)),n={modelTopology:this.toJSON(null,!1),format:o9,generatedBy:`TensorFlow.js tfjs-layers v${ES}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){n.trainingConfig=this.getTrainingConfig();let r="optimizer",{data:s,specs:i}=await dn.encodeWeights(await this.optimizer.getWeights(),r);a.specs.push(...i),a.data=dn.concatenateArrayBuffers([a.data,s])}return this.userDefinedMetadata!=null&&(tE(this.userDefinedMetadata,this.name,!0),n.userDefinedMetadata=this.userDefinedMetadata),n.weightData=a.data,n.weightSpecs=a.specs,e.save(n)}setUserDefinedMetadata(e){tE(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};bi.className="Model";ke.registerClass(bi);var ND=class extends bi{};ND.className="Functional";ke.registerClass(ND);async function l9(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let a=e.modelTopology;a.model_config!=null&&(a=a.model_config);let n=Qf(a),r=us(n,t);if(e.weightsManifest!=null){let s=await dn.loadWeights(e.weightsManifest,e.pathPrefix,r.weights.map(o=>o.originalName)),i={};for(let o of r.weights)i[o.originalName]=s[o.originalName];r.loadWeights(i),nt(s)}return r}async function u9(e,t){if(t==null&&(t={}),typeof e=="string"){let a=dn.getLoadHandlers(e,t);if(a.length===0)a.push(dn.browserHTTPRequest(e,t));else if(a.length>1)throw new ne(`Found more than one (${a.length}) load handlers for URL '${e}'`);e=a[0]}return c9(e,void 0,t)}async function c9(e,t,a){if(a==null&&(a={}),e.load==null)throw new ne("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await e.load(),r=n.modelTopology;r.model_config!=null&&(r=r.model_config);let s=a.strict==null?!0:a.strict,i=n.weightData!=null&&n.weightSpecs!=null&&s,o=us(Qf(r),t,i),u=n.trainingConfig;if(u!=null&&o.loadTrainingConfig(u),n.userDefinedMetadata!=null&&o.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new ne("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:d,optimizerWeights:c}=d9(n.weightData,n.weightSpecs);o.loadWeights(d,s),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),nt(d),nt(c.map(f=>f.tensor))}return o}function d9(e,t){let a=dn.decodeWeights(e,t),n={},r=[];return t.forEach(s=>{s.group==="optimizer"?r.push({name:s.name,tensor:a[s.name]}):n[s.name]=a[s.name]}),{modelWeights:n,optimizerWeights:r}}var Dv=class Zw extends bi{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:wv("sequential_"),t.layers!=null)for(let a of t.layers)this.add(a)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(a=>a<0))throw new ne(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let a=t instanceof Zw||t instanceof bi,n;if(a){if(n=t,n.outputs.length!==1)throw new ne("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new ne("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new ne("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let r=rD({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(r)}if(a)this.outputs=n.outputs,this.inputs=n.inputs;else{if(t.inboundNodes.length!==1)throw new ne(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new ne("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=nD(this.outputs[0])}this.inboundNodes=[],new Av({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Zl(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{let r=t.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,a){return this.model==null&&this.build(),this.model.call(t,a)}build(t){if(Ct(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new bi({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,a,n=console.log){this.built||this.build(),super.summary(t,a,n)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,a,n={}){if(!this.built)throw new Fs("The model needs to be compiled before being used.");return this.model.evaluate(t,a,n)}async evaluateDataset(t,a){if(!this.built)throw new Fs("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,a)}predict(t,a={}){return this.model==null&&this.build(),this.model.predict(t,a)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,a,n={}){if(!this.built)throw new Fs("The model needs to be compiled before being used.");return this.model.fit(t,a,n)}async fitDataset(t,a){if(!this.built)throw new Fs("The model needs to be compiled before being used.");return this.model.fitDataset(t,a)}async trainOnBatch(t,a){return this.model.trainOnBatch(t,a)}static fromConfig(t,a,n={},r=!1){let s,i={};if(a instanceof Array){if(a[0].className==null||a[0].className==="Merge")throw new ne("Legacy serialization format not supported yet.");s=a}else C.assert(a.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=a.layers,delete a.layers,i=a;let o=new t(i);if(!(o instanceof Zw))throw new mt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let u of s){let d=us(u,void 0,r);r&&d.setFastWeightInitDuringBuild(!0),o.add(d)}return o}set stopTraining(t){if(this.model==null)throw new ne("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new ne("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let a of this.layers){let n={};n.className=a.getClassName(),n.config=a.getConfig(),t.push(n)}return{name:this.name,layers:t}}};Dv.className="Sequential";ke.registerClass(Dv);function h9(e){return new bi(e)}function p9(e){return new Dv(e)}function TD(e){return rD(e)}function f9(e,t){IS.registerCallbackConstructor(e,t)}var vn=class extends ke.Serializable{getConfig(){return{}}},_D=class extends vn{apply(e,t=1){return D7(e,t)}};_D.className="elu";ke.registerClass(_D);var CD=class extends vn{apply(e){return rv(e)}};CD.className="selu";ke.registerClass(CD);var ED=class extends vn{apply(e){return Ot(e)}};ED.className="relu";ke.registerClass(ED);var AD=class extends vn{apply(e){return ae(()=>To(6,Ot(e)))}};AD.className="relu6";ke.registerClass(AD);var $D=class extends vn{apply(e){return e}};$D.className="linear";ke.registerClass($D);var RD=class extends vn{apply(e){return Vr(e)}};RD.className="sigmoid";ke.registerClass(RD);var DD=class extends vn{apply(e){return F7(e)}};DD.className="hardSigmoid";ke.registerClass(DD);var MD=class extends vn{apply(e){return Tc(e)}};MD.className="softplus";ke.registerClass(MD);var FD=class extends vn{apply(e){return M7(e)}};FD.className="softsign";ke.registerClass(FD);var OD=class extends vn{apply(e){return No(e)}};OD.className="tanh";ke.registerClass(OD);var AS=class extends vn{apply(e,t=-1){return Vo(e,t)}};AS.className="softmax";ke.registerClass(AS);var zD=class extends vn{apply(e,t=-1){return Zb(e,t)}};zD.className="logSoftmax";ke.registerClass(zD);var LD=class extends vn{apply(e){return ae(()=>ae(()=>{let t=Math.sqrt(2),a=Z(.5,ge(1,Kb(Fe(e,t))));return Z(e,a)}))}};LD.className="gelu";ke.registerClass(LD);var BD=class extends vn{apply(e){return ae(()=>Z(.5,Z(e,ge(1,No(Z(en(Fe(2,Math.PI)),ge(e,Z(.044715,Ps(e,3)))))))))}};BD.className="gelu_new";ke.registerClass(BD);var UD=class extends vn{apply(e){return ae(()=>Z(e,No(Tc(e))))}};UD.className="mish";ke.registerClass(UD);var PD=class extends vn{apply(e,t=1){return ae(()=>Z(Vr(Z(e,t)),e))}};PD.className="swish";ke.registerClass(PD);function Eo(e){return e.getClassName()}function fw(e,t={}){return Zm(e,ke.SerializationMap.getMap().classNameMap,t,"activation")}function Ao(e){if(e==null){let t={};return t.className="linear",t.config={},fw(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},fw(t)}else return e instanceof vn?e:fw(e)}function $S(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var WD=class extends ke.Serializable{},ag=class extends WD{constructor(e){super(),$S(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ae(()=>{let t=da([1]);return this.hasL1&&(t=ge(t,ze(Z(this.l1,Ca(e))))),this.hasL2&&(t=ge(t,ze(Z(this.l2,Jm(e))))),te(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};ag.className="L1L2";ke.registerClass(ag);function m9(e){return $S(e),new ag({l1:e!=null?e.l1:null,l2:0})}function g9(e){return $S(e),new ag({l2:e!=null?e.l2:null,l1:0})}var oE={l1l2:"L1L2"};function Qt(e){return lS(e)}function lE(e,t={}){return Zm(e,ke.SerializationMap.getMap().classNameMap,t,"regularizer")}function la(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in oE?oE[e]:e,config:{}};return lE(t)}else return e instanceof WD?e:lE(e)}var RS=class extends gt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Qe(e);let a=Ot(e);return this.maxValue!=null&&(a=yn(a,0,this.maxValue)),a}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};RS.className="ReLU";ke.registerClass(RS);var DS=class extends gt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let a=Qe(e);return Um(a,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};DS.className="LeakyReLU";ke.registerClass(DS);var MS=class extends gt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=oa(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=la(e.alphaRegularizer),this.alphaConstraint=Va(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new ne(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Ct(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let n of this.sharedAxes)t[n-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let a={};if(this.sharedAxes!=null)for(let n=1;n<e.length;++n)a[n]=e[n];this.inputSpec=[new Ea({ndim:e.length,axes:a})],this.built=!0}call(e,t){return e=Qe(e),qm(e,this.alpha.read())}getConfig(){let e={alphaInitializer:ha(this.alphaInitializer),alphaRegularizer:Qt(this.alphaRegularizer),alphaConstraint:Wa(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};MS.className="PReLU";ke.registerClass(MS);var FS=class extends gt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new mt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let a=Qe(e);return Zh(a)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};FS.className="ELU";ke.registerClass(FS);var OS=class extends gt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let a=Qe(e);return Z(a,Te(Dn(a,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};OS.className="ThresholdedReLU";ke.registerClass(OS);var zS=class extends gt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new AS().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return ae(()=>{let a=Qe(e),n=t.mask;if(n!=null){let r=Z($e(Pn(a.shape),Te(n,a.dtype)),We(-1e9));a=ge(a,r)}return this.axis instanceof Array?this.axis.length>1?bn($e(a,Wm(a,this.axis,!0))):this.softmax(a,this.axis[0]):this.softmax(a,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};zS.className="Softmax";ke.registerClass(zS);function Cd(e,t,a){if(typeof e=="number")return Zl(e,t);if(e.length!==t)throw new ne(`The ${a} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let n=0;n<t;++n){let r=e[n];if(!E7(r))throw new ne(`The ${a} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${r}`)}return e}function cs(e,t,a,n,r=1){if(e==null)return e;let s=t+(t-1)*(r-1),i;return a==="same"?i=e:i=e-s+1,Math.floor((i+n-1)/n)}function Ms(e,t,a,n){if(e==null)return null;if(n==="valid")e=e*t+Co([a-t,0]);else if(n==="same")e=e*t;else throw new ne(`Unsupport padding mode: ${n}.`);return e}function LS(e,t){return ae(()=>(Sa(t),t==="channelsFirst"?ut(e,[0,2,3,1]):e))}function VD(e,t){return ae(()=>(Sa(t),t==="channelsFirst"?ut(e,[0,2,3,4,1]):e))}function y9(e,t,a,n=1,r="valid",s,i=1){return ae(()=>{if(s==null&&(s=hs()),Sa(s),e.shape.length!==3)throw new ne(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new ne(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(a!=null&&a.shape.length!==1)throw new ne(`The bias for a conv1dWithBias operation should be 1, but is ${a.shape.length} instead`);if(s==="channelsFirst"&&(e=ut(e,[0,2,1])),r==="causal")throw new mt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Gb(e,t,n,r==="same"?"same":"valid","NWC",i);return a!=null&&(o=gs(o,a)),o})}function uE(e,t,a,n=[1,1],r="valid",s,i,o=null){return ae(()=>{if(s==null&&(s=hs()),Sa(s),e.rank!==3&&e.rank!==4)throw new ne(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new ne(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let u=LS(e,s);if(r==="causal")throw new mt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Bd.conv2d({x:u,filter:t,strides:n,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:a,activation:o}),s==="channelsFirst"&&(u=ut(u,[0,3,1,2])),u})}function b9(e,t,a,n=[1,1,1],r="valid",s,i){return ae(()=>{if(s==null&&(s=hs()),Sa(s),e.rank!==4&&e.rank!==5)throw new ne(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new ne(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=VD(e,s);if(r==="causal")throw new mt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=hk(o,t,n,r==="same"?"same":"valid","NDHWC",i),a!=null&&(o=gs(o,a)),s==="channelsFirst"&&(o=ut(o,[0,4,1,2,3])),o})}var GD=class HD extends gt{constructor(t,a){if(super(a),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",HD.verifyArgs(a),this.rank=t,Qa(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new mt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Cd(a.kernelSize,t,"kernelSize"),this.strides=Cd(a.strides==null?1:a.strides,t,"strides"),this.padding=a.padding==null?"valid":a.padding,Cr(this.padding),this.dataFormat=a.dataFormat==null?"channelsLast":a.dataFormat,Sa(this.dataFormat),this.activation=Ao(a.activation),this.useBias=a.useBias==null?!0:a.useBias,this.biasInitializer=oa(a.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Va(a.biasConstraint),this.biasRegularizer=la(a.biasRegularizer),this.activityRegularizer=la(a.activityRegularizer),this.dilationRate=Cd(a.dilationRate==null?1:a.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ne(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ne(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ne(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Ds("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!uS(t.kernelSize,"number",1,3))throw new ne(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Eo(this.activation),useBias:this.useBias,biasInitializer:ha(this.biasInitializer),biasRegularizer:Qt(this.biasRegularizer),activityRegularizer:Qt(this.activityRegularizer),biasConstraint:Wa(this.biasConstraint)},a=super.getConfig();return Object.assign(t,a),t}},Mv=class qD extends GD{constructor(t,a){super(t,a),this.kernel=null,qD.verifyArgs(a),this.filters=a.filters,Qa(this.filters,"filters"),this.kernelInitializer=oa(a.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Va(a.kernelConstraint),this.kernelRegularizer=la(a.kernelRegularizer)}build(t){t=Ct(t);let a=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[a]==null)throw new ne(`The channel dimension of the input should be defined. Found ${t[a]}`);let n=t[a],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[a]:n}}],this.built=!0}call(t,a){return ae(()=>{t=Qe(t);let n,r=this.bias==null?null:this.bias.read(),s=KR(this.activation.getClassName());if(s!=null&&this.rank===2)n=uE(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=y9(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=uE(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=b9(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new mt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(t){t=Ct(t);let a=[],n=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<n.length;++s){let i=cs(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);a.push(i)}let r=[t[0]];return this.dataFormat==="channelsLast"?(r=r.concat(a),r.push(this.filters)):(r.push(this.filters),r=r.concat(a)),r}getConfig(){let t={filters:this.filters,kernelInitializer:ha(this.kernelInitializer),kernelRegularizer:Qt(this.kernelRegularizer),kernelConstraint:Wa(this.kernelConstraint)},a=super.getConfig();return Object.assign(t,a),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new ne(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},Fv=class jD extends Mv{constructor(t){super(2,t),jD.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!uS(t.kernelSize,"number",1,2))throw new ne(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};Fv.className="Conv2D";ke.registerClass(Fv);var Ov=class KD extends Mv{constructor(t){super(3,t),KD.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new ne(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};Ov.className="Conv3D";ke.registerClass(Ov);var BS=class extends Fv{constructor(e){if(super(e),this.inputSpec=[new Ea({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ne(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ct(e),e.length!==4)throw new ne("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ne("The channel dimension of the inputs should be defined. Found `None`.");let a=e[t],n=this.kernelSize.concat([this.filters,a]);this.kernel=this.addWeight("kernel",n,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ea({ndim:4,axes:{[t]:a}})],this.built=!0}call(e,t){return ae(()=>{let a=Qe(e);if(a.shape.length!==4)throw new ne(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${a.shape.length}`);let n=a.shape,r=n[0],s,i;this.dataFormat==="channelsFirst"?(s=2,i=3):(s=1,i=2);let o=n[s],u=n[i],d=this.kernelSize[0],c=this.kernelSize[1],f=this.strides[0],m=this.strides[1],g=Ms(o,f,d,this.padding),b=Ms(u,m,c,this.padding),v=[r,g,b,this.filters];this.dataFormat!=="channelsLast"&&(a=ut(a,[0,2,3,1]));let x=Hb(a,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=ut(x,[0,3,1,2])),this.bias!=null&&(x=gs(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=Ct(e);let t=e.slice(),a,n,r;this.dataFormat==="channelsFirst"?(a=1,n=2,r=3):(a=3,n=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],u=this.strides[1];return t[a]=this.filters,t[n]=Ms(t[n],o,s,this.padding),t[r]=Ms(t[r],u,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};BS.className="Conv2DTranspose";ke.registerClass(BS);var US=class extends Ov{constructor(e){if(super(e),this.inputSpec=[new Ea({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ne(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ct(e),e.length!==5)throw new ne("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new ne("The channel dimension of the inputs should be defined. Found `None`.");let a=e[t],n=this.kernelSize.concat([this.filters,a]);this.kernel=this.addWeight("kernel",n,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ea({ndim:5,axes:{[t]:a}})],this.built=!0}call(e,t){return ae(()=>{let a=Qe(e);if(a.shape.length!==5)throw new ne(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${a.shape.length}`);let n=a.shape,r=n[0],s,i,o;this.dataFormat==="channelsFirst"?(o=2,s=3,i=4):(o=1,s=2,i=3);let u=n[o],d=n[s],c=n[i],f=this.kernelSize[0],m=this.kernelSize[1],g=this.kernelSize[2],b=this.strides[0],v=this.strides[1],x=this.strides[2],k=Ms(u,b,f,this.padding),S=Ms(d,v,m,this.padding),N=Ms(c,x,g,this.padding),T=[r,k,S,N,this.filters];this.dataFormat!=="channelsLast"&&(a=ut(a,[0,2,3,4,1]));let _=pk(a,this.kernel.read(),T,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(_=ut(_,[0,4,1,2,3])),this.bias!==null&&(_=gs(_,this.bias.read(),this.dataFormat)),this.activation!==null&&(_=this.activation.apply(_)),_})}computeOutputShape(e){e=Ct(e);let t=e.slice(),a,n,r,s;this.dataFormat==="channelsFirst"?(a=1,n=2,r=3,s=4):(a=4,n=1,r=2,s=3);let i=this.kernelSize[0],o=this.kernelSize[1],u=this.kernelSize[2],d=this.strides[0],c=this.strides[1],f=this.strides[2];return t[a]=this.filters,t[n]=Ms(t[n],d,i,this.padding),t[r]=Ms(t[r],c,o,this.padding),t[s]=Ms(t[s],f,u,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};US.className="Conv3DTranspose";ke.registerClass(US);var XD=class extends Mv{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new ne("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new ne("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new ne(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=oa(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=la(t.depthwiseRegularizer),this.depthwiseConstraint=Va(t.depthwiseConstraint),this.pointwiseInitializer=oa(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=la(t.pointwiseRegularizer),this.pointwiseConstraint=Va(t.pointwiseConstraint)}build(e){if(e=Ct(e),e.length<this.rank+2)throw new ne(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new ne(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let a=e[t],n=this.kernelSize.concat([a,this.depthMultiplier]),r=[];for(let i=0;i<this.rank;++i)r.push(1);r.push(a*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",n,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new Ea({ndim:this.rank+2,axes:{[t]:a}})],this.built=!0}call(e,t){return ae(()=>{e=Qe(e);let a;if(this.rank===1)throw new mt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ut(e,[0,2,3,1])),a=tp(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(a=gs(a,this.bias.read(),this.dataFormat)),this.activation!=null&&(a=this.activation.apply(a)),this.dataFormat==="channelsFirst"&&(a=ut(a,[0,3,1,2])),a})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ha(this.depthwiseInitializer),e.pointwiseInitializer=ha(this.pointwiseInitializer),e.depthwiseRegularizer=Qt(this.depthwiseRegularizer),e.pointwiseRegularizer=Qt(this.pointwiseRegularizer),e.depthwiseConstraint=Wa(this.depthwiseConstraint),e.pointwiseConstraint=Wa(this.pointwiseConstraint),e}};XD.className="SeparableConv";var PS=class extends XD{constructor(e){super(2,e)}};PS.className="SeparableConv2D";ke.registerClass(PS);var WS=class YD extends Mv{constructor(t){super(1,t),YD.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!uS(t.kernelSize,"number",1,1))throw new ne(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};WS.className="Conv1D";ke.registerClass(WS);var VS=class extends gt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ae(()=>{if(e=Qe(e),this.dataFormat==="channelsLast"){let a=Iy(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Iy(a,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let a=Iy(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Iy(a,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};VS.className="Cropping2D";ke.registerClass(VS);var GS=class extends gt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Sa(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,T7(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],a=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,a]}else{let t=e[1]==null?null:this.size[0]*e[1],a=e[2]==null?null:this.size[1]*e[2];return[e[0],t,a,e[3]]}}call(e,t){return ae(()=>{let a=Qe(e),n=a.shape;if(this.dataFormat==="channelsFirst"){a=ut(a,[0,2,3,1]);let r=this.size[0]*n[2],s=this.size[1]*n[3],i=this.interpolation==="nearest"?xr.resizeNearestNeighbor(a,[r,s]):xr.resizeBilinear(a,[r,s]);return ut(i,[0,3,1,2])}else{let r=this.size[0]*n[1],s=this.size[1]*n[2];return this.interpolation==="nearest"?xr.resizeNearestNeighbor(a,[r,s]):xr.resizeBilinear(a,[r,s])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};GS.className="UpSampling2D";ke.registerClass(GS);function v9(e,t,a=[1,1],n="valid",r,s){return ae(()=>{r==null&&(r=hs()),Sa(r);let i=LS(e,r);if(e.rank!==4)throw new ne(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new ne(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Nc(i,t,a,n==="same"?"same":"valid","NHWC",s),r==="channelsFirst"&&(i=ut(i,[0,3,1,2])),i})}var HS=class extends GD{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=oa(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Va(e.depthwiseConstraint),this.depthwiseRegularizer=la(e.depthwiseRegularizer)}build(e){if(e=Ct(e),e.length<4)throw new ne(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new ne(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let a=e[t],n=[this.kernelSize[0],this.kernelSize[1],a,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",n,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[a*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ae(()=>{e=Qe(e);let a=v9(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(a=gs(a,this.bias.read(),this.dataFormat)),this.activation!=null&&(a=this.activation.apply(a)),a})}computeOutputShape(e){e=Ct(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],a=this.dataFormat==="channelsFirst"?e[3]:e[2],n=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=cs(t,this.kernelSize[0],this.padding,this.strides[0]),s=cs(a,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],n,r,s]:[e[0],r,s,n]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ha(this.depthwiseInitializer),e.depthwiseRegularizer=Qt(this.depthwiseRegularizer),e.depthwiseConstraint=Wa(this.depthwiseRegularizer),e}};HS.className="DepthwiseConv2D";ke.registerClass(HS);function ZD(e,t,a,n){if(Array.isArray(e)){if(t!=null||a!=null)throw new ne("When inputs is an array, neither initialState or constants should be provided");n!=null&&(a=e.slice(e.length-n,e.length),e=e.slice(0,e.length-n)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(s){return s==null||Array.isArray(s)?s:[s]}return t=r(t),a=r(a),{inputs:e,initialState:t,constants:a}}function QD(e,t,a,n=!1,r,s,i=!1,o=!1){return ae(()=>{let u=t.shape.length;if(u<3)throw new ne(`Input should be at least 3D, but is ${u}D.`);let d=[1,0].concat(ds(2,u));t=ut(t,d),s!=null,i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=Te(Te(r,"bool"),"float32"),r.rank===u-1&&(r=Za(r,-1)),r=ut(r,d)),n&&(t=_r(t,0),r!=null&&(r=_r(r,0)));let c=[],f,m=a,g=t.shape[0],b=ya(t),v;r!=null&&(v=ya(r));for(let k=0;k<g;++k){let S=b[k],N=ae(()=>e(S,m));if(r==null)f=N[0],m=N[1];else{let T=ae(()=>{let _=v[k],R=$e(ur(_),_),M=ge(Z(N[0],_),Z(m[0],R)),F=m.map((B,V)=>ge(Z(N[1][V],_),Z(B,R)));return{output:M,newStates:F}});f=T.output,m=T.newStates}o&&c.push(f)}let x;return o&&(x=$a(c,1)),[f,x,m]})}var Ei=class JD extends gt{constructor(t){super(t);let a;if(t.cell==null)throw new ne("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?a=new Bv({cells:t.cell}):a=t.cell,a.stateSize==null)throw new ne("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=a,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Ea({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ds(0,t).map(a=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Hw(t)&&(t=t[0]),t=t;let a=this.cell.stateSize;Array.isArray(a)||(a=[a]);let n=a[0],r;if(this.returnSequences?r=[t[0],t[1],n]:r=[t[0],n],this.returnState){let s=[];for(let i of a)s.push([t[0],i]);return[r].concat(s)}else return r}computeMask(t,a){return ae(()=>{Array.isArray(a)&&(a=a[0]);let n=this.returnSequences?a:null;if(this.returnState){let r=this.states.map(s=>null);return[n].concat(r)}else return n})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,a=[];for(let n=0;n<t;++n)a.push(null);return a}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new mt("Constants support is not implemented in RNN yet.");Hw(t)&&(t=t[0]),t=t;let a=this.stateful?t[0]:null,n=t.slice(2);this.inputSpec[0]=new Ea({shape:[a,null,...n]});let r=[t[0]].concat(t.slice(2));this.cell.build(r);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!C.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),s))throw new ne(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(i=>new Ea({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,a=!1){ae(()=>{if(!this.stateful)throw new uo("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new ne("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>da([n,r])):this.states_=[da([n,this.cell.stateSize])];else if(t==null)nt(this.states_),this.keptStates!=null&&(nt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>da([n,r])):this.states_[0]=da([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ne(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);a===!0?this.keptStates.push(this.states_.slice()):nt(this.states_);for(let r=0;r<this.states_.length;++r){let s=t[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,o=[n,i];if(!C.arraysEqual(s.shape,o))throw new ne(`State ${r} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[r]=s}}this.states_=this.states_.map(r=>Ba(r.clone()))})}apply(t,a){let n=a==null?null:a.initialState,r=a==null?null:a.constants;a==null&&(a={});let s=ZD(t,n,r,this.numConstants);t=s.inputs,n=s.initialState,r=s.constants;let i=[],o=[];if(n!=null){a.initialState=n,i=i.concat(n),this.stateSpec=[];for(let u of n)this.stateSpec.push(new Ea({shape:u.shape}));o=o.concat(this.stateSpec)}if(r!=null&&(a.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof ps){let u=[t].concat(i),d=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=d;let f=super.apply(u,a);return this.inputSpec=c,f}else return super.apply(t,a)}call(t,a){return ae(()=>{let n=a==null?null:a.mask,r=a==null?null:a.training,s=a==null?null:a.initialState;t=Qe(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new ne(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:r},u=QD((g,b)=>{let v=this.cell.call([g].concat(b),o);return[v[0],v.slice(1)]},t,s,this.goBackwards,n,null,this.unroll,this.returnSequences),d=u[0],c=u[1],f=u[2];this.stateful&&this.resetStates(f,r);let m=this.returnSequences?c:d;return this.returnState?[m].concat(f):m})}getInitialState(t){return ae(()=>{let a=da(t.shape);return a=ze(a,[1,2]),a=Qm(a),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?Vw(a,[1,n]):a):this.cell.stateSize>1?[Vw(a,[1,this.cell.stateSize])]:[a]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),a={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(a.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===JD.className&&(a.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),t),a)}static fromConfig(t,a,n={}){let r=a.cell,s=us(r,n);return new t(Object.assign(a,{cell:s}))}};Ei.className="RNN";ke.registerClass(Ei);var ng=class extends gt{},zv=class extends ng{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Qa(this.units,"units"),this.activation=Ao(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=oa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oa(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=la(e.kernelRegularizer),this.recurrentRegularizer=la(e.recurrentRegularizer),this.biasRegularizer=la(e.biasRegularizer),this.kernelConstraint=Va(e.kernelConstraint),this.recurrentConstraint=Va(e.recurrentConstraint),this.biasConstraint=Va(e.biasConstraint),this.dropout=Ud([1,Co([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ud([1,Co([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ct(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ae(()=>{if(e=e,e.length!==2)throw new ne(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let a=e[1];e=e[0];let n=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=$o({ones:()=>ur(e),rate:this.dropout,training:n,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=$o({ones:()=>ur(a),rate:this.recurrentDropout,training:n,dropoutFunc:this.dropoutFunc}));let r,s=this.dropoutMask,i=this.recurrentDropoutMask;s!=null?r=Bs(Z(e,s),this.kernel.read()):r=Bs(e,this.kernel.read()),this.bias!=null&&(r=gs(r,this.bias.read())),i!=null&&(a=Z(a,i));let o=ge(r,Bs(a,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Eo(this.activation),useBias:this.useBias,kernelInitializer:ha(this.kernelInitializer),recurrentInitializer:ha(this.recurrentInitializer),biasInitializer:ha(this.biasInitializer),kernelRegularizer:Qt(this.kernelRegularizer),recurrentRegularizer:Qt(this.recurrentRegularizer),biasRegularizer:Qt(this.biasRegularizer),activityRegularizer:Qt(this.activityRegularizer),kernelConstraint:Wa(this.kernelConstraint),recurrentConstraint:Wa(this.recurrentConstraint),biasConstraint:Wa(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};zv.className="SimpleRNNCell";ke.registerClass(zv);var qS=class extends Ei{constructor(e){e.cell=new zv(e),super(e)}call(e,t){return ae(()=>{this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let a=t==null?null:t.mask,n=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:a,training:n,initialState:r})})}static fromConfig(e,t){return new e(t)}};qS.className="SimpleRNN";ke.registerClass(qS);var Lv=class extends ng{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new ne("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Qa(this.units,"units"),this.activation=Ao(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ao(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=oa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oa(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=la(e.kernelRegularizer),this.recurrentRegularizer=la(e.recurrentRegularizer),this.biasRegularizer=la(e.biasRegularizer),this.kernelConstraint=Va(e.kernelConstraint),this.recurrentConstraint=Va(e.recurrentConstraint),this.biasConstraint=Va(e.biasConstraint),this.dropout=Ud([1,Co([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ud([1,Co([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ct(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ae(()=>{if(e=e,e.length!==2)throw new ne(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let a=t.training==null?!1:t.training,n=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=$o({ones:()=>ur(e),rate:this.dropout,training:a,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=$o({ones:()=>ur(n),rate:this.recurrentDropout,training:a,count:3,dropoutFunc:this.dropoutFunc}));let r=this.dropoutMask,s=this.recurrentDropoutMask,i,o,u;0<this.dropout&&this.dropout<1&&(e=Z(e,r[0]));let d=Bs(e,this.kernel.read());this.useBias&&(d=gs(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(n=Z(n,s[0]));let c=this.recurrentKernel.read(),[f,m]=Wn(c,[2*this.units,this.units],c.rank-1),g=Bs(n,f),[b,v,x]=Wn(d,3,d.rank-1),[k,S]=Wn(g,2,g.rank-1);i=this.recurrentActivation.apply(ge(b,k)),o=this.recurrentActivation.apply(ge(v,S));let N=Bs(Z(o,n),m);u=this.activation.apply(ge(x,N));let T=ge(Z(i,n),Z(ge(1,ta(i)),u));return[T,T]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Eo(this.activation),recurrentActivation:Eo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ha(this.kernelInitializer),recurrentInitializer:ha(this.recurrentInitializer),biasInitializer:ha(this.biasInitializer),kernelRegularizer:Qt(this.kernelRegularizer),recurrentRegularizer:Qt(this.recurrentRegularizer),biasRegularizer:Qt(this.biasRegularizer),activityRegularizer:Qt(this.activityRegularizer),kernelConstraint:Wa(this.kernelConstraint),recurrentConstraint:Wa(this.recurrentConstraint),biasConstraint:Wa(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};Lv.className="GRUCell";ke.registerClass(Lv);var jS=class extends Ei{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Lv(e),super(e)}call(e,t){return ae(()=>{this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let a=t==null?null:t.mask,n=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:a,training:n,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};jS.className="GRU";ke.registerClass(jS);var rg=class extends ng{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Qa(this.units,"units"),this.activation=Ao(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Ao(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=oa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=oa(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=oa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=la(e.kernelRegularizer),this.recurrentRegularizer=la(e.recurrentRegularizer),this.biasRegularizer=la(e.biasRegularizer),this.kernelConstraint=Va(e.kernelConstraint),this.recurrentConstraint=Va(e.recurrentConstraint),this.biasConstraint=Va(e.biasConstraint),this.dropout=Ud([1,Co([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ud([1,Co([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Ct(e);let a=e[e.length-1];this.kernel=this.addWeight("kernel",[a,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let n;if(this.useBias){if(this.unitForgetBias){let r=this.biasInitializer,s=this.units;n=new(t=class extends jr{apply(i,o){let u=r.apply([s]),d=new Sv().apply([s]),c=r.apply([s*2]);return jC(jC(u,d),c)}},t.className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ae(()=>{let a=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new ne(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=e[1],r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=$o({ones:()=>ur(e),rate:this.dropout,training:a,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=$o({ones:()=>ur(n),rate:this.recurrentDropout,training:a,count:4,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,o,u,d,c;0<this.dropout&&this.dropout<1&&(e=Z(e,s[0]));let f=Bs(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(n=Z(n,i[0])),f=ge(f,Bs(n,this.recurrentKernel.read())),this.useBias&&(f=gs(f,this.bias.read()));let[m,g,b,v]=Wn(f,4,f.rank-1);o=this.recurrentActivation.apply(m),u=this.recurrentActivation.apply(g),d=ge(Z(u,r),Z(o,this.activation.apply(b))),c=this.recurrentActivation.apply(v);let x=Z(c,this.activation.apply(d));return[x,x,d]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Eo(this.activation),recurrentActivation:Eo(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ha(this.kernelInitializer),recurrentInitializer:ha(this.recurrentInitializer),biasInitializer:ha(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Qt(this.kernelRegularizer),recurrentRegularizer:Qt(this.recurrentRegularizer),biasRegularizer:Qt(this.biasRegularizer),activityRegularizer:Qt(this.activityRegularizer),kernelConstraint:Wa(this.kernelConstraint),recurrentConstraint:Wa(this.recurrentConstraint),biasConstraint:Wa(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};rg.className="LSTMCell";ke.registerClass(rg);var KS=class extends Ei{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new rg(e),super(e)}call(e,t){return ae(()=>{this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let a=t==null?null:t.mask,n=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:a,training:n,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};KS.className="LSTM";ke.registerClass(KS);var Bv=class extends ng{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ae(()=>{e=e;let a=e.slice(1),n=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?n.push(a.splice(0,i.stateSize.length)):n.push(a.splice(0,1));n.reverse();let r=[],s;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];a=n[i],i===0?s=[e[0]].concat(a):s=[s[0]].concat(a),s=o.call(s,t),r.push(s.slice(1))}a=[];for(let i of r.slice().reverse())a.push(...i);return[s[0]].concat(a)})}build(e){Hw(e)&&(e=e[0]),e=e;let t;this.cells.forEach((a,n)=>{Fl(`RNNCell_${n}`,()=>{a.build(e),Array.isArray(a.stateSize)?t=a.stateSize[0]:t=a.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=n=>({className:n.getClassName(),config:n.getConfig()}),a={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),a)}static fromConfig(e,t,a={}){let n=[];for(let r of t.cells)n.push(us(r,a));return new e({cells:n})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let a of this.cells)t.push(...a.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return qw(e)}setWeights(e){let t=[];for(let a of this.cells){let n=a.weights.length,r=e.splice(n);for(let s=0;s<a.weights.length;++s)t.push([a.weights[s],r[s]])}bS(t)}};Bv.className="StackedRNNCells";ke.registerClass(Bv);function $o(e){let{ones:t,rate:a,training:n=!1,count:r=1,dropoutFunc:s}=e,i=()=>s!=null?s(t(),a):tD(t(),a),o=()=>eg(i,t,n);return!r||r<=1?Ba(o().clone()):Array(r).fill(void 0).map(o).map(u=>Ba(u.clone()))}var x9=function(e,t){var a={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,n=Object.getOwnPropertySymbols(e);r<n.length;r++)t.indexOf(n[r])<0&&Object.prototype.propertyIsEnumerable.call(e,n[r])&&(a[n[r]]=e[n[r]]);return a},eM=class extends Ei{constructor(e){if(e.unroll)throw new mt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new mt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ea({ndim:5})]}call(e,t){return ae(()=>{if(this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new ne("ConvRNN2D cell does not support constants");let a=t==null?null:t.mask,n=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:a,training:n,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ae(()=>{let{stateSize:t}=this.cell,a=e.shape,n=this.computeSingleOutputShape(a),r=[n[0],...n.slice(2)],s=da(r);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){ae(()=>{if(!this.stateful)throw new uo("Cannot call resetStates() on an RNN Layer that is not stateful.");let a=this.inputSpec[0].shape,n=this.computeSingleOutputShape(a),r=[n[0],...n.slice(2)];if(a[0]==null)throw new ne("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>da(r)):this.states_=[da(r)];else if(e==null)nt(this.states_),this.keptStates!=null&&(nt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>da(r)):this.states_[0]=da(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new ne(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):nt(this.states_);for(let s=0;s<this.states_.length;++s){let i=e[s],o=r;if(!C.arraysEqual(i.shape,o))throw new ne(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>Ba(s.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:a,kernelSize:n,padding:r,strides:s,dilationRate:i}=this.cell,o=t==="channelsFirst",u=e[o?3:2],d=e[o?4:3],c=cs(u,n[0],r,s[0],i[0]),f=cs(d,n[1],r,s[1],i[1]);return[...e.slice(0,2),...o?[a,c,f]:[c,f,a]]}};eM.className="ConvRNN2D";var Uv=class extends rg{constructor(e){let{filters:t,kernelSize:a,strides:n,padding:r,dataFormat:s,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Qa(this.filters,"filters"),this.kernelSize=Cd(a,2,"kernelSize"),this.kernelSize.forEach(o=>Qa(o,"kernelSize")),this.strides=Cd(n||1,2,"strides"),this.strides.forEach(o=>Qa(o,"strides")),this.padding=r||"valid",Cr(this.padding),this.dataFormat=s||"channelsLast",Sa(this.dataFormat),this.dilationRate=Cd(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>Qa(o,"dilationRate"))}build(e){var t;e=Ct(e);let a=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[a]==null)throw new ne(`The channel dimension of the input should be defined. Found ${e[a]}`);let n=e[a],r=4,s=this.kernelSize.concat([n,this.filters*r]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let u=this.biasInitializer,d=this.filters;o=new(t=class extends jr{apply(c,f){let m=u.apply([d]),g=Pn([d]),b=u.apply([d*2]);return cS([m,g,b])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ae(()=>{if(e.length!==3)throw new ne(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=t.training||!1,n=e[0],r=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=$o({ones:()=>ur(n),rate:this.dropout,training:a,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,u=(ce,L,q)=>!L||!L[q]?ce:Z(L[q],ce),d=u(n,o,0),c=u(n,o,1),f=u(n,o,2),m=u(n,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=$o({ones:()=>ur(r),rate:this.recurrentDropout,training:a,count:i,dropoutFunc:this.dropoutFunc}));let g=this.recurrentDropoutMask,b=u(r,g,0),v=u(r,g,1),x=u(r,g,2),k=u(r,g,3),S=3,[N,T,_,R]=Wn(this.kernel.read(),i,S),[M,F,B,V]=this.useBias?Wn(this.bias.read(),i):[null,null,null,null];d=this.inputConv(d,N,M,this.padding),c=this.inputConv(c,T,F,this.padding),f=this.inputConv(f,_,B,this.padding),m=this.inputConv(m,R,V,this.padding);let[P,A,G,J]=Wn(this.recurrentKernel.read(),i,S);b=this.recurrentConv(b,P),v=this.recurrentConv(v,A),x=this.recurrentConv(x,G),k=this.recurrentConv(k,J);let ee=this.recurrentActivation.apply(ge(d,b)),W=this.recurrentActivation.apply(ge(c,v)),X=ge(Z(W,s),Z(ee,this.activation.apply(ge(f,x)))),Q=Z(this.recurrentActivation.apply(ge(m,k)),this.activation.apply(X));return[Q,Q,X]})}getConfig(){let e=super.getConfig(),{units:t}=e,a=x9(e,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},a),n)}inputConv(e,t,a,n){let r=Cn(e,t,this.strides,n||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return a?gs(r,a,this.dataFormat):r}recurrentConv(e,t){return Cn(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Uv.className="ConvLSTM2DCell";ke.registerClass(Uv);var XS=class extends eM{constructor(e){let t=new Uv(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};XS.className="ConvLSTM2D";ke.registerClass(XS);var Pv=class extends gt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,a=[];for(let n=0;n<this.noiseShape.length;++n)a.push(this.noiseShape[n]==null?t[n]:this.noiseShape[n]);return a}call(e,t){return ae(()=>{this.invokeCallHook(e,t);let a=Qe(e);if(0<this.rate&&this.rate<1){let n=t.training==null?!1:t.training,r=this.getNoiseShape(a);return eg(()=>tD(a,this.rate,r,this.seed),()=>a,n)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Pv.className="Dropout";ke.registerClass(Pv);var YS=class extends Pv{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};YS.className="SpatialDropout1D";ke.registerClass(YS);var ZS=class extends gt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Qa(this.units,"units"),this.activation=Ao(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=oa(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=oa(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Va(e.kernelConstraint),this.biasConstraint=Va(e.biasConstraint),this.kernelRegularizer=la(e.kernelRegularizer),this.biasRegularizer=la(e.biasRegularizer),this.activityRegularizer=la(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Ct(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Ct(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ae(()=>{this.invokeCallHook(e,t);let a=Qe(e),n=KR(this.activation.getClassName()),r;return n!=null?r=Bs(a,this.kernel.read(),n,this.bias?this.bias.read():null):(r=Bs(a,this.kernel.read()),this.bias!=null&&(r=gs(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){let e={units:this.units,activation:Eo(this.activation),useBias:this.useBias,kernelInitializer:ha(this.kernelInitializer),biasInitializer:ha(this.biasInitializer),kernelRegularizer:Qt(this.kernelRegularizer),biasRegularizer:Qt(this.biasRegularizer),activityRegularizer:Qt(this.activityRegularizer),kernelConstraint:Wa(this.kernelConstraint),biasConstraint:Wa(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};ZS.className="Dense";ke.registerClass(ZS);var QS=class extends gt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ct(e);for(let t of e.slice(1))if(t==null)throw new ne(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],vo(e,1)]}call(e,t){return ae(()=>{this.invokeCallHook(e,t);let a=Qe(e);if(this.dataFormat==="channelsFirst"&&a.rank>1){let n=[0];for(let r=2;r<a.rank;++r)n.push(r);n.push(1),a=ut(a,n)}return R7(a)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};QS.className="Flatten";ke.registerClass(QS);var JS=class extends gt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Ao(e.activation)}call(e,t){return ae(()=>{this.invokeCallHook(e,t);let a=Qe(e);return this.activation.apply(a)})}getConfig(){let e={activation:Eo(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};JS.className="Activation";ke.registerClass(JS);var e2=class extends gt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ae(()=>(e=Qe(e),A7(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};e2.className="RepeatVector";ke.registerClass(e2);var t2=class extends gt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let a="Total size of new array must be unchanged.",n=t.slice(),r=1,s=null;for(let o=0;o<n.length;++o){let u=n[o];if(this.isUnknown(u))if(s===null)s=o;else throw new ne("Can only specifiy one unknown dimension.");else r*=u}let i=vo(e);if(s!==null){if(r===0||i%r!==0)throw new ne(a);n[s]=i/r}else if(i!==r)throw new ne(a);return n}computeOutputShape(e){let t=!1;for(let a=0;a<e.length;++a)if(this.isUnknown(e[a])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ae(()=>{this.invokeCallHook(e,t);let a=Qe(e),n=a.shape,r=n.slice(0,1).concat(this.fixUnknownDimension(n.slice(1),this.targetShape));return te(a,r)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};t2.className="Reshape";ke.registerClass(t2);var a2=class extends gt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=ds(1,e.dims.length+1);if(!C.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ea({ndim:this.dims.length+1})]}computeOutputShape(e){e=Ct(e);let t=e.slice();return this.dims.forEach((a,n)=>{t[n+1]=e[a]}),t}call(e,t){return ut(Qe(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};a2.className="Permute";ke.registerClass(a2);var n2=class extends gt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let a=Qe(e);return jf(Xl(a,this.maskValue),-1)}call(e,t){return ae(()=>{this.invokeCallHook(e,t);let a=Qe(e),n=jf(Xl(a,this.maskValue),-1,!0);return Z(a,Te(n,a.dtype))})}};n2.className="Masking";ke.registerClass(n2);var r2=class extends gt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ft(e.inputLength))}this.inputDim=e.inputDim,Qa(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Qa(this.outputDim,"outputDim"),this.embeddingsInitializer=oa(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=la(e.embeddingsRegularizer),this.activityRegularizer=la(e.activityRegularizer),this.embeddingsConstraint=Va(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ae(()=>this.maskZero?(e=Qe(e),Xl(e,St(e))):null)}computeOutputShape(e){if(e=Ct(e),this.inputLength==null)return[...e,this.outputDim];let t=Ft(this.inputLength);if(t.length!==e.length-1)throw new ne(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let a=0;for(let n=0;n<t.length;++n){let r=t[n],s=e[n+1];if(r!=null&&s!=null&&r!==s)throw new ne(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[a]=s),a++}}return[e[0],...t,this.outputDim]}call(e,t){return ae(()=>{this.invokeCallHook(e,t);let a=Qe(e);a.dtype!=="int32"&&(a=ki(a,"int32"));let n=eD(this.embeddings.read(),te(a,[a.size]));return te(n,Ct(this.computeOutputShape(a.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ha(this.embeddingsInitializer),embeddingsRegularizer:Qt(this.embeddingsRegularizer),activityRegularizer:Qt(this.activityRegularizer),embeddingsConstraint:Wa(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};r2.className="Embedding";ke.registerClass(r2);var Ac=class extends gt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new mt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let a=e.slice(0,e.length-t.length);for(let n=0;n<t.length;++n){let r=e[e.length-t.length+n],s=t[n];if(r==null||s==null||r<0||s<0)a.push(null);else if(r===1)a.push(s);else if(s===1)a.push(r);else{if(r!==s)throw new ne("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));a.push(r)}}return a}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ct(e)]),e=e,e.length<2)throw new ne(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=bo(t),t.length>1)throw new ne(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let a=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);a=this.computeElementwiseOpOutputShape(a,s)}let n=e.map(r=>r.length);e.indexOf(null)===-1&&bo(n).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ae(()=>{if(e=e,this.reshapeRequired){let a=[],n=e.map(r=>r.rank);if(n.indexOf(null)===-1){let r=Co(n);for(let s of e){let i=s.rank;for(let o=0;o<r-i;++o)s=Qm(s,1);a.push(s)}return this.mergeFunction(a)}else{let r=!1;for(let o of e){let u=o.rank;if(u==null){let d=o.shape,c=d[0],f=d.slice(1).concat([c]),m=te(o,[c].concat(vo(d.slice(1))));m=ut(m,[1,0]),m=te(m,f),a.push(m),r=!0}else if(u>1){let d=ds(1,u).concat([0]);a.push(ut(o,d)),r=!0}else a.push(o)}let s=this.mergeFunction(a),i=s.rank;if(r){if(i==null){let o=s.shape,u=o.length,d=o[u-1],c=[d].concat(o.slice(0,o.length-1));s=te(ut(te(s,[-1,d]),[1,0]),c)}else if(i>1){let o=[i-1].concat(ds(0,i-1));s=ut(s,o)}}return s}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let n=1;n<e.length;++n){let r=e[n]==null?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let a=[];for(let n of e)n!=null&&n[0]!==null&&a.push(n[0]);return a=bo(a),a.length===1?t=a.concat(t):t=[null].concat(t),t}computeMask(e,t){return ae(()=>{if(t==null)return null;if(!Array.isArray(t))throw new ne("`mask` should be an Array");if(!Array.isArray(e))throw new ne("`inputs` should be an Array");if(t.length!==e.length)throw new ne(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(n=>n==null))return null;t=t.map(n=>n==null?n:Za(n,0));let a=t[0];for(let n=1;n<t.length-1;++n)a=Gr(a,t[n]);return a})}},s2=class extends Ac{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let t=e[0].clone();for(let a=1;a<e.length;++a)t=ge(t,e[a]);return t})}};s2.className="Add";ke.registerClass(s2);var i2=class extends Ac{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let t=e[0].clone();for(let a=1;a<e.length;++a)t=Z(t,e[a]);return t})}};i2.className="Multiply";ke.registerClass(i2);var o2=class extends Ac{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let t=e[0].clone();for(let a=1;a<e.length;++a)t=ge(t,e[a]);return Z(1/e.length,t)})}};o2.className="Average";ke.registerClass(o2);var l2=class extends Ac{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let t=e[0];for(let a=1;a<e.length;++a)t=Hs(t,e[a]);return t})}};l2.className="Maximum";ke.registerClass(l2);var u2=class extends Ac{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let t=e[0];for(let a=1;a<e.length;++a)t=To(t,e[a]);return t})}};u2.className="Minimum";ke.registerClass(u2);var c2=class extends Ac{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new ne("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let n of e)if(n!=null){t=!1;break}if(t)return;let a=[];for(let n=0;n<e.length;++n){let r=e[n].slice();r.splice(this.axis,1);let s=!1;for(let i of a)if(C.arraysEqual(i,r)){s=!0;break}s||a.push(r)}if(a.length>1)throw new ne("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ae(()=>cS(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new ne("A `Concatenate` layer should be called on a list of inputs.");let t=e,a=t[0].slice(),n=this.axis<0?a.length+this.axis:this.axis;for(let r of t.slice(1)){if(a[n]==null||r[n]==null){a[n]=null;break}a[n]+=r[n]}return a}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new ne("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new ne("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new ne(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ae(()=>{let a=!0;if(t.forEach(s=>{if(s!=null){a=!1;return}}),a)return null;let n=[];for(let s=0;s<e.length;++s)t[s]==null?n.push(Te(ur(e[s]),"bool")):t[s].rank<e[s].rank?n.push(Za(t[s],-1)):n.push(t[s]);let r=Gt(n,this.axis);return Vb(r,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};c2.className="Concatenate";ke.registerClass(c2);function If(e,t){for(;e<0;)e+=t;return e}function w9(e,t,a){if(e.shape.length>3||t.shape.length>3)throw new mt("batchDot is not implemented for tensors of 4D or higher rank yet");if(C.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),C.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof a=="number"&&(a=[a,a]),e.dtype==="complex64"||t.dtype==="complex64")throw new mt("batchDot is not implemented for complex64-type Tensors yet.");let n=e.shape.length,r=t.shape.length;a==null&&(a=[n-1,r-2]);let s=a;return ae(()=>{let i;if(n>r){i=n-r;let u=[];for(let d=0;d<i;++d)u.push(1);t=te(t,t.shape.concat(u))}else if(r>n){i=r-n;let u=[];for(let d=0;d<i;++d)u.push(1);e=te(e,e.shape.concat(u))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)s[0]===s[1]?o=ze(Z(e,t),s[0]):o=ze(Z(ut(e,[1,0]),t),s[1]);else{let u=s[0]!==e.shape.length-1,d=s[1]===t.shape.length-1;o=lt(e,t,u,d)}if(i>0){let u;n>r?u=n+r-3:u=n-1;let d=[];for(let c=u;c<u+i;++c)d.push(c);o=Go(o,d)}return o.shape.length===1&&(o=Za(o,1)),o})}var d2=class extends Ac{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){C.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],a=e[1];if(t.length>3||a.length>3)throw new mt("Dot layer does not support tensors of 4D or higher rank yet.");let n=this.interpretAxes(t,a);if(t[n[0]]!==a[n[1]])throw new ne(`Dimension incompatibility: ${t[n[0]]} !== ${a[n[1]]}`)}mergeFunction(e){if(e.length!==2)throw new ne(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],a=e[1],n;return Array.isArray(this.axes)?n=this.axes.map((r,s)=>If(r,e[s].shape.length)):n=[If(this.axes,t.shape.length),If(this.axes,a.shape.length)],this.normalize&&(t=rb(t,n[0]),a=rb(a,n[1])),w9(t,a,n)}interpretAxes(e,t){let a;return Array.isArray(this.axes)?a=this.axes:a=[If(this.axes,e.length),If(this.axes,t.length)],a}computeOutputShape(e){C.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),a=e[1].slice();if(t.length>3||a.length>3)throw new mt("Dot layer does not support tensors of 4D or higher rank yet.");let n=this.interpretAxes(t,a);t.splice(n[0],1),a.splice(n[1],1),a.splice(0,1);let r=t.concat(a);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};d2.className="Dot";ke.registerClass(d2);var h2=class extends gt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ae(()=>{this.invokeCallHook(e,t);let a=Qe(e);return eg(()=>ge(kv(a.shape,0,this.stddev),a),()=>a,t.training||!1)})}};h2.className="GaussianNoise";ke.registerClass(h2);var p2=class extends gt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ae(()=>{this.invokeCallHook(e,t);let a=Qe(e);return this.rate>0&&this.rate<1?eg(()=>{let n=Math.sqrt(this.rate/(1-this.rate));return Z(a,kv(a.shape,1,n))},()=>a,t.training||!1):a})}};p2.className="GaussianDropout";ke.registerClass(p2);var f2=class extends gt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Qe(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ae(()=>{if(this.rate<1&&this.rate>0){let a=this._getNoiseShape(e);return eg(()=>{let n=Qe(e),r=-1.6732632423543772*1.0507009873554805,s=Ti(Wo(a),this.rate);s=ki(s,"float32");let i=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-i*r*this.rate,u=ge(Z(n,s),Z(ge(s,-1),r));return ge(Z(u,i),o)},()=>Qe(e),t.training||!1)}return e})}};f2.className="AlphaDropout";ke.registerClass(f2);function Jf(e,t,a,n,r,s=.001){let i;if(e.rank===2)i=ak(e,t,a,n,r,s);else if(e.rank===3)i=nk(e,t,a,n,r,s);else if(e.rank===4)i=rk(e,t,a,n,r,s);else throw new mt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function k9(e,t,a,n,r=.001){return ae(()=>{let s=Gm(e,n),i=s.mean,o=s.variance;return[Jf(e,i,o,a,t,r),i,o]})}function S9(e,t,a,n,r=.001){return ae(()=>{let s=Gm(e,n),i=s.mean,o=s.variance,u=[];for(let g of ds(0,e.rank))n.indexOf(g)!==-1?u.push(1):u.push(e.shape[g]);let d=te(i,u),c=te(o,u),f=t==null?null:te(t,u),m=a==null?null:te(a,u);return[Jf(e,d,c,m,f,r),i,o]})}function I9(e,t,a,n,r=.001){return C.arraysEqual(n.slice().sort(),ds(0,e.rank-1))?k9(e,t,a,n,r):S9(e,t,a,n,r)}var m2=class extends gt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=oa(e.betaInitializer||"zeros"),this.gammaInitializer=oa(e.gammaInitializer||"ones"),this.movingMeanInitializer=oa(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=oa(e.movingVarianceInitializer||"ones"),this.betaConstraint=Va(e.betaConstraint),this.gammaConstraint=Va(e.gammaConstraint),this.betaRegularizer=la(e.betaRegularizer),this.gammaRegularizer=la(e.gammaRegularizer)}build(e){e=Ct(e);let t=this.axis>=0?this.axis:this.axis+e.length,a=e[t];if(a==null)throw new ne(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ea({ndim:e.length,axes:{[t]:a}})];let n=[a];this.scale&&(this.gamma=this.addWeight("gamma",n,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",n,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",n,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",n,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ae(()=>{let a=t.training==null?!1:t.training,n=Qe(e),r=n.shape,s=r.length,i=ds(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let u=Zl(1,s);u[o]=r[o];let d=i.slice();d.sort();let c=!C.arraysEqual(d,ds(0,s).slice(0,s-1)),f=()=>{if(c){let x=te(this.movingMean.read(),u),k=te(this.movingVariance.read(),u),S=this.center?te(this.beta.read(),u):null,N=this.scale?te(this.gamma.read(),u):null;return Jf(n,x,k,S,N,this.epsilon)}else return Jf(n,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!a)return f();let[m,g,b]=I9(n,this.gamma.read(),this.beta.read(),i,this.epsilon),v=(x,k,S)=>{ae(()=>{let N=1-S,T=x.read(),_=Z($e(T,k),N);x.write($e(T,_))})};return v(this.movingMean,g,this.momentum),v(this.movingVariance,b,this.momentum),m})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ha(this.betaInitializer),gammaInitializer:ha(this.gammaInitializer),movingMeanInitializer:ha(this.movingMeanInitializer),movingVarianceInitializer:ha(this.movingVarianceInitializer),betaRegularizer:Qt(this.betaRegularizer),gammaRegularizer:Qt(this.gammaRegularizer),betaConstraint:Wa(this.betaConstraint),gammaConstraint:Wa(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};m2.className="BatchNormalization";ke.registerClass(m2);var g2=class extends gt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=oa(e.betaInitializer||"zeros"),this.gammaInitializer=oa(e.gammaInitializer||"ones"),this.betaRegularizer=la(e.betaRegularizer),this.gammaRegularizer=la(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Ct(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(let r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==bo(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let a=this.axis.map(r=>e[r]),n=!0;this.scale?this.gamma=this.addWeight("gamma",a,"float32",this.gammaInitializer,this.gammaRegularizer,n):this.gamma=null,this.center?this.beta=this.addWeight("beta",a,"float32",this.betaInitializer,this.betaRegularizer,n):this.beta=null,this.built=!0}call(e,t){let a=Qe(e),n=a.shape,r=n.length;return ae(()=>{let{mean:s,variance:i}=Gm(a,this.axis,!0),o=Zl(1,r);for(let g of this.axis)o[g]=n[g];let u=g=>g!=null&&g.shape.length!==r?te(g,o):g,d=this.scale?u(this.gamma.read()):null,c=this.center?u(this.beta.read()):null,f=[],m=[];for(let g=0;g<r;++g)this.axis.indexOf(g)!==-1?(f.push(n[g]),m.push(1)):(f.push(1),m.push(n[g]));return s=sr(s,f),i=sr(i,f),d!=null&&(d=sr(d,m)),c!=null&&(c=sr(c,m)),Jf(a,s,i,c,d,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ha(this.betaInitializer),gammaInitializer:ha(this.gammaInitializer),betaRegularizer:Qt(this.betaRegularizer),gammaRegularizer:Qt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};g2.className="LayerNormalization";ke.registerClass(g2);function N9(e,t,a){return ae(()=>{if(e.rank!==4)throw new ne(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new ne("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(a==null&&(a=hs()),a!=="channelsLast"&&a!=="channelsFirst")throw new ne(`Unknown data format: ${a}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return a==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],ms(e,n)})}var y2=class extends gt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?hs():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new ne(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,a;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],a=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new ne(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new ne(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);a=e.padding[1]}this.padding=[t,a]}this.inputSpec=[new Ea({ndim:4})]}computeOutputShape(e){e=Ct(e);let t,a;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?a=e[3]+this.padding[1][0]+this.padding[1][1]:a=null,[e[0],e[1],t,a]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?a=e[2]+this.padding[1][0]+this.padding[1][1]:a=null,[e[0],t,a,e[3]])}call(e,t){return ae(()=>N9(Qe(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};y2.className="ZeroPadding2D";ke.registerClass(y2);function Wv(e,t,a,n,r,s){return ae(()=>{Sa(r),YR(s),Cr(n),a==null&&(a=[1,1]),n==null&&(n="valid"),r==null&&(r=hs()),s==null&&(s="max"),e=LS(e,r);let i,o=n==="same"?"same":"valid";return s==="max"?i=Ka(e,t,a,o):i=Ni(e,t,a,o),r==="channelsFirst"&&(i=ut(i,[0,3,1,2])),i})}function tM(e,t,a,n,r,s){return ae(()=>{Sa(r),YR(s),Cr(n),a==null&&(a=[1,1,1]),n==null&&(n="valid"),r==null&&(r=hs()),s==null&&(s="max"),e=VD(e,r);let i,o=n==="same"?"same":"valid";return s==="max"?i=Ck(e,t,a,o):i=tk(e,t,a,o),r==="channelsFirst"&&(i=ut(i,[0,4,1,2,3])),i})}var aM=class extends gt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new ne(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Qa(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new ne(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Qa(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Cr(this.padding),this.inputSpec=[new Ea({ndim:3})]}computeOutputShape(e){e=Ct(e);let t=cs(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ae(()=>{this.invokeCallHook(e,t),e=Qm(Qe(e),2);let a=this.poolingFunction(Qe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Go(a,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},b2=class extends aM{constructor(e){super(e)}poolingFunction(e,t,a,n,r){return Sa(r),Cr(n),Wv(e,t,a,n,r,"max")}};b2.className="MaxPooling1D";ke.registerClass(b2);var v2=class extends aM{constructor(e){super(e)}poolingFunction(e,t,a,n,r){return Sa(r),Cr(n),Wv(e,t,a,n,r,"avg")}};v2.className="AveragePooling1D";ke.registerClass(v2);var nM=class extends gt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new ne(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Qa(this.poolSize,"poolSize"),Qa(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Sa(this.dataFormat),Cr(this.padding),this.inputSpec=[new Ea({ndim:4})]}computeOutputShape(e){e=Ct(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],a=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=cs(t,this.poolSize[0],this.padding,this.strides[0]),a=cs(a,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,a]:[e[0],t,a,e[3]]}call(e,t){return ae(()=>(this.invokeCallHook(e,t),this.poolingFunction(Qe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},x2=class extends nM{constructor(e){super(e)}poolingFunction(e,t,a,n,r){return Sa(r),Cr(n),Wv(e,t,a,n,r,"max")}};x2.className="MaxPooling2D";ke.registerClass(x2);var w2=class extends nM{constructor(e){super(e)}poolingFunction(e,t,a,n,r){return Sa(r),Cr(n),Wv(e,t,a,n,r,"avg")}};w2.className="AveragePooling2D";ke.registerClass(w2);var rM=class extends gt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new ne(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Qa(this.poolSize,"poolSize"),Qa(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Sa(this.dataFormat),Cr(this.padding),this.inputSpec=[new Ea({ndim:5})]}computeOutputShape(e){e=Ct(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],a=this.dataFormat==="channelsFirst"?e[3]:e[2],n=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=cs(t,this.poolSize[0],this.padding,this.strides[0]),a=cs(a,this.poolSize[1],this.padding,this.strides[1]),n=cs(n,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,a,n]:[e[0],t,a,n,e[4]]}call(e,t){return ae(()=>(this.invokeCallHook(e,t),this.poolingFunction(Qe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},k2=class extends rM{constructor(e){super(e)}poolingFunction(e,t,a,n,r){return Sa(r),Cr(n),tM(e,t,a,n,r,"max")}};k2.className="MaxPooling3D";ke.registerClass(k2);var S2=class extends rM{constructor(e){super(e)}poolingFunction(e,t,a,n,r){return Sa(r),Cr(n),tM(e,t,a,n,r,"avg")}};S2.className="AveragePooling3D";ke.registerClass(S2);var sM=class extends gt{constructor(e){super(e),this.inputSpec=[new Ea({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new mt}},I2=class extends sM{constructor(e){super(e||{})}call(e,t){return ae(()=>{let a=Qe(e);return ca(a,1)})}};I2.className="GlobalAveragePooling1D";ke.registerClass(I2);var N2=class extends sM{constructor(e){super(e||{})}call(e,t){return ae(()=>{let a=Qe(e);return Ir(a,1)})}};N2.className="GlobalMaxPooling1D";ke.registerClass(N2);var iM=class extends gt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Sa(this.dataFormat),this.inputSpec=[new Ea({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new mt}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},T2=class extends iM{call(e,t){return ae(()=>{let a=Qe(e);return this.dataFormat==="channelsLast"?ca(a,[1,2]):ca(a,[2,3])})}};T2.className="GlobalAveragePooling2D";ke.registerClass(T2);var _2=class extends iM{call(e,t){return ae(()=>{let a=Qe(e);return this.dataFormat==="channelsLast"?Ir(a,[1,2]):Ir(a,[2,3])})}};_2.className="GlobalMaxPooling2D";ke.registerClass(_2);var oM=class extends gt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,a={}){let n=t.layer,r=us(n,a);delete t.layer;let s={layer:r};return Object.assign(s,t),new e(s)}},C2=class extends oM{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Ct(e),e.length<3)throw new ne(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Ct(e);let t=[e[0]].concat(e.slice(2)),a=this.layer.computeOutputShape(t),n=e[1];return[a[0],n].concat(a.slice(1))}call(e,t){return ae(()=>(e=Qe(e),QD((a,n)=>[Qe(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};C2.className="TimeDistributed";ke.registerClass(C2);function T9(e){Cc(N7,"BidirectionalMergeMode",e)}var _9="concat",E2=class extends oM{constructor(e){super(e);let t=e.layer.getConfig(),a={};a.className=e.layer.getClassName(),a.config=t,this.forwardLayer=us(a),t.goBackwards=t.goBackwards!==!0;let n={};if(n.className=e.layer.getClassName(),n.config=t,this.backwardLayer=us(n),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?_9:e.mergeMode,T9(this.mergeMode),e.weights)throw new mt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,a=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,a)),this.backwardLayer.setWeights(e.slice(a))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let a,n,r;return this.returnState&&(r=t.slice(1)),a=t[0],a=a,this.mergeMode==="concat"?(a[a.length-1]*=2,n=[a]):this.mergeMode==null?n=[a,a.slice()]:n=[a],this.returnState?this.mergeMode==null?n.concat(r).concat(r.slice()):[a].concat(r).concat(r.slice()):Un(n)}apply(e,t){let a=t==null?null:t.initialState,n=t==null?null:t.constants;t==null&&(t={});let r=ZD(e,a,n,this.numConstants);if(e=r.inputs,a=r.initialState,n=r.constants,Array.isArray(e)&&(a=e.slice(1),e=e[0]),(a==null||a.length===0)&&n==null)return super.apply(e,t);let s=[],i=[];if(a!=null){let u=a.length;if(u%2>0)throw new ne("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=a,s.push(...a);let d=a.map(c=>new Ea({shape:c.shape}));this.forwardLayer.stateSpec=d.slice(0,u/2),this.backwardLayer.stateSpec=d.slice(u/2),i.push(...d)}if(n!=null)throw new mt("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof ps;for(let u of s)if(u instanceof ps!==o)throw new ne("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let u=[e].concat(s),d=this.inputSpec.concat(i),c=this.inputSpec;this.inputSpec=d;let f=super.apply(u,t);return this.inputSpec=c,f}else return super.apply(e,t)}call(e,t){return ae(()=>{let a=t.initialState,n,r;if(a==null)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let o=a.slice(0,a.length/2),u=a.slice(a.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let s;this.returnState&&(Array.isArray(n)&&(s=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=_r(r,1));let i;return this.mergeMode==="concat"?i=cS([n,r]):this.mergeMode==="sum"?i=ge(n,r):this.mergeMode==="ave"?i=Z(.5,ge(n,r)):this.mergeMode==="mul"?i=Z(n,r):this.mergeMode==null&&(i=[n,r]),this.returnState?this.mergeMode==null?i.concat(s):[i].concat(s):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Fl(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Fl(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let a;if(this.returnSequences?this.mergeMode==null?a=[t,t]:a=t:this.mergeMode==null?a=[null,null]:a=null,this.returnState){let n=this.forwardLayer.states.map(r=>null);return Array.isArray(a)?a.concat(n).concat(n):[a].concat(n).concat(n)}else return a}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let a=us(t.layer);if(delete t.layer,t.numConstants!=null)throw new mt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let n=t;return n.layer=a,new e(n)}};E2.className="Bidirectional";ke.registerClass(E2);var A2=class extends gt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ae(()=>(e=Qe(e),e.dtype!=="float32"&&(e=ki(e,"float32")),ge(Z(e,this.scale),this.offset)))}};A2.className="Rescaling";ke.registerClass(A2);var{resizeBilinear:C9,cropAndResize:E9}=xr,$2=class extends gt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,a,n,r,s,i,o){return ae(()=>{let u,d=!1,c=t/s,f=a/i,m=(n+t)/s,g=(r+a)/i,b=[c,f,m,g],v=[];e.rank===3?(d=!0,u=$a([e])):u=e;for(let N=0;N<u.shape[0];N++)v.push(b);let x=_n(v,[v.length,4]),k=Yl(0,v.length,1,"int32"),S=E9(u,x,k,[n,r],"nearest");return ki(d?Qe(ya(S)):S,o)})}upsize(e,t,a,n){return ae(()=>{let r=C9(e,[t,a]);return ki(r,n)})}call(e,t){return ae(()=>{let a=Qe(e),n=a.dtype,r=a.shape,s=r[r.length-3],i=r[r.length-2],o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let u=0;return i!==this.width&&(u=Math.floor((i-this.width)/2),u===0&&(u=1)),o>=0&&u>=0?this.centerCrop(a,o,u,this.height,this.width,s,i,n):this.upsize(e,this.height,this.width,n)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ct(e);let t=e.length-3,a=e.length-2;return e[t]=this.height,e[a]=this.width,e}};$2.className="CenterCrop";ke.registerClass($2);function A9(e,t,a,n){let r=Qe(e);if(r.dtype!=="int32"&&(r=ki(r,"int32")),t==="int")return r;let s=r.shape;if(r.rank===0&&(r=Za(r,-1)),t==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=Za(r,-1)),r.rank>2)throw new ne(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${r.rank}.`);let i=["multiHot","oneHot"].includes(t),o=r,u;if(typeof n<"u"&&t==="count"?u=Qy(o,n,a,i):u=Qy(o,[],a,i),t!=="tfIdf")return u;if(n)return Z(u,n);throw new ne("When outputMode is 'tfIdf', weights must be provided.")}var R2=class extends gt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Ct(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ae(()=>{e=Qe(e),e.dtype!=="int32"&&(e=ki(e,"int32"));let a;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new ne(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);a=Qe(t.countWeights)}let n=Ir(e),r=Dd(e),s=Dn(this.numTokens,n).bufferSync().get(0),i=Ti(r,0).bufferSync().get(0);if(!(s&&i))throw new ne(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return A9(e,this.outputMode,this.numTokens,a)})}};R2.className="CategoryEncoding";ke.registerClass(R2);var $9=["bilinear","nearest"],cE=new Set($9),D2=class extends gt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(cE.has(e.interpolation))this.interpolation=e.interpolation;else throw new ne(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Ct(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ae(()=>{let a=[this.height,this.width];if(this.interpolation==="bilinear")return xr.resizeBilinear(e,a,!this.cropToAspectRatio);if(this.interpolation==="nearest")return xr.resizeNearestNeighbor(e,a,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...cE]} are supported`)})}};D2.className="Resizing";ke.registerClass(D2);var lM=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};lM.className="RandomSeed";var uM=class extends gt{constructor(e){super(e),this.randomGenerator=new lM(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};uM.className="BaseRandomLayer";var R9=["bilinear","nearest"],dE=new Set(R9),M2=class extends uM{constructor(e){super(e);let{factor:t,interpolation:a="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ne(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ne(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ne(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(a)if(dE.has(a))this.interpolation=a;else throw new ne(`Invalid interpolation parameter: ${a} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ct(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return ae(()=>{let a=Qe(e);this.imgHeight=a.shape[a.shape.length-3];let n=a.shape[a.shape.length-2];this.widthFactor=Wo([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);let s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return xr.resizeBilinear(e,s);case"nearest":return xr.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...dE]} are supported`)}})}};M2.className="RandomWidth";ke.registerClass(M2);function D9(e){return new rp(e)}function M9(e){return new FS(e)}function F9(e){return new RS(e)}function O9(e){return new DS(e)}function z9(e){return new MS(e)}function L9(e){return new zS(e)}function B9(e){return new OS(e)}function U9(e){return new WS(e)}function P9(e){return new Fv(e)}function W9(e){return new BS(e)}function V9(e){return new Ov(e)}function G9(e){return new US(e)}function H9(e){return new PS(e)}function q9(e){return new VS(e)}function j9(e){return new GS(e)}function K9(e){return new HS(e)}function X9(e){return new JS(e)}function Y9(e){return new ZS(e)}function Z9(e){return new Pv(e)}function Q9(e){return new YS(e)}function J9(e){return new QS(e)}function eY(e){return new e2(e)}function tY(e){return new t2(e)}function aY(e){return new a2(e)}function nY(e){return new r2(e)}function rY(e){return new s2(e)}function sY(e){return new o2(e)}function iY(e){return new c2(e)}function oY(e){return new l2(e)}function lY(e){return new u2(e)}function uY(e){return new i2(e)}function cY(e){return new d2(e)}function dY(e){return new m2(e)}function hY(e){return new g2(e)}function pY(e){return new y2(e)}function F2(e){return new v2(e)}function fY(e){return F2(e)}function mY(e){return F2(e)}function O2(e){return new w2(e)}function gY(e){return O2(e)}function yY(e){return O2(e)}function z2(e){return new S2(e)}function bY(e){return z2(e)}function vY(e){return z2(e)}function xY(e){return new I2(e)}function wY(e){return new T2(e)}function cM(e){return new N2(e)}function dM(e){return new _2(e)}function hM(e){return new b2(e)}function pM(e){return new x2(e)}function kY(e){return new k2(e)}function SY(e){return new jS(e)}function IY(e){return new Lv(e)}function NY(e){return new KS(e)}function TY(e){return new rg(e)}function _Y(e){return new qS(e)}function CY(e){return new zv(e)}function EY(e){return new XS(e)}function AY(e){return new Uv(e)}function $Y(e){return new Ei(e)}function RY(e){return new Bv(e)}function DY(e){return new E2(e)}function MY(e){return new C2(e)}var FY=cM,OY=dM,zY=hM,LY=pM;function BY(e){return new h2(e)}function UY(e){return new p2(e)}function PY(e){return new f2(e)}function WY(e){return new n2(e)}function VY(e){return new A2(e)}function GY(e){return new $2(e)}function HY(e){return new D2(e)}function qY(e){return new R2(e)}function jY(e){return new M2(e)}var fM={};rt(fM,{MAPE:()=>rZ,MSE:()=>oZ,binaryAccuracy:()=>KY,binaryCrossentropy:()=>XY,categoricalAccuracy:()=>ZY,categoricalCrossentropy:()=>QY,cosineProximity:()=>tZ,mape:()=>sZ,meanAbsoluteError:()=>aZ,meanAbsolutePercentageError:()=>nZ,meanSquaredError:()=>iZ,mse:()=>lZ,precision:()=>JY,r2Score:()=>uZ,recall:()=>eZ,sparseCategoricalAccuracy:()=>YY});function KY(e,t){return TS(e,t)}function XY(e,t){return yD(e,t)}function YY(e,t){return bD(e,t)}function ZY(e,t){return _S(e,t)}function QY(e,t){return CS(e,t)}function JY(e,t){return gD(e,t)}function eZ(e,t){return $X(e,t)}function tZ(e,t){return NS(e,t)}function aZ(e,t){return $v(e,t)}function nZ(e,t){return sp(e,t)}function rZ(e,t){return sp(e,t)}function sZ(e,t){return sp(e,t)}function iZ(e,t){return Ec(e,t)}function oZ(e,t){return Ec(e,t)}function lZ(e,t){return Ec(e,t)}function uZ(e,t){return RX(e,t)}var mM={};rt(mM,{modelFromJSON:()=>l9});var gM={};rt(gM,{l1:()=>dZ,l1l2:()=>cZ,l2:()=>hZ});function cZ(e){return new ag(e)}function dZ(e){return m9(e)}function hZ(e){return g9(e)}var yM=class extends Pd{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof bi))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function Ty(e,t){return e<t}function hE(e,t){return e>t}var bM=class extends yM{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new mt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Ty:this.mode==="max"?this.monitorFunc=hE:this.monitor.indexOf("acc")!==-1?this.monitorFunc=hE:this.monitorFunc=Ty,this.monitorFunc===Ty&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Ty?1/0:-1/0}async onEpochEnd(e,t){await oo(t);let a=this.getMonitorValue(t);a!=null&&(this.monitorFunc(a-this.minDelta,this.best)?(this.best=a,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function pZ(e){return new bM(e)}var fZ={earlyStopping:pZ},mZ=ie();mZ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var tr;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(tr||(tr={}));var pE;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(pE||(pE={}));var L2={};function gZ(e,t){let a={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};L2[e]=a}function vM(e){return L2[e]}function yZ(e){delete L2[e]}function E(e,t,a,n,r){let s=t.inputParams[e];if(s&&s.inputIndexStart!==void 0){let o=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?o+1:s.inputIndexEnd,d=o<0?t.inputNames.length+o:o;if(s.type==="tensor")return un(t.inputNames[d],a,n,r);if(s.type==="tensors"){let m=t.inputs.slice(o,u);return t.inputNames.slice(o,u).filter((g,b)=>{var v;return((v=m[b])===null||v===void 0?void 0:v.op)!=="NoOp"}).map(g=>un(g,a,n,r))}let c=un(t.inputNames[d],a,n,r),f=c.dataSync();return s.type==="number"?f[0]:C.toNestedArray(c.shape,f)}let i=t.attrParams[e];return i&&i.value}function un(e,t,a,n){let[r,s]=nr(e,a);if(n!=null){let o=n.getHashTableHandleByName(r);if(o!=null)return o}let i=a.currentContextIds.find(o=>!!t[ub(r,o)]);return i!==void 0?t[ub(r,i)][s]:void 0}function fE(e,t,a){return t[ub(e,a.currentContextId)]}function fi(e,t){let[a,n,r]=nr(e,t);return[ub(a,t&&t.currentContextId),n,r]}function ub(e,t){return t?`${e}-${t}`:e}function nr(e,t){if(e==="")return["",0,void 0];let a=t!=null&&t.parseNodeNameCache!=null;if(a){let s=t.parseNodeNameCache.get(e);if(s!=null)return s}let n=e.split(":"),r;if(n.length===1)r=[e,0,void 0];else{let s=n[0],i=n.length===3?n[1]:void 0,o=Number(n[n.length-1]);r=[s,o,i]}return a&&t.parseNodeNameCache.set(e,r),r}function By(e,t,a){let n=E("pad",e,t,a);if(n==="explicit"){n=E("explicitPaddings",e,t,a);let r=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)r[s][0]=n[s*2],r[s][1]=n[s*2+1];return r}return n}function mi(e){return e.kept?e:zs(e)}var xM={};rt(xM,{json:()=>bZ});var bZ=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],wM={};rt(wM,{json:()=>vZ});var vZ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],kM={};rt(kM,{json:()=>xZ});var xZ=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],SM={};rt(SM,{json:()=>wZ});var wZ=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],IM={};rt(IM,{json:()=>kZ});var kZ=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],NM={};rt(NM,{json:()=>SZ});var SZ=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],TM={};rt(TM,{json:()=>IZ});var IZ=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],_M={};rt(_M,{json:()=>NZ});var NZ=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],CM={};rt(CM,{json:()=>TZ});var TZ=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],EM={};rt(EM,{json:()=>_Z});var _Z=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],AM={};rt(AM,{json:()=>CZ});var CZ=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],$M={};rt($M,{json:()=>EZ});var EZ=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],RM={};rt(RM,{json:()=>AZ});var AZ=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],DM={};rt(DM,{json:()=>$Z});var $Z=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],MM={};rt(MM,{json:()=>RZ});var RZ=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],FM={};rt(FM,{json:()=>DZ});var DZ=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],OM={};rt(OM,{json:()=>MZ});var MZ=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],zM={};rt(zM,{json:()=>FZ});var FZ=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],LM={};rt(LM,{json:()=>OZ});var OZ=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],mE=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[xM,wM,kM,SM,IM,NM,TM,_M,CM,EM,AM,$M,RM,DM,MM,FM,OM,zM,LM],t=[].concat(...e.map(a=>a.json));this.opMappers=t.reduce((a,n)=>(a[n.tfOpName]=n,a),{})}transformGraph(e,t={}){let a=e.node,n=[],r=[],s=[],i=a.reduce((b,v)=>(b[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?n.push(b[v.name]):v.op==="Const"?r.push(b[v.name]):(v.input==null||v.input.length===0)&&s.push(b[v.name]),b),{}),o=[],u=[],d={},c={};t!=null&&(d=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let f=Object.keys(i);f.forEach(b=>{let v=i[b];v.inputNames.forEach((x,k)=>{let[S,,N]=fi(x),T=i[S];if(T.outputs!=null){let _=T.outputs.indexOf(N);if(_!==-1){let R=`${S}:${_}`;v.inputNames[k]=R}}v.inputs.push(T),T.children.push(v)})}),Object.keys(c).length===0?f.forEach(b=>{let v=i[b];v.children.length===0&&u.push(v)}):Object.keys(c).forEach(b=>{let[v]=fi(b),x=i[v];x!=null&&(x.signatureKey=c[b],u.push(x))}),Object.keys(d).length>0?Object.keys(d).forEach(b=>{let[v]=fi(b),x=i[v];x&&(x.signatureKey=d[b],o.push(x))}):o=n;let m={};e.library!=null&&e.library.function!=null&&(m=e.library.function.reduce((b,v)=>(b[v.signature.name]=this.mapFunction(v),b),{}));let g={nodes:i,inputs:o,outputs:u,weights:r,placeholders:n,signature:t,functions:m};return s.length>0&&(g.initNodes=s),g}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,a)=>(t[e[a].name]=a,t),{})}mapNode(e){let t=vM(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let a={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(n=>n.startsWith("^")?n.slice(1):n),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(a.inputParams=t.inputs.reduce((n,r)=>(n[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},n),{})),t.attrs!=null&&(a.attrParams=t.attrs.reduce((n,r)=>{let s=r.type,i;switch(r.type){case"string":i=Qw(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Qw(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":i=s1(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=s1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":i=e1(e.attr,r.tfName,r.defaultValue||0),i===void 0&&r.tfDeprecatedName&&(i=e1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":i=r1(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=r1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":i=Jw(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=Jw(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":i=o1(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=o1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":i=n1(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=n1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":i=i1(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=i1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":i=t1(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=t1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":i=a1(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=a1(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":i=gE(e.attr,r.tfName,r.defaultValue),i===void 0&&r.tfDeprecatedName&&(i=gE(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return n[r.name]={value:i,type:s},n},{})),a}mapFunction(e){let t=e.nodeDef,a=[],n=[],r={};t!=null&&(r=t.reduce((d,c)=>(d[c.name]=this.mapNode(c),c.op==="Const"&&n.push(d[c.name]),d),{}));let s=[],i=[];e.signature.inputArg.forEach(d=>{let[c]=fi(d.name),f={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:B2(d.type),type:"dtype"}},children:[]};f.signatureKey=d.name,s.push(f),r[c]=f}),Object.keys(r).forEach(d=>{let c=r[d];c.inputNames.forEach((f,m)=>{let[g,,b]=fi(f),v=r[g];if(v.outputs!=null){let x=v.outputs.indexOf(b);if(x!==-1){let k=`${g}:${x}`;c.inputNames[m]=k}}c.inputs.push(v),v.children.push(c)})});let o=e.ret;e.signature.outputArg.forEach(d=>{let[c,f]=fi(o[d.name]),m=r[c];m!=null&&(m.defaultOutput=f,i.push(m))});let u=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:i,weights:n,placeholders:a,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a),t),{}),outputs:e.signature.outputArg.reduce((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a,e.ret),t),{})}}mapArgToTensorInfo(e,t){let a=e.name;return t!=null&&(a=t[a]),{name:a,dtype:e.type}}};function zZ(e){let t=ie().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function BM(e,t){let a=Array.isArray(e)?String.fromCharCode.apply(null,e):zZ(e);return t?a:a.toLowerCase()}function Qw(e,t,a,n=!1){let r=e[t];return r!=null?BM(r.s,n):a}function Jw(e,t,a){let n=e[t];return n?n.b:a}function e1(e,t,a){let n=e[t]||{},r=n.i!=null?n.i:n.f!=null?n.f:a;return typeof r=="number"?r:parseInt(r,10)}function B2(e){switch(typeof e=="string"&&(e=tr[e]),e){case tr.DT_FLOAT:case tr.DT_HALF:return"float32";case tr.DT_INT32:case tr.DT_INT64:case tr.DT_INT8:case tr.DT_UINT8:return"int32";case tr.DT_BOOL:return"bool";case tr.DT_DOUBLE:return"float32";case tr.DT_STRING:return"string";case tr.DT_COMPLEX64:case tr.DT_COMPLEX128:return"complex64";default:return null}}function gE(e,t,a){let n=e[t];return n&&n.func?n.func.name:a}function t1(e,t,a){let n=e[t];return n&&n.type?B2(n.type):a}function a1(e,t,a){let n=e[t];return n&&n.list&&n.list.type?n.list.type.map(r=>B2(r)):a}function UM(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function n1(e,t,a){let n=e[t];return n&&n.shape?UM(n.shape):a}function r1(e,t,a){let n=e[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):a}function s1(e,t,a,n=!1){let r=e[t];return r&&r.list&&r.list.s?r.list.s.map(s=>BM(s,n)):a}function i1(e,t,a){let n=e[t];return n&&n.list&&n.list.shape?n.list.shape.map(r=>UM(r)):a}function o1(e,t,a){let n=e[t];return n&&n.list&&n.list.b?n.list.b:a}var LZ=class{constructor(e,t,a){this.node=e,this.tensorMap=t,this.context=a,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(n=>this.getInput(n)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((n,r)=>(n[r]=this.getAttr(r),n),{}))}getInput(e){return un(e,this.tensorMap,this.context)}getAttr(e,t){let a=this.node.rawAttrs[e];if(a.tensor!=null)return un(e,this.tensorMap,this.context);if(a.i!=null||a.f!=null)return e1(this.node.rawAttrs,e,t);if(a.s!=null)return Qw(this.node.rawAttrs,e,t);if(a.b!=null)return Jw(this.node.rawAttrs,e,t);if(a.shape!=null)return n1(this.node.rawAttrs,e,t);if(a.type!=null)return t1(this.node.rawAttrs,e,t);if(a.list!=null){if(a.list.i!=null||a.list.f!=null)return r1(this.node.rawAttrs,e,t);if(a.list.s!=null)return s1(this.node.rawAttrs,e,t);if(a.list.shape!=null)return i1(this.node.rawAttrs,e,t);if(a.list.b!=null)return o1(this.node.rawAttrs,e,t);if(a.list.type!=null)return a1(this.node.rawAttrs,e,t)}return t}},an={};rt(an,{OP_SCOPE_SUFFIX:()=>P1,abs:()=>Ca,acos:()=>q1,acosh:()=>j1,add:()=>ge,addN:()=>e$,all:()=>Vb,any:()=>jf,argMax:()=>ql,argMin:()=>K1,asin:()=>X1,asinh:()=>Y1,atan:()=>Z1,atan2:()=>Q1,atanh:()=>J1,avgPool:()=>Ni,avgPool3d:()=>tk,basicLSTMCell:()=>r$,batchNorm:()=>Ic,batchNorm2d:()=>ak,batchNorm3d:()=>nk,batchNorm4d:()=>rk,batchToSpaceND:()=>zm,bincount:()=>sk,bitwiseAnd:()=>s$,booleanMaskAsync:()=>K$,broadcastArgs:()=>i$,broadcastTo:()=>Ml,buffer:()=>ct,cast:()=>Te,ceil:()=>ik,clipByValue:()=>yn,clone:()=>zs,complex:()=>wi,concat:()=>Gt,concat1d:()=>ok,concat2d:()=>lk,concat3d:()=>uk,concat4d:()=>ck,conv1d:()=>Gb,conv2d:()=>Cn,conv2dTranspose:()=>Hb,conv3d:()=>hk,conv3dTranspose:()=>pk,cos:()=>Lm,cosh:()=>qb,cosineWindow:()=>mv,cumprod:()=>Yf,cumsum:()=>jb,denseBincount:()=>Qy,depthToSpace:()=>fk,depthwiseConv2d:()=>Nc,diag:()=>l$,dilation2d:()=>mk,div:()=>Fe,divNoNan:()=>gk,dot:()=>yk,dropout:()=>qk,einsum:()=>Cl,elu:()=>Zh,enclosingPowerOfTwo:()=>jk,ensureShape:()=>c$,equal:()=>or,erf:()=>Kb,euclideanNorm:()=>xk,exp:()=>bn,expandDims:()=>Za,expm1:()=>wk,eye:()=>Xb,fft:()=>Km,fill:()=>ir,floor:()=>Jh,floorDiv:()=>Wb,fused:()=>Bd,gather:()=>ep,gatherND:()=>Q$,greater:()=>Dn,greaterEqual:()=>Ti,ifft:()=>Ld,imag:()=>Bm,image:()=>xr,inTopKAsync:()=>J$,irfft:()=>lv,isFinite:()=>kk,isInf:()=>Sk,isNaN:()=>Ik,leakyRelu:()=>Um,less:()=>Md,lessEqual:()=>Po,linalg:()=>Yk,linspace:()=>m$,localResponseNormalization:()=>Nk,log:()=>lr,log1p:()=>Pm,logSigmoid:()=>Tk,logSoftmax:()=>Zb,logSumExp:()=>Wm,logicalAnd:()=>Gr,logicalNot:()=>Vm,logicalOr:()=>Qb,logicalXor:()=>_k,losses:()=>dR,lowerBound:()=>y$,matMul:()=>lt,max:()=>Ir,maxPool:()=>Ka,maxPool3d:()=>Ck,maxPoolWithArgmax:()=>b$,maximum:()=>Hs,mean:()=>ca,meshgrid:()=>v$,min:()=>Dd,minimum:()=>To,mirrorPad:()=>Ek,mod:()=>Ak,moments:()=>Gm,movingAverage:()=>X$,mul:()=>Z,multiRNNCell:()=>x$,multinomial:()=>w$,neg:()=>ta,norm:()=>Qh,notEqual:()=>Xl,oneHot:()=>Fd,ones:()=>Pn,onesLike:()=>ur,op:()=>K,outerProduct:()=>k$,pad:()=>ms,pad1d:()=>S$,pad2d:()=>I$,pad3d:()=>N$,pad4d:()=>T$,pool:()=>$k,pow:()=>Ps,prelu:()=>qm,print:()=>H1,prod:()=>Rk,raggedGather:()=>_$,raggedRange:()=>C$,raggedTensorToTensor:()=>E$,rand:()=>A$,randomGamma:()=>M$,randomNormal:()=>ev,randomStandardNormal:()=>F$,randomUniform:()=>Wo,randomUniformInt:()=>O$,range:()=>Yl,real:()=>Od,reciprocal:()=>zk,relu:()=>Ot,relu6:()=>tv,reshape:()=>te,reverse:()=>_r,reverse1d:()=>z$,reverse2d:()=>L$,reverse3d:()=>B$,reverse4d:()=>U$,rfft:()=>Xm,round:()=>av,rsqrt:()=>nv,scalar:()=>We,scatterND:()=>Y$,searchSorted:()=>Jb,selu:()=>rv,separableConv2d:()=>tp,setdiff1dAsync:()=>P$,sigmoid:()=>Vr,sign:()=>Lk,signal:()=>cR,sin:()=>sv,sinh:()=>iv,slice:()=>bt,slice1d:()=>jm,slice2d:()=>ov,slice3d:()=>ap,slice4d:()=>zd,softmax:()=>Vo,softplus:()=>Tc,spaceToBatchND:()=>Hm,sparse:()=>hR,sparseToDense:()=>Z$,spectral:()=>uR,split:()=>Wn,sqrt:()=>en,square:()=>Vt,squaredDifference:()=>uv,squeeze:()=>Go,stack:()=>$a,step:()=>_c,stridedSlice:()=>Bk,string:()=>pR,sub:()=>$e,sum:()=>ze,tan:()=>Uk,tanh:()=>No,tensor:()=>_n,tensor1d:()=>Mt,tensor2d:()=>Ls,tensor3d:()=>cv,tensor4d:()=>_o,tensor5d:()=>W$,tensor6d:()=>V$,tensorScatterUpdate:()=>H$,tile:()=>sr,topk:()=>Wk,transpose:()=>ut,truncatedNormal:()=>pv,unique:()=>Vk,unsortedSegmentSum:()=>fv,unstack:()=>ya,upperBound:()=>q$,variable:()=>Gk,where:()=>Ja,whereAsync:()=>Hk,zeros:()=>da,zerosLike:()=>St});var BZ=(e,t,a,n=an)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(E("a",e,t,a),E("b",e,t,a))];case"AddN":return[n.addN(E("tensors",e,t,a))];case"FloorMod":case"Mod":return[n.mod(E("a",e,t,a),E("b",e,t,a))];case"Mul":return[n.mul(E("a",e,t,a),E("b",e,t,a))];case"RealDiv":case"Div":return[n.div(E("a",e,t,a),E("b",e,t,a))];case"DivNoNan":return[n.divNoNan(E("a",e,t,a),E("b",e,t,a))];case"FloorDiv":return[n.floorDiv(E("a",e,t,a),E("b",e,t,a))];case"Sub":return[n.sub(E("a",e,t,a),E("b",e,t,a))];case"Minimum":return[n.minimum(E("a",e,t,a),E("b",e,t,a))];case"Maximum":return[n.maximum(E("a",e,t,a),E("b",e,t,a))];case"Pow":return[n.pow(E("a",e,t,a),E("b",e,t,a))];case"SquaredDifference":return[n.squaredDifference(E("a",e,t,a),E("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},UZ=(e,t,a,n=an)=>{switch(e.op){case"Abs":case"ComplexAbs":return[n.abs(E("x",e,t,a))];case"Acos":return[n.acos(E("x",e,t,a))];case"Acosh":return[n.acosh(E("x",e,t,a))];case"Asin":return[n.asin(E("x",e,t,a))];case"Asinh":return[n.asinh(E("x",e,t,a))];case"Atan":return[n.atan(E("x",e,t,a))];case"Atan2":return[n.atan2(E("x",e,t,a),E("y",e,t,a))];case"Atanh":return[n.atanh(E("x",e,t,a))];case"Ceil":return[n.ceil(E("x",e,t,a))];case"Complex":return[n.complex(E("real",e,t,a),E("imag",e,t,a))];case"Cos":return[n.cos(E("x",e,t,a))];case"Cosh":return[n.cosh(E("x",e,t,a))];case"Elu":return[n.elu(E("x",e,t,a))];case"Erf":return[n.erf(E("x",e,t,a))];case"Exp":return[n.exp(E("x",e,t,a))];case"Expm1":return[n.expm1(E("x",e,t,a))];case"Floor":return[n.floor(E("x",e,t,a))];case"Log":return[n.log(E("x",e,t,a))];case"Log1p":return[n.log1p(E("x",e,t,a))];case"Imag":return[n.imag(E("x",e,t,a))];case"Neg":return[n.neg(E("x",e,t,a))];case"Reciprocal":return[n.reciprocal(E("x",e,t,a))];case"Real":return[n.real(E("x",e,t,a))];case"Relu":return[n.relu(E("x",e,t,a))];case"Round":return[n.round(E("x",e,t,a))];case"Selu":return[n.selu(E("x",e,t,a))];case"Sigmoid":return[n.sigmoid(E("x",e,t,a))];case"Sin":return[n.sin(E("x",e,t,a))];case"Sign":return[n.sign(E("x",e,t,a))];case"Sinh":return[n.sinh(E("x",e,t,a))];case"Softplus":return[n.softplus(E("x",e,t,a))];case"Sqrt":return[n.sqrt(E("x",e,t,a))];case"Square":return[n.square(E("x",e,t,a))];case"Tanh":return[n.tanh(E("x",e,t,a))];case"Tan":return[n.tan(E("x",e,t,a))];case"ClipByValue":return[n.clipByValue(E("x",e,t,a),E("clipValueMin",e,t,a),E("clipValueMax",e,t,a))];case"Relu6":return[n.relu6(E("x",e,t,a))];case"Rsqrt":return[n.rsqrt(un(e.inputNames[0],t,a))];case"LeakyRelu":return[n.leakyRelu(E("x",e,t,a),E("alpha",e,t,a))];case"Prelu":return[n.prelu(E("x",e,t,a),E("alpha",e,t,a))];case"IsNan":return[n.isNaN(un(e.inputNames[0],t,a))];case"IsInf":return[n.isInf(un(e.inputNames[0],t,a))];case"IsFinite":return[n.isFinite(un(e.inputNames[0],t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Wr(e,t,a=""){if(!(typeof e=="number"||typeof t=="number")){C.assert(e.length===t.length,()=>a+` Shapes ${e} and ${t} must match`);for(let n=0;n<e.length;n++){let r=e[n],s=t[n];C.assert(r<0||s<0||r===s,()=>a+` Shapes ${e} and ${t} must match`)}}}function yE(e){return!(typeof e=="number"||e.some(t=>t<0))}function Nf(e,t,a){let n=l1(e,a),r=!yE(n);if(r&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(r&&t.forEach(s=>{n=l1(s.shape,n)}),!yE(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function l1(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let a=[];for(let n=0;n<e.length;++n){let r=e[n],s=t[n];if(r>=0&&s>=0&&r!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);a[n]=r>=0?r:s}return a}var PZ=class{constructor(e,t,a,n,r,s,i){this.name=e,this.dtype=t,this.maxSize=a,this.elementShape=n,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=We(0),Ba(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Wr(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);a.tensor=t,Ba(t),a.written=!0,this.tensors[e]=a}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((a,n)=>this.write(a,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let n=0;n<this.size();n++)e.push(n)}if(e.length===0)return _n([],[0].concat(this.elementShape));let a=this.readMany(e);return Wr(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),$a(a,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return _n([],[0].concat(this.elementShape));let t=[];for(let n=0;n<this.size();n++)t.push(n);let a=this.readMany(t);return Wr(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),Gt(a,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let a=Math.max(...e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(e,ya(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let a=0,n=e.map(o=>(a+=o,a));if(a!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${a}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let r=a===0?0:t.size/a,s=[];ae(()=>{t=te(t,[1,a,r]);for(let o=0;o<e.length;++o){let u=[0,o===0?0:n[o-1],0],d=[1,e[o],r];s[o]=te(bt(t,u,d),this.elementShape)}return s});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},Vv=class u1{get id(){return this.idTensor.id}constructor(t,a,n,r=-1){this.tensors=t,this.elementShape=a,this.elementDtype=n,t!=null&&t.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Wr(a,s.shape,"TensorList shape mismatch: "),Ba(s)}),this.idTensor=We(0),this.maxNumElements=r,Ba(this.idTensor)}copy(){return new u1([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(a=>{(t==null||!t.has(a.id))&&a.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,a,n=-1){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Wr(t,this.elementShape,"TensorList shape mismatch: ");let r=Nf(this.elementShape,this.tensors,t);return ae(()=>{let s=this.tensors.map(i=>te(i,r));return $a(s,0)})}popBack(t,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=Nf(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,Wr(r.shape,t,"TensorList shape mismatch: "),te(r,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Wr(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ba(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let a=new u1([],this.elementShape,this.elementDtype,this.maxNumElements);a.tensors.length=t;for(let n=0;n<Math.min(this.tensors.length,t);++n)a.tensors[n]=this.tensors[n];return a}getItem(t,a,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Wr(this.tensors[t].shape,a,"TensorList shape mismatch: ");let r=Nf(this.elementShape,this.tensors,a);return te(this.tensors[t],r)}setItem(t,a){if(a.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Wr(this.elementShape,a.shape,"TensorList shape mismatch: "),Ba(a),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=a}gather(t,a,n){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);Wr(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());let r=Nf(this.elementShape,this.tensors,n);return t.length===0?_n([],[0].concat(r)):ae(()=>{let s=t.map(i=>te(this.tensors[i],r));return $a(s,0)})}concat(t,a){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Wr(this.elementShape,a,"TensorList shape mismatch: ");let n=Nf(this.elementShape,this.tensors,a);return this.size()===0?_n([],[0].concat(n)):ae(()=>{let r=this.tensors.map(s=>te(s,n));return Gt(r,0)})}};function WZ(e,t,a){let n=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==a)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${a}`);let r=e.shape.slice(1);Wr(r,t,"TensorList shape mismatch: ");let s=ya(e);return new Vv(s,t,n)}function VZ(e,t,a,n){return new Vv([],e,t,n)}function GZ(e,t,a,n){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let r=Math.max(...t);if(n!=null&&n!==-1&&r>=n)throw new Error(`Max index must be < array size (${r}  vs. ${n})`);let s=new Vv([],a,e.dtype,n),i=ya(e,0);return t.forEach((o,u)=>{s.setItem(o,i[u])}),s}function HZ(e,t,a){let n=0,r=t.map(c=>(n+=c,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=l1(s,a),o=n===0?0:e.size/n,u=ae(()=>{let c=[];e=te(e,[1,n,o]);for(let f=0;f<t.length;++f){let m=[0,f===0?0:r[f-1],0],g=[1,t[f],o];c[f]=te(bt(e,m,g),i)}return e.dispose(),c}),d=new Vv([],a,e.dtype,t.length);for(let c=0;c<u.length;c++)d.setItem(c,u[c]);return d}var qZ=async(e,t,a)=>{switch(e.op){case"If":case"StatelessIf":{let n=E("thenBranch",e,t,a),r=E("elseBranch",e,t,a),s=E("cond",e,t,a),i=E("args",e,t,a);return(await s.data())[0]?a.functionMap[n].executeFunctionAsync(i,a.tensorArrayMap,a.tensorListMap):a.functionMap[r].executeFunctionAsync(i,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{let n=E("body",e,t,a),r=E("cond",e,t,a),s=E("args",e,t,a),i=await a.functionMap[r].executeFunctionAsync(s,a.tensorArrayMap,a.tensorListMap),o=s.map(c=>c.id),u=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let d=s;for(;u[0];){let c=d;d=await a.functionMap[n].executeFunctionAsync(d,a.tensorArrayMap,a.tensorListMap);let f=d.map(g=>g.id);c.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()});let m=await a.functionMap[r].executeFunctionAsync(d,a.tensorArrayMap,a.tensorListMap);u=await m[0].data(),m.forEach(g=>{!g.kept&&o.indexOf(g.id)===-1&&f.indexOf(g.id)===-1&&g.dispose()})}return d}case"LoopCond":{let n=E("pred",e,t,a);return[mi(n)]}case"Switch":{let n=E("pred",e,t,a),r=E("data",e,t,a);return r.kept||(r=mi(r)),(await n.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{let n=e.inputNames.find(r=>un(r,t,a)!==void 0);if(n){let r=un(n,t,a);return[mi(r)]}return}case"Enter":{let n=E("frameName",e,t,a),r=E("tensor",e,t,a);return a.enterFrame(n),[mi(r)]}case"Exit":{let n=E("tensor",e,t,a);return a.exitFrame(),[mi(n)]}case"NextIteration":{let n=E("tensor",e,t,a);return a.nextIteration(),[mi(n)]}case"TensorArrayV3":{let n=E("size",e,t,a),r=E("dtype",e,t,a),s=E("elementShape",e,t,a),i=E("dynamicSize",e,t,a),o=E("clearAfterRead",e,t,a),u=E("identicalElementShapes",e,t,a),d=E("name",e,t,a),c=new PZ(d,r,n,s,u,i,o);return a.addTensorArray(c),[c.idTensor,We(1)]}case"TensorArrayWriteV3":{let n=E("tensorArrayId",e,t,a),r=E("index",e,t,a),s=E("tensor",e,t,a),i=a.getTensorArray(n.id);return i.write(r,s),[i.idTensor]}case"TensorArrayReadV3":{let n=E("tensorArrayId",e,t,a),r=E("index",e,t,a);return[a.getTensorArray(n.id).read(r)]}case"TensorArrayGatherV3":{let n=E("tensorArrayId",e,t,a),r=E("indices",e,t,a),s=E("dtype",e,t,a);return[a.getTensorArray(n.id).gather(r,s)]}case"TensorArrayScatterV3":{let n=E("tensorArrayId",e,t,a),r=E("indices",e,t,a),s=E("tensor",e,t,a),i=a.getTensorArray(n.id);return i.scatter(r,s),[i.idTensor]}case"TensorArrayConcatV3":{let n=E("tensorArrayId",e,t,a),r=a.getTensorArray(n.id),s=E("dtype",e,t,a);return[r.concat(s)]}case"TensorArraySplitV3":{let n=E("tensorArrayId",e,t,a),r=E("tensor",e,t,a),s=E("lengths",e,t,a),i=a.getTensorArray(n.id);return i.split(s,r),[i.idTensor]}case"TensorArraySizeV3":{let n=E("tensorArrayId",e,t,a),r=a.getTensorArray(n.id);return[We(r.size(),"int32")]}case"TensorArrayCloseV3":{let n=E("tensorArrayId",e,t,a),r=a.getTensorArray(n.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{let n=E("tensorListId",e,t,a),r=E("index",e,t,a),s=E("tensor",e,t,a),i=a.getTensorList(n.id);return i.setItem(r,s),[i.idTensor]}case"TensorListGetItem":{let n=E("tensorListId",e,t,a),r=E("index",e,t,a),s=E("elementShape",e,t,a),i=E("elementDType",e,t,a);return[a.getTensorList(n.id).getItem(r,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let n=E("indices",e,t,a),r=E("tensor",e,t,a),s=E("elementShape",e,t,a),i=E("numElements",e,t,a),o=GZ(r,n,s,i);return a.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=E("elementShape",e,t,a),r=E("elementDType",e,t,a),s;e.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=E(s,e,t,a),o=e.op==="TensorListReserve"?-1:i,u=VZ(n,r,i,o);return a.addTensorList(u),[u.idTensor]}case"TensorListGather":{let n=E("tensorListId",e,t,a),r=E("indices",e,t,a),s=E("elementShape",e,t,a),i=E("elementDType",e,t,a);return[a.getTensorList(n.id).gather(r,i,s)]}case"TensorListStack":{let n=E("tensorListId",e,t,a),r=E("elementShape",e,t,a),s=E("elementDType",e,t,a),i=E("numElements",e,t,a);return[a.getTensorList(n.id).stack(r,s,i)]}case"TensorListFromTensor":{let n=E("tensor",e,t,a),r=E("elementShape",e,t,a),s=E("elementDType",e,t,a),i=WZ(n,r,s);return a.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let n=E("tensorListId",e,t,a),r=a.getTensorList(n.id),s=E("dtype",e,t,a),i=E("elementShape",e,t,a);return[r.concat(s,i)]}case"TensorListPushBack":{let n=E("tensorListId",e,t,a),r=E("tensor",e,t,a),s=a.getTensorList(n.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{let n=E("tensorListId",e,t,a),r=E("elementShape",e,t,a),s=E("elementDType",e,t,a);return[a.getTensorList(n.id).popBack(r,s)]}case"TensorListSplit":{let n=E("tensor",e,t,a),r=E("elementShape",e,t,a),s=E("lengths",e,t,a),i=HZ(n,s,r);return a.addTensorList(i),[i.idTensor]}case"TensorListLength":{let n=E("tensorListId",e,t,a),r=a.getTensorList(n.id);return[We(r.size(),"int32")]}case"TensorListResize":{let n=E("tensorListId",e,t,a),r=E("size",e,t,a),s=a.getTensorList(n.id).resize(r);return a.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function bE(e,t,a){let[n,r]=E("fusedOps",e,t,a),s=n==="biasadd",i=!s,o=r==="prelu",u=n==="fusedbatchnorm",d=E("numArgs",e,t,a);if(s){if(o&&d!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&d!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=E("strides",e,t,a),f=By(e,t,a),m=E("dataFormat",e,t,a).toUpperCase(),g=E("dilations",e,t,a),[b,v]=E("args",e,t,a);i&&(v=b,b=void 0);let x=E("leakyreluAlpha",e,t,a);return{stride:c,pad:f,dataFormat:m,dilations:g,biasArg:b,preluArg:v,activationFunc:r,leakyreluAlpha:x}}var jZ=(e,t,a,n=an)=>{switch(e.op){case"Conv1D":{let r=E("stride",e,t,a),s=E("pad",e,t,a),i=E("dataFormat",e,t,a).toUpperCase(),o=E("dilation",e,t,a);return[n.conv1d(E("x",e,t,a),E("filter",e,t,a),r,s,i,o)]}case"Conv2D":{let r=E("strides",e,t,a),s=By(e,t,a),i=E("dataFormat",e,t,a).toUpperCase(),o=E("dilations",e,t,a);return[n.conv2d(E("x",e,t,a),E("filter",e,t,a),[r[1],r[2]],s,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:u,preluArg:d,activationFunc:c,leakyreluAlpha:f}=bE(e,t,a);return[n.fused.conv2d({x:E("x",e,t,a),filter:E("filter",e,t,a),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:d,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:s,dataFormat:i,dilations:o,biasArg:u,preluArg:d,activationFunc:c,leakyreluAlpha:f}=bE(e,t,a);return[n.fused.depthwiseConv2d({x:E("x",e,t,a),filter:E("filter",e,t,a),strides:[r[1],r[2]],pad:s,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:c,preluActivationWeights:d,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=E("outputShape",e,t,a),s=E("strides",e,t,a),i=By(e,t,a);return[n.conv2dTranspose(E("x",e,t,a),E("filter",e,t,a),r,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=E("strides",e,t,a),s=By(e,t,a),i=E("dilations",e,t,a),o=E("dataFormat",e,t,a).toUpperCase();return[n.depthwiseConv2d(E("input",e,t,a),E("filter",e,t,a),[r[1],r[2]],s,o,[i[1],i[2]])]}case"Conv3D":{let r=E("strides",e,t,a),s=E("pad",e,t,a),i=E("dataFormat",e,t,a).toUpperCase(),o=E("dilations",e,t,a);return[n.conv3d(E("x",e,t,a),E("filter",e,t,a),[r[1],r[2],r[3]],s,i,[o[1],o[2],o[3]])]}case"AvgPool":{let r=E("strides",e,t,a),s=E("pad",e,t,a),i=E("kernelSize",e,t,a);return[n.avgPool(E("x",e,t,a),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPool":{let r=E("strides",e,t,a),s=E("pad",e,t,a),i=E("kernelSize",e,t,a);return[n.maxPool(E("x",e,t,a),[i[1],i[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{let r=E("strides",e,t,a),s=E("pad",e,t,a),i=E("kernelSize",e,t,a),o=E("includeBatchInIndex",e,t,a),{result:u,indexes:d}=n.maxPoolWithArgmax(E("x",e,t,a),[i[1],i[2]],[r[1],r[2]],s,o);return[u,d]}case"AvgPool3D":{let r=E("strides",e,t,a),s=E("pad",e,t,a),i=E("kernelSize",e,t,a);return[n.avgPool3d(E("x",e,t,a),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{let r=E("strides",e,t,a),s=E("pad",e,t,a),i=E("kernelSize",e,t,a);return[n.maxPool3d(E("x",e,t,a),[i[1],i[2],i[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{let r=E("strides",e,t,a),s=E("pad",e,t,a),i=E("dilations",e,t,a),o=r[1],u=r[2],d=i[1],c=i[2];return[n.dilation2d(E("x",e,t,a),E("filter",e,t,a),[o,u],s,[d,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},KZ=(e,t,a,n=an)=>{switch(e.op){case"Fill":{let r=E("shape",e,t,a),s=E("dtype",e,t,a),i=E("value",e,t,a);return[n.fill(r,i,s)]}case"LinSpace":{let r=E("start",e,t,a),s=E("stop",e,t,a),i=E("num",e,t,a);return[n.linspace(r,s,i)]}case"Multinomial":{let r=E("logits",e,t,a),s=E("numSamples",e,t,a),i=E("seed",e,t,a);return[n.multinomial(r,s,i)]}case"OneHot":{let r=E("indices",e,t,a),s=E("depth",e,t,a),i=E("onValue",e,t,a),o=E("offValue",e,t,a),u=E("dtype",e,t,a);return[n.oneHot(r,s,i,o,u)]}case"Ones":return[n.ones(E("shape",e,t,a),E("dtype",e,t,a))];case"OnesLike":return[n.onesLike(E("x",e,t,a))];case"RandomStandardNormal":return[n.randomStandardNormal(E("shape",e,t,a),E("dtype",e,t,a),E("seed",e,t,a))];case"RandomUniform":return[n.randomUniform(E("shape",e,t,a),E("minval",e,t,a),E("maxval",e,t,a),E("dtype",e,t,a))];case"RandomUniformInt":return[n.randomUniformInt(E("shape",e,t,a),E("minval",e,t,a),E("maxval",e,t,a),E("seed",e,t,a))];case"Range":{let r=E("start",e,t,a),s=E("stop",e,t,a),i=E("step",e,t,a);return[n.range(r,s,i,E("dtype",e,t,a))]}case"TruncatedNormal":{let r=E("shape",e,t,a),s=E("mean",e,t,a),i=E("stdDev",e,t,a),o=E("seed",e,t,a);return[n.truncatedNormal(r,s,i,E("dtype",e,t,a),o)]}case"Zeros":return[n.zeros(E("shape",e,t,a),E("dtype",e,t,a))];case"ZerosLike":return[n.zerosLike(E("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function mw(e,t,a){let n=E("boxes",e,t,a),r=E("scores",e,t,a),s=E("maxOutputSize",e,t,a),i=E("iouThreshold",e,t,a),o=E("scoreThreshold",e,t,a),u=E("softNmsSigma",e,t,a);return{boxes:n,scores:r,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:u}}var XZ=async(e,t,a,n,r=an)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:d,softNmsSigma:c}=mw(e,t,a),f=await r.image.nonMaxSuppressionWithScoreAsync(s,i,o,u,d,c);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:d}=mw(e,t,a),c=E("padToMaxOutputSize",e,t,a),f=await r.image.nonMaxSuppressionPaddedAsync(s,i,o,u,d,c);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:i,maxOutputSize:o,iouThreshold:u,scoreThreshold:d}=mw(e,t,a);return[await r.image.nonMaxSuppressionAsync(s,i,o,u,d)]}case"Where":{let s=r.cast(E("condition",e,t,a),"bool"),i=[await r.whereAsync(s)];return s.dispose(),i}case"ListDiff":return r.setdiff1dAsync(E("x",e,t,a),E("y",e,t,a));default:throw TypeError(`Node type ${e.op} is not implemented`)}},YZ=(e,t,a,n=an)=>{switch(e.op){case"LowerBound":{let r=E("sortedSequence",e,t,a),s=E("values",e,t,a);return[n.lowerBound(r,s)]}case"TopKV2":{let r=E("x",e,t,a),s=E("k",e,t,a),i=E("sorted",e,t,a),o=n.topk(r,s,i);return[o.values,o.indices]}case"UpperBound":{let r=E("sortedSequence",e,t,a),s=E("values",e,t,a);return[n.upperBound(r,s)]}case"Unique":{let r=E("x",e,t,a),s=n.unique(r);return[s.values,s.indices]}case"UniqueV2":{let r=E("x",e,t,a),s=E("axis",e,t,a),i=n.unique(r,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},ZZ=(e,t,a,n=an)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=E("default",e,t,a);return[un(e.name,t,a)||r];case"Placeholder":return[un(e.name,t,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=E("x",e,t,a);return[mi(c)]}case"IdentityN":return E("x",e,t,a).map(c=>mi(c));case"Snapshot":let s=E("x",e,t,a);return[mi(s)];case"Shape":return[n.tensor1d(E("x",e,t,a).shape,"int32")];case"ShapeN":return E("x",e,t,a).map(c=>n.tensor1d(c.shape));case"Size":return[n.scalar(E("x",e,t,a).size,"int32")];case"Rank":return[n.scalar(E("x",e,t,a).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":let i=E("x",e,t,a),o=E("data",e,t,a),u=E("message",e,t,a),d=E("summarize",e,t,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,d));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},QZ=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=We(0),this.tensorMap=new Map,Ba(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return We(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let a=await e.data();return this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),ae(()=>{let n=ya(t),r=a.length,s=n.length;C.assert(r===s,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`);for(let i=0;i<r;i++){let o=a[i],u=n[i];Ba(u),this.tensorMap.set(o,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let a=await e.data();return ae(()=>{let n=[];for(let r=0;r<a.length;r++){let s=a[r],i=this.findWithDefault(s,t);n.push(i)}return $a(n)})}findWithDefault(e,t){let a=this.tensorMap.get(e);return a??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},JZ=async(e,t,a,n)=>{switch(e.op){case"HashTable":case"HashTableV2":{let r=n.getHashTableHandleByName(e.name);if(r!=null)return[r];{let s=E("keyDType",e,t,a),i=E("valueDType",e,t,a),o=new QZ(s,i);return n.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let r=E("tableHandle",e,t,a,n),s=E("keys",e,t,a),i=E("values",e,t,a);return[await n.getHashTableById(r.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let r=E("tableHandle",e,t,a,n),s=E("keys",e,t,a),i=E("defaultValue",e,t,a);return[await n.getHashTableById(r.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let r=E("tableHandle",e,t,a,n);return[n.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},eQ=(e,t,a,n=an)=>{switch(e.op){case"ResizeBilinear":{let r=E("images",e,t,a),s=E("size",e,t,a),i=E("alignCorners",e,t,a),o=E("halfPixelCenters",e,t,a);return[n.image.resizeBilinear(r,[s[0],s[1]],i,o)]}case"ResizeNearestNeighbor":{let r=E("images",e,t,a),s=E("size",e,t,a),i=E("alignCorners",e,t,a),o=E("halfPixelCenters",e,t,a);return[n.image.resizeNearestNeighbor(r,[s[0],s[1]],i,o)]}case"CropAndResize":{let r=E("image",e,t,a),s=E("boxes",e,t,a),i=E("boxInd",e,t,a),o=E("cropSize",e,t,a),u=E("method",e,t,a),d=E("extrapolationValue",e,t,a);return[n.image.cropAndResize(r,s,i,o,u,d)]}case"ImageProjectiveTransformV3":{let r=E("images",e,t,a),s=E("transforms",e,t,a),i=E("outputShape",e,t,a),o=E("fillValue",e,t,a),u=E("interpolation",e,t,a),d=E("fillMode",e,t,a);return[n.image.transform(r,s,u.toLowerCase(),d.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},tQ=(e,t,a,n=an)=>{switch(e.op){case"Equal":return[n.equal(E("a",e,t,a),E("b",e,t,a))];case"NotEqual":return[n.notEqual(E("a",e,t,a),E("b",e,t,a))];case"Greater":return[n.greater(E("a",e,t,a),E("b",e,t,a))];case"GreaterEqual":return[n.greaterEqual(E("a",e,t,a),E("b",e,t,a))];case"Less":return[n.less(E("a",e,t,a),E("b",e,t,a))];case"LessEqual":return[n.lessEqual(E("a",e,t,a),E("b",e,t,a))];case"LogicalAnd":return[n.logicalAnd(E("a",e,t,a),E("b",e,t,a))];case"LogicalNot":return[n.logicalNot(E("a",e,t,a))];case"LogicalOr":return[n.logicalOr(E("a",e,t,a),E("b",e,t,a))];case"Select":case"SelectV2":return[n.where(E("condition",e,t,a),E("a",e,t,a),E("b",e,t,a))];case"BitwiseAnd":return[n.bitwiseAnd(E("a",e,t,a),E("b",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},aQ=(e,t,a,n=an)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(E("a",e,t,a),E("b",e,t,a),E("transposeA",e,t,a),E("transposeB",e,t,a))];case"Einsum":return[n.einsum(E("equation",e,t,a),...E("tensors",e,t,a))];case"Transpose":return[n.transpose(E("x",e,t,a),E("perm",e,t,a))];case"_FusedMatMul":let[r,s]=E("fusedOps",e,t,a),i=r==="biasadd",o=s==="prelu",u=E("numArgs",e,t,a),d=E("leakyreluAlpha",e,t,a);if(i){if(o&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,f]=E("args",e,t,a);return[n.fused.matMul({a:E("a",e,t,a),b:E("b",e,t,a),transposeA:E("transposeA",e,t,a),transposeB:E("transposeB",e,t,a),bias:c,activation:s,preluActivationWeights:f,leakyreluAlpha:d})];case"MatrixBandPart":return[n.linalg.bandPart(E("a",e,t,a),E("numLower",e,t,a),E("numUpper",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},nQ=(e,t,a,n=an)=>{switch(e.op){case"EuclideanNorm":return[n.euclideanNorm(E("x",e,t,a),E("axis",e,t,a),E("keepDims",e,t,a))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(E("x",e,t,a),E("mean",e,t,a),E("variance",e,t,a),E("offset",e,t,a),E("scale",e,t,a),E("epsilon",e,t,a))];case"FusedBatchNormV3":return[n.batchNorm(E("x",e,t,a),E("mean",e,t,a),E("variance",e,t,a),E("offset",e,t,a),E("scale",e,t,a),E("epsilon",e,t,a))];case"LRN":return[n.localResponseNormalization(E("x",e,t,a),E("radius",e,t,a),E("bias",e,t,a),E("alpha",e,t,a),E("beta",e,t,a))];case"Softmax":return[n.softmax(E("x",e,t,a))];case"LogSoftmax":return[n.logSoftmax(E("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},rQ=(e,t,a,n=an)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:r,outputDenseValues:s}=n.raggedGather(E("paramsNestedSplits",e,t,a),E("paramsDenseValues",e,t,a),E("indices",e,t,a),E("outputRaggedRank",e,t,a));return r.concat(s)}case"RaggedRange":{let{rtNestedSplits:r,rtDenseValues:s}=n.raggedRange(E("starts",e,t,a),E("limits",e,t,a),E("splits",e,t,a));return[r,s]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(E("shape",e,t,a),E("values",e,t,a),E("defaultValue",e,t,a),E("rowPartitionTensors",e,t,a),E("rowPartitionTypes",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},sQ=(e,t,a,n=an)=>{switch(e.op){case"Max":{let o=E("axis",e,t,a),u=E("keepDims",e,t,a);return[n.max(E("x",e,t,a),o,u)]}case"Mean":{let o=E("axis",e,t,a),u=E("keepDims",e,t,a);return[n.mean(E("x",e,t,a),o,u)]}case"Min":{let o=E("axis",e,t,a),u=E("keepDims",e,t,a);return[n.min(E("x",e,t,a),o,u)]}case"Sum":{let o=E("axis",e,t,a),u=E("keepDims",e,t,a);return[n.sum(E("x",e,t,a),o,u)]}case"All":{let o=E("axis",e,t,a),u=E("keepDims",e,t,a);return[n.all(E("x",e,t,a),o,u)]}case"Any":{let o=E("axis",e,t,a),u=E("keepDims",e,t,a);return[n.any(E("x",e,t,a),o,u)]}case"ArgMax":{let o=E("axis",e,t,a);return[n.argMax(E("x",e,t,a),o)]}case"ArgMin":{let o=E("axis",e,t,a);return[n.argMin(E("x",e,t,a),o)]}case"Prod":{let o=E("axis",e,t,a),u=E("keepDims",e,t,a);return[n.prod(E("x",e,t,a),o,u)]}case"Cumprod":{let o=E("axis",e,t,a),u=E("exclusive",e,t,a),d=E("reverse",e,t,a);return[n.cumprod(E("x",e,t,a),o,u,d)]}case"Cumsum":{let o=E("axis",e,t,a),u=E("exclusive",e,t,a),d=E("reverse",e,t,a);return[n.cumsum(E("x",e,t,a),o,u,d)]}case"Bincount":let r=E("x",e,t,a),s=E("weights",e,t,a),i=E("size",e,t,a);return[n.bincount(r,s,i)];case"DenseBincount":{let o=E("x",e,t,a),u=E("weights",e,t,a),d=E("size",e,t,a),c=E("binaryOutput",e,t,a);return[n.denseBincount(o,u,d,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},iQ=(e,t,a,n=an)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=E("n",e,t,a),s=E("axis",e,t,a),i=E("tensors",e,t,a);return i=i.slice(0,r),[n.concat(i,s)]}case"Gather":{let r=E("x",e,t,a),s=E("indices",e,t,a);return[n.gather(r,n.cast(s,"int32"),0)]}case"GatherV2":{let r=E("axis",e,t,a),s=E("batchDims",e,t,a),i=E("x",e,t,a),o=E("indices",e,t,a);return[n.gather(i,n.cast(o,"int32"),r,s)]}case"Reverse":{let r=E("dims",e,t,a),s=[];for(let o=0;o<r.length;o++)r[o]&&s.push(o);let i=E("x",e,t,a);return[n.reverse(i,s)]}case"ReverseV2":{let r=E("axis",e,t,a),s=E("x",e,t,a);return[n.reverse(s,r)]}case"Slice":{let r=E("begin",e,t,a),s=E("size",e,t,a);return[n.slice(E("x",e,t,a),r,s)]}case"StridedSlice":{let r=E("begin",e,t,a),s=E("end",e,t,a),i=E("strides",e,t,a),o=E("beginMask",e,t,a),u=E("endMask",e,t,a),d=E("ellipsisMask",e,t,a),c=E("newAxisMask",e,t,a),f=E("shrinkAxisMask",e,t,a),m=E("x",e,t,a);return[n.stridedSlice(m,r,s,i,o,u,d,c,f)]}case"Pack":return ae(()=>{let r=E("axis",e,t,a),s=E("tensors",e,t,a),i=s[0].shape,o=n.squeeze(s[0]).shape,u=s.map(d=>{let c=C.arraysEqual(d.shape,i);if(!c&&!C.arraysEqual(n.squeeze(d).shape,o))throw new Error("the input tensors shape does not match");return c?d:n.reshape(d,i)});return[n.stack(u,r)]});case"Unpack":{let r=E("axis",e,t,a),s=E("tensor",e,t,a);return n.unstack(s,r)}case"Tile":{let r=E("reps",e,t,a);return[n.tile(E("x",e,t,a),r)]}case"Split":case"SplitV":{let r=E("axis",e,t,a),s=E("numOrSizeSplits",e,t,a),i=E("x",e,t,a);return n.split(i,s,r)}case"ScatterNd":{let r=E("indices",e,t,a),s=E("values",e,t,a),i=E("shape",e,t,a);return[n.scatterND(r,s,i)]}case"GatherNd":{let r=E("x",e,t,a),s=E("indices",e,t,a);return[n.gatherND(r,s)]}case"SparseToDense":{let r=E("sparseIndices",e,t,a),s=E("outputShape",e,t,a),i=E("sparseValues",e,t,a),o=E("defaultValue",e,t,a);return[n.sparseToDense(r,i,s,i.dtype===o.dtype?o:n.cast(o,i.dtype))]}case"TensorScatterUpdate":{let r=E("indices",e,t,a),s=E("values",e,t,a),i=E("tensor",e,t,a);return[n.tensorScatterUpdate(i,r,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},oQ=(e,t,a,n=an)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:s,emptyRowIndicator:i,reverseIndexMap:o}=n.sparse.sparseFillEmptyRows(E("indices",e,t,a),E("values",e,t,a),E("denseShape",e,t,a),E("defaultValue",e,t,a));return[r,s,i,o]}case"SparseReshape":{let{outputIndices:r,outputShape:s}=n.sparse.sparseReshape(E("inputIndices",e,t,a),E("inputShape",e,t,a),E("newShape",e,t,a));return[r,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(E("data",e,t,a),E("indices",e,t,a),E("segmentIds",e,t,a))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(E("data",e,t,a),E("indices",e,t,a),E("segmentIds",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},lQ=(e,t,a,n=an)=>{switch(e.op){case"FFT":return[n.fft(E("x",e,t,a))];case"IFFT":return[n.ifft(E("x",e,t,a))];case"RFFT":return[n.rfft(E("x",e,t,a))];case"IRFFT":return[n.irfft(E("x",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},uQ=(e,t,a,n=an)=>{switch(e.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(E("input",e,t,a),E("pattern",e,t,a),E("rewrite",e,t,a),E("replaceGlobal",e,t,a))];case"StringNGrams":{let{nGrams:r,nGramsSplits:s}=n.string.stringNGrams(E("data",e,t,a),E("dataSplits",e,t,a),E("separator",e,t,a),E("nGramWidths",e,t,a),E("leftPad",e,t,a),E("rightPad",e,t,a),E("padWidth",e,t,a),E("preserveShortSequences",e,t,a));return[r,s]}case"StringSplit":{let{indices:r,values:s,shape:i}=n.string.stringSplit(E("input",e,t,a),E("delimiter",e,t,a),E("skipEmpty",e,t,a));return[r,s,i]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(E("input",e,t,a),E("numBuckets",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},cQ=(e,t,a,n=an)=>{switch(e.op){case"Cast":return[n.cast(E("x",e,t,a),E("dtype",e,t,a))];case"ExpandDims":{let r=E("axis",e,t,a);return[n.expandDims(E("x",e,t,a),r)]}case"Squeeze":{let r=E("axis",e,t,a);return[n.squeeze(E("x",e,t,a),r)]}case"Reshape":return[n.reshape(E("x",e,t,a),E("shape",e,t,a))];case"EnsureShape":return[n.ensureShape(E("x",e,t,a),E("shape",e,t,a))];case"MirrorPad":return[n.mirrorPad(E("x",e,t,a),E("padding",e,t,a),E("mode",e,t,a))];case"PadV2":case"Pad":return[n.pad(E("x",e,t,a),E("padding",e,t,a),E("constantValue",e,t,a))];case"SpaceToBatchND":{let r=E("blockShape",e,t,a),s=E("paddings",e,t,a);return[n.spaceToBatchND(E("x",e,t,a),r,s)]}case"BatchToSpaceND":{let r=E("blockShape",e,t,a),s=E("crops",e,t,a);return[n.batchToSpaceND(E("x",e,t,a),r,s)]}case"DepthToSpace":{let r=E("blockSize",e,t,a),s=E("dataFormat",e,t,a).toUpperCase();return[n.depthToSpace(E("x",e,t,a),r,s)]}case"BroadcastTo":return[n.broadcastTo(E("x",e,t,a),E("shape",e,t,a))];case"BroadcastArgs":return[n.broadcastArgs(E("s0",e,t,a),E("s1",e,t,a))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function vE(e,t,a,n,r=ae){let s=((i,o,u)=>{switch(i.category){case"arithmetic":return r(()=>BZ(i,o,u));case"basic_math":return r(()=>UZ(i,o,u));case"control":return qZ(i,o,u);case"convolution":return r(()=>jZ(i,o,u));case"creation":return r(()=>KZ(i,o,u));case"dynamic":return XZ(i,o,u);case"evaluation":return r(()=>YZ(i,o,u));case"image":return r(()=>eQ(i,o,u));case"graph":return r(()=>ZZ(i,o,u));case"logical":return r(()=>tQ(i,o,u));case"matrices":return r(()=>aQ(i,o,u));case"normalization":return r(()=>nQ(i,o,u));case"ragged":return r(()=>rQ(i,o,u));case"reduction":return r(()=>sQ(i,o,u));case"slice_join":return r(()=>iQ(i,o,u));case"sparse":return r(()=>oQ(i,o,u));case"spectral":return r(()=>lQ(i,o,u));case"string":return r(()=>uQ(i,o,u));case"transformation":return r(()=>cQ(i,o,u));case"hash_table":return JZ(i,o,u,n);case"custom":let d=vM(i.op);if(d&&d.customExecutor)return d.customExecutor(new LZ(i,o,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,a);return C.isPromise(s)?s.then(i=>[].concat(i)):[].concat(s)}var xE=class{constructor(e={},t={},a={},n={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=a,this.functionMap=n,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function wE(e,t,a,n){let r=new Set,s=[],i=null,o=null,u=new Set,d=new Set(Object.keys(e).map(m=>nr(m)[0]));n=n||[];let c=new Set(n.map(m=>nr(m.name)[0])),f=[...t];for(;f.length>0;){let m=f.pop();if((Al(m)||bQ(m)||vQ(m))&&i==null&&(i=m,o=i.children.map(g=>g.name).filter(g=>r.has(g))),r.add(m.name),a[m.name]==null&&!d.has(m.name)&&!c.has(m.name)){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(g=>{u.has(g.name)||(u.add(g.name),f.push(g))})}}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:i,syncInputs:o}}function dQ(e,t){let{usedNodes:a,inputs:n}=t,r=Object.keys(n).map(x=>nr(x)[0]).map(x=>e.nodes[x]),s=e.initNodes||[],i=x=>a.has(typeof x=="string"?x:x.name);function o(x){return[...new Map(x.map(k=>[k.name,k])).values()]}let u=o([...r,...e.weights,...s]).filter(i),d=o([...u,...Object.values(e.nodes)]).filter(i),c=new Map(d.map(x=>[x.name,x])),f={};for(let x of d){f[x.name]=f[x.name]||0;for(let k of x.children)i(k)||(f[k.name]=Number.POSITIVE_INFINITY),f[k.name]=(f[k.name]||0)+1}let m=Object.entries(f).filter(([,x])=>x===0).map(([x])=>x),g=[...m];for(;m.length>0;){let x=m.pop(),k=c.get(x);for(let S of k.children.filter(i))--f[S.name]===0&&(g.push(S.name),m.push(S.name))}let b=g.map(x=>c.get(x)),v=hQ(b,u);return pQ(v,u),v}function hQ(e,t){let a=new Map(e.map(s=>[s.name,s])),n=t.map(s=>s.name),r=new Set(n);for(;n.length>0;){let s=n.pop(),i=a.get(s);for(let o of i.children)!a.has(o.name)||r.has(o.name)||(r.add(o.name),n.push(o.name))}return e.filter(s=>r.has(s.name))}var _y=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function pQ(e,t){let a=new Map(e.map((o,u)=>[o.name,u])),n=new Set(t.map(o=>o.name)),r=o=>n.has(typeof o=="string"?o:o.name),s=new Set(e.map(o=>o.name)),i=o=>s.has(typeof o=="string"?o:o.name);for(let o of e){for(let u of o.children.filter(i)){if(!a.has(u.name))throw new _y(`Child ${u.name} of node ${o.name} is unreachable.`);if(a.get(o.name)>a.get(u.name))throw new _y(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!r(o))for(let u of o.inputs){if(!a.has(u.name))throw new _y(`Input ${u.name} of node ${o.name} is unreachable.`);if(a.get(u.name)>a.get(o.name))throw new _y(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}function fQ(e){let t=new Map(e.map((o,u)=>[o.name,u])),a=Number.MAX_SAFE_INTEGER,n=e.map((o,u)=>Al(o)?a:u),r=o=>{let u=n[t.get(o.name)];return u??-1},s=e.map((o,u)=>o.children.map(r).reduce((d,c)=>Math.max(d,c),n[u])),i=new Map;for(let o=0;o<e.length;++o){let u=s[o];if(u===a)continue;let d=e[o],c=e[u];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(d)}return i}var mQ=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),gQ=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),yQ=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Al(e){return mQ.has(e.op)}function bQ(e){return gQ.has(e.op)}function vQ(e){return yQ.has(e.op)}var kE=class PM{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let a=Object.keys(t).map(n=>t[n].map(r=>r.id));this._weightIds=[].concat(...a),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let a=t.signatureKey||t.name;return t.defaultOutput?`${a}:${t.defaultOutput}`:a})}get functions(){return Object.keys(this._functions).reduce((t,a)=>(t[a]=this._functions[a].signature,t),{})}constructor(t,a){this.graph=t,this.parent=a,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(n=>{this._functionExecutorMap[n]=new PM(t.functions[n],this)})}getCompilationKey(t,a){let n=t.map(s=>s.name).sort(),r=a.map(s=>s.name).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,a){let n=wE(t,a,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:i}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){let d=a.map(f=>f.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${d}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}let o=dQ(this.graph,n),u=fQ(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(t==null)return null;let a=t.clone();return Ba(a),a}cloneTensorList(t){return t?t.map(a=>this.cloneAndKeepTensor(a)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([a,n])=>[a,this.cloneTensorList(n)]))}execute(t,a){this.disposeIntermediateTensors(),t=this.mapInputs(t);let n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),a=this.mapOutputs(a),this.checkOutputs(a);let r=n.map(m=>this.graph.nodes[nr(m)[0]]),s=a.map(m=>nr(m)[0]),i=new Set(s),o=s.map(m=>this.graph.nodes[m]);o.length===0&&(o=this._outputs);let u=this.getCompilationKey(r,o),d=this.compiledMap.get(u);d==null&&(d=this.compile(t,o),this.compiledMap.set(u,d));try{this.keepIntermediateTensors=ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}let c={},f={};return ae(()=>{let m=new xE(this.weightMap,c,f,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(k=>{let[S,N]=nr(k,m),T=[];T[N]=t[k],g[S]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[S]=this.cloneTensorList(T))});let b=this.getFrozenTensorIds(g),{orderedNodes:v,nodeLiveUntilMap:x}=d;for(let k of v){if(g[k.name])continue;let S=vE(k,g,m,this._resourceManager);if(C.isPromise(S))throw new Error(`The execution of the op '${k.op}' returned a promise. Please use model.executeAsync() instead.`);g[k.name]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[k.name]=this.cloneTensorList(S)),this.checkTensorForDisposalWithNodeLiveUntilInfo(k,g,m,b,i,x.get(k.name))}return this.parent==null&&m.dispose(b),a.map(k=>un(k,g,m))})}getFrozenTensorIds(t){let a=[].concat.apply([],Object.keys(t).map(n=>t[n]).map(n=>n.map(r=>r.id)));return new Set(a)}checkTensorForDisposal(t,a,n,r,s,i,o){if(!(Al(a)||i.has(t))){for(let u of n[t])u!=null&&(o[u.id]=(o[u.id]||0)+a.children.length);for(let u of a.inputs){if(Al(u))continue;let d=fE(u.name,n,r);if(d!=null)for(let c of d){if(!c||c.kept||s.has(c.id))continue;let f=o[c.id];f===1?(c.dispose(),delete o[c.id]):f!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,a,n,r,s,i){function o(u){return Al(u)||s.has(u.name)}if(!(Al(t)||i==null))for(let u of i){if(o(u))continue;let d=fE(u.name,a,n);for(let c of d)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(t,a){return this._executeAsync(t,a)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let a of t)a&&!a.isDisposed&&a.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,a,n=!1,r={},s={}){this.disposeIntermediateTensors(),n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),a=this.mapOutputs(a),this.checkOutputs(a));try{this.keepIntermediateTensors=ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}let i=new xE(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,a,n),u=a.map(m=>un(m,o,i)),d=u.map(m=>m.id),c=Object.keys(t).map(m=>t[m].id),f=new Set([...d,...c,...this.weightIds]);return Object.values(o).forEach(m=>{m.forEach(g=>{g&&!g.isDisposed&&!f.has(g.id)&&g.dispose()})}),this.parent==null&&i.dispose(f),u}async executeFunctionAsync(t,a,n){let r=t.reduce((s,i,o)=>(s[this.inputs[o].name]=i,s),{});return this._executeAsync(r,this.outputNodes,!0,a,n)}async executeWithControlFlow(t,a,n,r){let s=Object.keys(t),i=s.map(T=>this.graph.nodes[nr(T)[0]]),o=n.map(T=>nr(T)[0]),u=new Set(o),d=o.map(T=>this.graph.nodes[T]);d.length===0&&(d=this._outputs);let{usedNodes:c,missingInputs:f,dynamicNode:m,syncInputs:g}=wE(t,d,this.weightMap,this._initNodes),b=[...i,...this.graph.weights,...this._initNodes||[]].map(T=>({node:T,contexts:a.currentContext})),v=Object.assign({},this.weightMap);Object.keys(t).forEach(T=>{let[_,R]=nr(T),M=[];M[R]=t[T],v[_]=M});let x={},k=this.getFrozenTensorIds(v),S={};for(;b.length>0;){let T=this.processStack(i,b,a,v,S,k,u,x,c);await Promise.all(T)}m==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let N=d.filter(T=>!Al(T)&&!un(T.name,v,a)).map(T=>T.name);if(N.length>0){let T="";throw m!=null&&(T=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${s}]. Consider providing the following inputs: [${f}]. ${T}`)}return v}processStack(t,a,n,r,s,i,o,u,d){let c=[];for(;a.length>0;){let f=a.pop();n.currentContext=f.contexts;let m="";if(f.node.op==="Enter"&&E("isConstant",f.node,r,n)&&([m]=fi(f.node.name,n)),r[f.node.name]==null){let g=vE(f.node,r,n,this._resourceManager);m||([m]=fi(f.node.name,n));let b=n.currentContext;C.isPromise(g)?c.push(g.then(v=>(r[m]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(v)),n.currentContext=b,this.checkTensorForDisposal(m,f.node,r,n,i,o,u),this.processChildNodes(f.node,a,n,r,s,d),v))):(r[m]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(g)),this.checkTensorForDisposal(m,f.node,r,n,i,o,u),this.processChildNodes(f.node,a,n,r,s,d))}else this.processChildNodes(f.node,a,n,r,s,d)}return c}processChildNodes(t,a,n,r,s,i){t.children.forEach(o=>{let[u]=fi(o.name,n);s[u]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(d=>!!un(d,r,n))&&(s[u]=!0,a.push({contexts:n.currentContext,node:o})):o.inputNames.every(d=>!!un(d,r,n))&&(s[u]=!0,a.push({contexts:n.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(a=>a.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(a=>{let n=t[a],[r]=nr(a),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,o=i.length===n.shape.length&&n.shape.every((u,d)=>i[d]===-1||i[d]===u);C.assert(o,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&C.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){var a,n;let r={};for(let s in t){let i=(n=(a=this._signature)===null||a===void 0?void 0:a.inputs)===null||n===void 0?void 0:n[s];i!=null?r[i.name]=t[s]:r[s]=t[s]}return r}checkInputs(t){let a=Object.keys(t).filter(n=>{let[r]=nr(n);return this.graph.nodes[r]==null});if(a.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${a}] that are not part of graph`)}mapOutputs(t){return t.map(a=>{var n,r;let s=(r=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||r===void 0?void 0:r[a];return s!=null?s.name:a},{})}checkOutputs(t){t.forEach(a=>{let[n]=nr(a);if(!this.graph.nodes[n])throw new Error(`The output '${a}' is not found in the graph`)})}},xQ=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},wQ="?tfjs-format=file",kQ="model.json",U2=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},a=dn){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=a,t==null&&(this.loadOptions={}),this.resourceManager=new xQ}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return C.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await GA(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let a=this.artifacts.modelTopology,n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let r=this.artifacts.userDefinedMetadata;r.signature!=null&&(n=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=n,this.version=`${a.versions.producer}.${a.versions.minConsumer}`,this.executor=new kE(mE.Instance.transformGraph(a,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let r=mE.Instance.transformGraph(e.modelInitializer);this.initializer=new kE(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let a=this.io.getSaveHandlers(e);if(a.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(a.length>1)throw new Error(`Found more than one (${a.length}) save handlers for URL '${e}'`);e=a[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof ht?[e]:e,a={};return t.forEach((n,r)=>a[this.structuredOutputKeys[r]]=n),a}return e}predict(e,t){let a=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(a)}async predictAsync(e,t){let a=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(a)}normalizeInputs(e){var t;if(!(e instanceof ht)&&!Array.isArray(e)){let r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(let s in r){let i=r[s];i.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let a=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+a!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-a} non-resource placeholders, while there are ${e.length} input tensors provided.`);let n=0;return this.inputNodes.reduce((r,s)=>{var i,o,u;let d=(u=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[s])===null||u===void 0?void 0:u.resourceId;return d!=null?r[s]=this.resourceIdToCapturedInput[d]:r[s]=e[n++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,a=Object.keys(t);for(let n=0;n<a.length;n++){let r=a[n],s=t[r];this.resourceIdToCapturedInput[s.resourceId]=e[n]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let a=this.executor.execute(e,t);return a.length>1?a:a[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let a=await this.executor.executeAsync(e,t);return a.length>1?a:a[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,a)=>(t[a]=[e[a]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&nt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function SQ(e,t={},a=dn){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=NQ(e));let n=new U2(e,t,a);return await n.load(),n}function IQ(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let s=dn.getWeightSpecs(n.weightsManifest),i=dn.getModelArtifactsForJSONSync(n,s,r);t=dn.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=dn.fromMemorySync(e);else throw new Error("Unknown model format");let a=new U2(t);return a.load(),a}function NQ(e){return e.endsWith("/")||(e=e+"/"),`${e}${kQ}${wQ}`}var TQ="4.22.0",WM={};rt(WM,{CSVDataset:()=>JM,Dataset:()=>ip,FileDataSource:()=>iF,TextLineDataset:()=>QM,URLDataSource:()=>oF,array:()=>XQ,csv:()=>lJ,func:()=>uJ,generator:()=>cJ,microphone:()=>hJ,version_data:()=>pJ,webcam:()=>dJ,zip:()=>YQ});var _Q=Fo(kb()),CQ=Fo(kb());function EQ(e,t){return cb(e,t)}function cb(e,t,a=new Map,n=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(n.has(e))throw new Error("Circular references are not supported.");if(a.has(e))return a.get(e);let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse)if(Wd(e)){let s=Array.isArray(e)?[]:{};n.add(e);for(let i in e){let o=e[i],u=cb(o,t,a,n);s[i]=u}return n.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return a.set(e,r.value),r.value}function AQ(e,t=GM){return VM(e,t)}function VM(e,t,a=new Set){let n=e[0];if(a.has(n))throw new Error("Circular references are not supported.");let r=t(e);if(r.recurse&&r.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse)if(Wd(n)){let s=Array.isArray(n)?[]:{};a.add(n);for(let i in n){let o=e.map(d=>d[i]),u=VM(o,t,a);s[i]=u}return a.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return r.value}function GM(e){return e===null?null:Wd(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function HM(e,t){let a=new Map;cb(e,t,a);for(let n of Array.from(a.keys())){let r=a.get(n);if(C.isPromise(r)){let s=await r;a.set(n,s)}}return cb(e,t,a)}function Wd(e){let t=!1;if(ie().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:a}=cA();t=e instanceof a}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof ht)&&!(e instanceof Promise)&&!t)}function $Q(e){return e==null||RQ(e)||Array.isArray(e)||typeof e=="object"&&e instanceof ht||C.isTypedArray(e)}function RQ(e){return e===null||typeof e!="object"&&typeof e!="function"}function DQ(e){return EQ(e,MQ)}function MQ(e){return e instanceof ht?{value:e.clone(),recurse:!1}:Wd(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var qM=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),a=this.get(t);return this.set(t,this.pop()),a}},jM=class KM extends qM{constructor(){super(KM.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,a=new Array(t),n=this.length();for(let r=0;r<n;r++)a[r]=this.get(this.wrap(this.begin+r));this.data=a,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};jM.INITIAL_CAPACITY=32;function XM(e){return new zQ(e)}function P2(e){return new LQ(e)}function FQ(e,t){return new YM(e,t)}function OQ(e,t=mo.FAIL){return new jQ(e,t)}var tn=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],a=await e.next();for(;!a.done;)t.push(a.value),a=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),a=e(t.value);for(;!t.done&&a;)t=await this.next(),a=e(t.value)}handleErrors(e){return new HQ(this,e)}filter(e){return new VQ(this,e)}map(e){return new GQ(this,e)}mapAsync(e){return new SE(this,e)}serialMapAsync(e){return new SE(this,e).serial()}flatmap(e){return new qQ(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new WQ(this,e,t)}columnMajorBatch(e,t=!0,a=GM){return this.rowMajorBatch(e,t).map(n=>AQ(n,a))}concatenate(e,t){return new YM(XM([this,e]),t)}take(e){return e<0||e==null?this:new PQ(this,e)}skip(e){return e<0||e==null?this:new UQ(this,e)}prefetch(e){return new ZM(this,e)}shuffle(e,t){return new KQ(this,e,t)}serial(){return new BQ(this)}},zQ=class extends tn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:DQ(e),done:!1}}},LQ=class extends tn{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},BQ=class extends tn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},UQ=class extends tn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;nt(e.value)}return this.upstream.next()}},PQ=class extends tn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},WQ=class extends tn{constructor(e,t,a=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=a,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},VQ=class extends tn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;nt(e.value)}}},GQ=class extends tn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=ls.getTensorsInContainer(e.value),a=this.transform(e.value),n=ls.getTensorsInContainer(a);for(let r of t)ls.isTensorInList(r,n)||r.dispose();return{value:a,done:!1}}},HQ=class extends tn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},SE=class extends tn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=ls.getTensorsInContainer(e.value),a=await this.transform(e.value),n=ls.getTensorsInContainer(a);for(let r of t)ls.isTensorInList(r,n)||r.dispose();return{value:a,done:!1}}},W2=class extends tn{constructor(){super(),this.outputQueue=new jM,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},qQ=class extends W2{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=ls.getTensorsInContainer(e.value),a=this.transform(e.value),n=ls.getTensorsInContainer(a);this.outputQueue.pushAll(a);for(let r of t)ls.isTensorInList(r,n)||r.dispose();return!0}},YM=class extends tn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let a=await this.moreIterators.next();if(a.done)return{value:null,done:!0};this.iterator=a.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},mo;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(mo||(mo={}));var jQ=class extends tn{constructor(e,t=mo.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,a=0;function n(s){return s instanceof tn?{value:s.next().then(i=>(t++,i.done&&a++,i.value)),recurse:!1}:{value:null,recurse:!0}}let r=await HM(this.iterators,n);if(t===a)return{value:null,done:!0};if(a>0)switch(this.mismatchMode){case mo.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case mo.SHORTEST:return{value:null,done:!0};case mo.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},ZM=class extends tn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new qM(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},KQ=class extends ZM{constructor(e,t,a){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=CQ.alea(a||C.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},ip=class{constructor(){this.size=null}batch(e,t=!0){let a=this;C.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let n;return this.size===1/0||this.size==null?n=this.size:t?n=Math.ceil(this.size/e):n=Math.floor(this.size/e),ar(async()=>(await a.iterator()).columnMajorBatch(e,t,ZQ),n)}concatenate(e){let t=this,a;return this.size===1/0||e.size===1/0?a=1/0:this.size!=null&&e.size!=null?a=this.size+e.size:a=null,ar(async()=>(await t.iterator()).concatenate(await e.iterator()),a)}filter(e){let t=this,a;return this.size===1/0?a=1/0:a=null,ar(async()=>(await t.iterator()).filter(n=>ae(()=>e(n))),a)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return ar(async()=>(await t.iterator()).map(a=>ae(()=>e(a))),this.size)}mapAsync(e){let t=this;return ar(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return ar(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,a;return this.size!=null&&e>0?a=this.size*e:e===0?a=0:this.size!=null&&(e===void 0||e<0)?a=1/0:a=null,ar(async()=>{let n=P2(async()=>({value:await t.iterator(),done:!1}));return FQ(n.take(e))},a)}skip(e){let t=this,a;return this.size!=null&&e>=0&&this.size>=e?a=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?a=0:a=null,ar(async()=>(await t.iterator()).skip(e),a)}shuffle(e,t,a=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let n=this,r=_Q.alea(t||C.now().toString());return ar(async()=>{let s=r.int32();return a&&(s+=r.int32()),(await n.iterator()).shuffle(e,s.toString())},this.size)}take(e){let t=this,a;return this.size!=null&&this.size>e?a=e:this.size!=null&&this.size<=e?a=this.size:a=null,ar(async()=>(await t.iterator()).take(e),a)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};ip.MAX_BUFFER_SIZE=1e4;function ar(e,t=null){return new class extends ip{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function XQ(e){return ar(async()=>XM(e),e.length)}function YQ(e){if(!Wd(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let a=0;a<e.length;a++)t=t==null?e[a].size:Math.min(t,e[a].size);else if(e instanceof Object)for(let a in e)t=t==null?e[a].size:Math.min(t,e[a].size);return ar(async()=>{let a=await HM(e,n=>{if(n instanceof ip)return{value:n.iterator(),recurse:!1};if(Wd(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return OQ(a,mo.SHORTEST)},t)}function ZQ(e){if(e===null)return null;let t=e[0];return $Q(t)?{value:QQ(e),recurse:!1}:{value:null,recurse:!0}}function QQ(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof ht?$a(e):_n(e)}var QM=class extends ip{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},Cy='"',Tf=Symbol("out"),IE=Symbol("field"),Ey=Symbol("quote"),gw=Symbol("quoteafterquote"),NE=Symbol("quoteinquote"),JM=class extends ip{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&C.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((n,r)=>(n[r]=n[r]+1||1,n),{}),a=Object.keys(t).filter(n=>t[n]>1);if(C.assert(a.length===0,()=>"Duplicate column names found: "+a.toString()),this.columnConfigs){for(let n of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(n)===-1)throw new Error('The key "'+n+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new QM(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(C.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),a={},n={};for(let r=0;r<this.fullColumnNames.length;r++){let s=this.fullColumnNames[r],i=this.columnConfigs?this.columnConfigs[s]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[r],u=null;if(o==="")if(i&&i.default!==void 0)u=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);u=void 0}else{let d=Number(o);if(isNaN(d))i&&i.dtype==="bool"?u=this.getBoolean(o):u=o;else if(!i||!i.dtype)u=d;else switch(i.dtype){case"float32":u=d;break;case"int32":u=Math.floor(d);break;case"bool":u=this.getBoolean(o);break;default:u=d}}i&&i.isLabel?n[s]=u:a[s]=u}}return Object.keys(n).length===0?a:{xs:a,ys:n}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let a=[],n=0,r=e.length,s=Tf;for(let i=0;i<r;i++)switch(s){case Tf:switch(e.charAt(i)){case Cy:n=i+1,s=Ey;break;case this.delimiter:if(n=i+1,this.delimiter===" "&&this.delimWhitespace)break;a.push(""),s=Tf;break;default:s=IE,n=i;break}break;case IE:switch(e.charAt(i)){case this.delimiter:a.push(e.substring(n,i)),s=Tf,n=i+1;break}break;case Ey:switch(e.charAt(i)){case Cy:s=gw;break}break;case gw:switch(e.charAt(i)){case this.delimiter:a.push(e.substring(n,i-1)),s=Tf,n=i+1;break;case Cy:s=Ey;break;default:s=NE;break}break;case NE:switch(e.charAt(i)){case Cy:s=Ey;break}break}if(s===gw?a.push(e.substring(n,r-1)):a.push(e.substring(n)),t&&a.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${a}`);return a}},JQ=class eF extends tn{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let a=Math.log2(this.fftSize);if(this.fftSize<0||a<4||a>14||!Number.isInteger(a))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!ie().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let a=new eF(t);return await a.start(),a}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let a=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,a.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,a,n=await this.getAudioData();if(this.includeSpectrogram){let r=this.flattenQueue(n.freqDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let r=this.flattenQueue(n.timeDataQueue);a=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:a},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],a=[],n=0;return new Promise(r=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:t,timeDataQueue:a}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),a.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),r({freqDataQueue:t,timeDataQueue:a}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let a=t[0].length,n=new Float32Array(t.length*a);return t.forEach((r,s)=>n.set(r,s*a)),n}getTensorFromAudioDataArray(t,a){let n=new Float32Array(C.sizeFromShape(a));return n.set(t,n.length-t.length),_n(n,a)}},eJ=class tF extends tn{constructor(t,a){if(super(),this.webcamVideoElement=t,this.webcamConfig=a,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Mt([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,i=(1-r)/2,o=s+n,u=r+i;this.cropBox=Ls([i,s,u,o],[1,4])}else this.cropBox=Ls([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,a={}){if(!ie().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!a.resizeWidth||!a.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=a.resizeWidth,t.height=a.resizeHeight}let n=new tF(t,a);return await n.start(),n}async start(){this.webcamConfig.facingMode&&C.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Ym.fromPixels(this.webcamVideoElement)}catch(a){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(a)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(a){throw new Error(`Error thrown cropping the video: ${a.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return ae(()=>{let a=Za(Te(t,"float32"),0),n;n=xr.cropAndResize(a,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=n.shape;return te(n,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},aF=class{},nF=class extends tn{split(e){return new tJ(this,e)}},tJ=class extends nF{constructor(e,t){super(),this.upstream=e,this.impl=new aJ(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},aJ=class extends W2{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let a of t.slice(0,-1))this.outputQueue.push(a);return this.carryover=t[t.length-1],!0}},nJ=class extends tn{decodeUTF8(){return new rJ(this)}},rJ=class extends nF{constructor(e){super(),this.upstream=e,this.impl=new sJ(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},sJ=class extends W2{constructor(e){if(super(),this.upstream=e,ie().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=cA();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let a;return ie().get("IS_BROWSER")?a=this.decoder.decode(t,{stream:!0}):a=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(a),!0}},rF=class extends nJ{constructor(e,t={}){super(),this.file=e,this.options=t,C.assert(e instanceof Uint8Array||(ie().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let a=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,a)));else{let n=new FileReader;n.onload=s=>{let i=n.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},n.onabort=s=>t(new Error("Aborted")),n.onerror=s=>t(new Error(s.type));let r=this.file.slice(this.offset,a);n.readAsArrayBuffer(r)}this.offset=a}),done:!1}}};async function iJ(e,t={},a){let n,r;typeof e=="string"?n=e:(n=e.url,r=oJ(e));let s=await(0,C.fetch)(n,r);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new rF(i,t)}else throw new Error(s.statusText)}var oJ=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function sF(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var iF=class extends aF{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(sF(this.input)&&ie().get("IS_NODE")){let e=D1();this.input=e.readFileSync(this.input.slice(7))}return new rF(this.input,this.options)}},oF=class extends aF{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return sF(this.url)?new iF(this.url,this.fileOptions).iterator():iJ(this.url,this.fileOptions)}};function lJ(e,t={}){return new JM(new oF(e),t)}function uJ(e){let t=P2(e);return ar(async()=>t)}function cJ(e){return ar(async()=>{let t=await e();return P2(()=>t.next())})}async function dJ(e,t){return eJ.create(e,t)}async function hJ(e){return JQ.create(e)}var pJ="4.22.0";function Be(e,t){Array.isArray(e)||(e=[e]),e.forEach(a=>{a!=null&&C.assert(a.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var fJ=qs.whereImpl,V2=class lF extends lm{nextDataId(){return lF.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Sb(this,Pr())}write(t,a,n){this.firstUse&&(this.firstUse=!1,ie().get("IS_NODE")&&D.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let r={id:this.nextDataId()};return this.data.set(r,{values:t,dtype:n,refCount:1}),r}makeTensorInfo(t,a,n){let r;if(a==="string"&&n!=null&&n.length>0&&C.isString(n[0])){let s=n.map(i=>C.encodeString(i));r=this.write(s,t,a)}else r=this.write(n,t,a);return{dataId:r,shape:t,dtype:a}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let a=this.data.get(t);a.refCount++}decRef(t){if(this.data.has(t)){let a=this.data.get(t);a.refCount--}}move(t,a,n,r,s){this.data.set(t,{values:a,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:a,complexTensorInfos:n}=this.data.get(t);if(a==="complex64"){let r=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return D.mergeRealAndImagArrays(r,s)}return C.convertBackendValuesAndArrayBuffer(this.data.get(t).values,a)}bufferSync(t){let a=this.readSync(t.dataId);if(t.dtype==="string")try{let n=a.map(r=>C.decodeString(r));return ct(t.shape,t.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ct(t.shape,t.dtype,a)}makeOutput(t,a,n){return Pr().makeTensorFromTensorInfo(this.makeTensorInfo(a,n,t),this)}disposeData(t,a=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!a&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(t);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let a=C.now();return t(),{kernelMs:C.now()-a}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Be([t],"where");let a=this.readSync(t.dataId);return fJ(t.shape,a)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};V2.nextDataId=0;var G2={};rt(G2,{addImpl:()=>dF,bincountImpl:()=>q2,bincountReduceImpl:()=>hF,bitwiseAndImpl:()=>pF,castImpl:()=>cF,ceilImpl:()=>fF,concatImpl:()=>j2,equalImpl:()=>mF,expImpl:()=>yF,expm1Impl:()=>vF,floorDivImpl:()=>wF,floorImpl:()=>xF,gatherNdImpl:()=>kF,gatherV2Impl:()=>SF,greaterEqualImpl:()=>NF,greaterImpl:()=>IF,lessEqualImpl:()=>_F,lessImpl:()=>TF,linSpaceImpl:()=>CF,logImpl:()=>EF,maxImpl:()=>AF,maximumImpl:()=>$F,minimumImpl:()=>RF,multiplyImpl:()=>K2,negImpl:()=>DF,notEqualImpl:()=>MF,prodImpl:()=>FF,raggedGatherImpl:()=>OF,raggedRangeImpl:()=>zF,raggedTensorToTensorImpl:()=>LF,rangeImpl:()=>Y2,rsqrtImpl:()=>BF,scatterImpl:()=>Dl,sigmoidImpl:()=>pee,simpleAbsImpl:()=>uF,sliceImpl:()=>hb,sparseFillEmptyRowsImpl:()=>PF,sparseReshapeImpl:()=>WF,sparseSegmentReductionImpl:()=>Z2,sqrtImpl:()=>gee,squaredDifferenceImpl:()=>VF,staticRegexReplaceImpl:()=>GF,stridedSliceImpl:()=>HF,stringNGramsImpl:()=>Q2,stringSplitImpl:()=>J2,stringToHashBucketFastImpl:()=>eI,subImpl:()=>qF,tileImpl:()=>jF,topKImpl:()=>XF,transposeImpl:()=>X2,uniqueImpl:()=>aI});function uF(e){let t=new Float32Array(e.length);for(let a=0;a<e.length;++a)t[a]=Math.abs(e[a]);return t}var mJ=e=>{let{x:t}=e.inputs,a=e.backend;Be(t,"abs");let n=new Float32Array(C.sizeFromShape(t.shape)),r=a.data.get(t.dataId).values;return n=uF(r),a.makeOutput(n,t.shape,t.dtype)},gJ={kernelName:Kd,backendName:"cpu",kernelFunc:mJ};function Ia(e){return(t,a,n,r,s)=>{let i=D.assertAndGetBroadcastShape(t,a),o=i.length,u=C.computeStrides(i),d=C.sizeFromShape(i),c=C.getTypedArrayFromDType(s,d),f=t.length,m=a.length,g=C.computeStrides(t),b=C.computeStrides(a),v=D.getBroadcastDims(t,i),x=D.getBroadcastDims(a,i);if(v.length+x.length===0)for(let k=0;k<c.length;++k)c[k]=e(n[k%n.length],r[k%r.length]);else for(let k=0;k<c.length;++k){let S=C.indexToLoc(k,o,u),N=S.slice(-f);v.forEach(M=>N[M]=0);let T=C.locToIndex(N,f,g),_=S.slice(-m);x.forEach(M=>_[M]=0);let R=C.locToIndex(_,m,b);c[k]=e(n[T],r[R])}return[c,i]}}function rr(e){let{inputs:t,backend:a}=e,{real:n,imag:r}=t,s=a.data.get(n.dataId).values,i=a.data.get(r.dataId).values,o=a.makeTensorInfo(n.shape,"complex64"),u=a.data.get(o.dataId);return u.complexTensorInfos={real:a.makeTensorInfo(n.shape,"float32",s),imag:a.makeTensorInfo(r.shape,"float32",i)},o}var yJ={kernelName:Tb,backendName:"cpu",kernelFunc:rr};function db(e,t,a="float32"){if(a==="complex64"){let r=db(e,t,"float32"),s=db(e,t,"float32");return rr({inputs:{real:r,imag:s},backend:e})}let n=C.makeZerosTypedArray(C.sizeFromShape(t),a);return e.makeTensorInfo(t,a,n)}function Vs(e){let{inputs:t,backend:a}=e,{x:n}=t;return a.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var bJ={kernelName:Fu,backendName:"cpu",kernelFunc:Vs};function Ql(e){let{inputs:t,backend:a}=e,{input:n}=t,r=a.data.get(n.dataId).complexTensorInfos.real,s=a.data.get(r.dataId).values;return a.makeTensorInfo(r.shape,r.dtype,s)}var vJ={kernelName:Lb,backendName:"cpu",kernelFunc:Ql};function cF(e,t,a,n){if(n==="int32"){let r=Int32Array.from(e);return[t,"int32",r]}if(n==="bool"){let r=C.toTypedArray([0],a),[s,i]=Ia((o,u)=>o!==u?1:0)(t,[],e,r,"bool");return[i,"bool",s]}throw new Error(`Error in Cast: failed to cast ${a} to ${n}`)}function Ro(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{dtype:s}=n;if(s==="complex64"){if(r.dtype==="complex64")return Vs({inputs:{x:r},backend:a});let c=db(a,r.shape,r.dtype),f=Ro({inputs:{x:r},backend:a,attrs:{dtype:"float32"}}),m=rr({inputs:{real:f,imag:c},backend:a});return a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(f),m}if(r.dtype==="complex64"){let c=Ql({inputs:{input:r},backend:a}),f=Ro({inputs:{x:c},backend:a,attrs:{dtype:s}});return a.disposeIntermediateTensorInfo(c),f}if(!C.hasEncodingLoss(r.dtype,s)){let c=Vs({inputs:{x:r},backend:a});return{dataId:c.dataId,shape:c.shape,dtype:s}}let i=a.data.get(r.dataId).values,[o,u,d]=cF(i,r.shape,r.dtype,s);return a.makeTensorInfo(o,u,d)}var xJ={kernelName:gu,backendName:"cpu",kernelFunc:Ro};function Ga(e,t,a,n){return a==null?({inputs:r,backend:s})=>{let{a:i,b:o}=r,u=s;Be([i,o],e);let d=u.data.get(i.dataId).values,c=u.data.get(o.dataId).values,f=i.dtype==="string"?D.fromUint8ToStringArray(d):d,m=i.dtype==="string"?D.fromUint8ToStringArray(c):c,g=n||i.dtype,[b,v]=t(i.shape,o.shape,f,m,g);return u.makeTensorInfo(v,g,b)}:({inputs:r,backend:s})=>{let{a:i,b:o}=r,u=s;if(i.dtype==="complex64"||o.dtype==="complex64"){let d=Ro({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(d.dataId),f=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,g=u.data.get(f.dataId).values,b=u.data.get(m.dataId).values,v=Ro({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),x=u.data.get(v.dataId),k=x.complexTensorInfos.real,S=x.complexTensorInfos.imag,N=u.data.get(k.dataId).values,T=u.data.get(S.dataId).values,[_,R,M]=a(i.shape,o.shape,g,b,N,T),F=u.makeTensorInfo(M,"float32",_),B=u.makeTensorInfo(M,"float32",R),V=rr({inputs:{real:F,imag:B},backend:u});return u.disposeIntermediateTensorInfo(d),u.disposeIntermediateTensorInfo(v),u.disposeIntermediateTensorInfo(F),u.disposeIntermediateTensorInfo(B),V}else{let d=u.data.get(i.dataId).values,c=u.data.get(o.dataId).values,f=n||i.dtype,[m,g]=t(i.shape,o.shape,d,c,f);return u.makeTensorInfo(g,f,m)}}}function H2(e){return(t,a,n,r,s,i)=>{let o=D.assertAndGetBroadcastShape(t,a),u=C.sizeFromShape(o),d=o.length,c=C.computeStrides(o),f=C.getTypedArrayFromDType("float32",u),m=C.getTypedArrayFromDType("float32",u),g=D.getBroadcastDims(t,o),b=D.getBroadcastDims(a,o),v=D.mergeRealAndImagArrays(n,r),x=D.mergeRealAndImagArrays(s,i),k=t.length,S=C.computeStrides(t),N=a.length,T=C.computeStrides(a);if(g.length+b.length===0)for(let _=0;_<f.length;_++){let R=_%v.length,M=_%x.length,F=e(v[R*2],v[R*2+1],x[M*2],x[M*2+1]);f[_]=F.real,m[_]=F.imag}else for(let _=0;_<f.length;_++){let R=C.indexToLoc(_,d,c),M=R.slice(-k);g.forEach(A=>M[A]=0);let F=C.locToIndex(M,k,S),B=R.slice(-N);b.forEach(A=>B[A]=0);let V=C.locToIndex(B,N,T),P=e(v[F*2],v[F*2+1],x[V*2],x[V*2+1]);f[_]=P.real,m[_]=P.imag}return[f,m,o]}}var dF=Ia((e,t)=>e+t),wJ=H2((e,t,a,n)=>({real:e+a,imag:t+n})),Vd=Ga(Oo,dF,wJ),kJ={kernelName:Oo,backendName:"cpu",kernelFunc:Vd};function q2(e,t,a,n,r){let s=C.sizeFromShape(n),i=C.makeZerosTypedArray(r,a);for(let o=0;o<e.length;o++){let u=e[o];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(s>0?i[u]+=t[o]:i[u]+=1)}return i}function hF(e,t,a,n=!1){let r=e.shape[0],s=e.shape[1],i=ct([r,a],t.dtype);for(let o=0;o<r;o++)for(let u=0;u<s;u++){let d=e.get(o,u);if(d<0)throw new Error("Input x must be non-negative!");d>=a||(n?i.set(1,o,d):t.size>0?i.set(i.get(o,d)+t.get(o,u),o,d):i.set(i.get(o,d)+1,o,d))}return i}var pF=Ia((e,t)=>e&t),SJ=Ga(ah,pF),IJ={kernelName:ah,backendName:"cpu",kernelFunc:SJ};function js(e){return(t,a,n)=>{let r=C.getArrayFromDType(a,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],n);return r}}function Lt(e,t,a){let n=js(t);return Ho(e,n,a)}function Ho(e,t,a){return({inputs:n,attrs:r,backend:s})=>{let{x:i}=n;Be(i,e);let o=s,u=o.data.get(i.dataId).values,d;if(i.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");d=D.fromUint8ToStringArray(u)}else d=u;let c=a||i.dtype,f=t(d,c,r);return o.makeTensorInfo(i.shape,c,f)}}var fF=js(e=>Math.ceil(e)),NJ=Ho(yu,fF),TJ={kernelName:yu,backendName:"cpu",kernelFunc:NJ};function j2(e,t,a,n){let r=C.getArrayFromDType(a,C.sizeFromShape(t));if(n&&a!=="string"){let s=0;e.forEach(i=>{let o=C.sizeFromShape(i.shape);r.set(i.vals,s),s+=o})}else{let s=0;e.forEach(i=>{let o=a==="string"?D.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let d=0;d<i.shape[0];++d){let c=d*t[1]+s;for(let f=0;f<i.shape[1];++f)r[c+f]=o[u++]}s+=i.shape[1]})}return r}var mF=Ia((e,t)=>e===t?1:0),gF=Ga(ch,mF,null,"bool"),_J={kernelName:ch,backendName:"cpu",kernelFunc:gF},yF=js(e=>Math.exp(e)),bF=Ho(Eu,yF,"float32"),CJ={kernelName:Eu,backendName:"cpu",kernelFunc:bF},vF=js(e=>Math.expm1(e)),EJ=Ho(Au,vF),AJ={kernelName:Au,backendName:"cpu",kernelFunc:EJ},xF=js(e=>Math.floor(e)),$J=Ho($u,xF),RJ={kernelName:$u,backendName:"cpu",kernelFunc:$J},wF=Ia((e,t)=>Math.floor(e/t)),DJ=Ga(Ru,wF,null,"int32"),MJ={kernelName:Ru,backendName:"cpu",kernelFunc:DJ};function kF(e,t,a,n,r,s,i,o,u){let d=ct([n,s],a);for(let c=0;c<n;c++){let f=[],m=0;for(let g=0;g<r;g++){let b=e[c*r+g];m+=b*i[g],f.push(b)}if(m<0||m>=u/s)throw new Error(`Invalid indices: ${f} does not index into ${o}`);for(let g=0;g<s;g++)d.values[c*s+g]=t.get(...t.indexToLoc(m*s+g))}return d}function SF(e,t,a){let n=ct(a,e.dtype);for(let r=0;r<n.size;++r){let s=n.indexToLoc(r).slice(),i=s[0],o=s[2],u=t.locToIndex([i,o]);s[2]=t.values[u];let d=e.locToIndex(s);0<=d&&d<e.values.length&&(n.values[r]=e.values[d])}return n}var IF=Ia((e,t)=>e>t?1:0),FJ=Ga(mh,IF,null,"bool"),OJ={kernelName:mh,backendName:"cpu",kernelFunc:FJ},NF=Ia((e,t)=>e>=t?1:0),zJ=Ga(Mu,NF,null,"bool"),LJ={kernelName:Mu,backendName:"cpu",kernelFunc:zJ},TF=Ia((e,t)=>e<t?1:0),BJ=Ga(gh,TF,null,"bool"),UJ={kernelName:gh,backendName:"cpu",kernelFunc:BJ},_F=Ia((e,t)=>e<=t?1:0),PJ=Ga(yh,_F,null,"bool"),WJ={kernelName:yh,backendName:"cpu",kernelFunc:PJ};function CF(e,t,a){let n=(t-e)/(a-1),r=C.makeZerosTypedArray(a,"float32");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+n;return r}var EF=js(e=>Math.log(e)),VJ=Ho(Uu,EF),GJ={kernelName:Uu,backendName:"cpu",kernelFunc:VJ};function AF(e,t,a,n){let r=C.getTypedArrayFromDType(n,C.sizeFromShape(a));for(let s=0;s<r.length;++s){let i=s*t,o=e[i];for(let u=0;u<t;++u){let d=e[i+u];(Number.isNaN(d)||d>o)&&(o=d)}r[s]=o}return r}var $F=Ia((e,t)=>Math.max(e,t)),HJ=Ga(Gu,$F),qJ={kernelName:Gu,backendName:"cpu",kernelFunc:HJ},RF=Ia((e,t)=>Math.min(e,t)),jJ=Ga(Ku,RF),KJ={kernelName:Ku,backendName:"cpu",kernelFunc:jJ},K2=Ia((e,t)=>e*t),XJ=H2((e,t,a,n)=>({real:e*a-t*n,imag:e*n+t*a})),Gv=Ga(Zu,K2,XJ),YJ={kernelName:Zu,backendName:"cpu",kernelFunc:Gv};function DF(e,t,a){let n=C.createScalarValue(-1,a);return K2([],t,n,e,a)}function ZJ(e){let{inputs:t,backend:a}=e,{x:n}=t;Be(n,"neg");let r=a.data.get(n.dataId).values,[s,i]=DF(r,n.shape,n.dtype);return a.makeTensorInfo(i,n.dtype,s)}var QJ={kernelName:Nh,backendName:"cpu",kernelFunc:ZJ},MF=Ia((e,t)=>e!==t?1:0),JJ=Ga(Th,MF,null,"bool"),eee={kernelName:Th,backendName:"cpu",kernelFunc:JJ};function X2(e,t,a,n,r){let s=t.length,i=C.sizeFromShape(t),o=C.computeStrides(t),u=C.computeStrides(r),d=C.getTypedArrayFromDType(a,C.sizeFromShape(r));for(let c=0;c<i;++c){let f=C.indexToLoc(c,s,o),m=new Array(f.length);for(let b=0;b<m.length;b++)m[b]=f[n[b]];let g=C.locToIndex(m,s,u);d[g]=e[c]}return d}function qn(e){let{inputs:t,attrs:a,backend:n}=e,{x:r}=t,{perm:s}=a;Be(r,"transpose");let i=r.shape.length,o=new Array(i);for(let c=0;c<o.length;c++)o[c]=r.shape[s[c]];let u=n.data.get(r.dataId).values,d=X2(u,r.shape,r.dtype,s,o);return{dataId:n.write(d,o,r.dtype),shape:o,dtype:r.dtype}}var tee={kernelName:yi,backendName:"cpu",kernelFunc:qn};function FF(e,t,a,n){let[r,s]=D.computeOutAndReduceShapes(e,n),i=Nr(t,"int32"),o=C.makeZerosTypedArray(C.sizeFromShape(r),i),u=C.sizeFromShape(s);for(let d=0;d<o.length;++d){let c=d*u,f=1;for(let m=0;m<u;++m)f*=a[c+m];o[d]=f}return{outVals:o,outShape:r,outDtype:i}}function aee(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n;Be(r,"prod");let o=r.shape.length,u=C.parseAxisParam(s,r.shape),d=D.getAxesPermutation(u,o),c=u,f=r,m=[];d!=null&&(f=qn({inputs:{x:r},backend:a,attrs:{perm:d}}),m.push(f),c=D.getInnerMostAxes(c.length,o));let g=a.data.get(f.dataId).values,{outVals:b,outShape:v,outDtype:x}=FF(f.shape,f.dtype,g,c),k=v;return i&&(k=D.expandShapeToKeepDim(v,u)),m.forEach(S=>a.disposeIntermediateTensorInfo(S)),a.makeTensorInfo(k,x,b)}var nee={kernelName:ac,backendName:"cpu",kernelFunc:aee};function ree(e,t,a){e.forEach((n,r)=>{if(n<0||n>=a){let s=C.indexToLoc(r,t.length,C.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${n} is not in [0, ${a})`)}})}function see(e,t){for(let a=0;a<e.length;++a){let n=e[a],r=a===e.length-1?t:e[a+1].length;if(n.length===0)throw new Error("Ragged splits may not be empty");if(n[0]<0)throw new Error("Ragged splits must be non-negative");if(n[n.length-1]>r)throw new Error("Ragged splits must not point past values");for(let s=1;s<n.length;++s)if(n[s-1]>n[s])throw new Error("Ragged splits must be sorted in ascending order")}}function iee(e,t,a,n){let r=[],s=0,i=t.length-1+a.length,o=new Array(i).fill(null).map(()=>[0]);see(a,n);let u=1;for(let d=0;d<t.length-1;++d){u*=t[d];let c=t[d+1];for(let f=1;f<u+1;++f)o[d].push(f*c)}for(let d=0;d<e.length;++d){let c=e[d],f=e[d]+1;for(let m=0;m<a.length;++m){let g=a[m],b=m+t.length-1;if(b>=0){let v=o[b],x=v[v.length-1]-g[c];for(let k=c;k<f;++k)o[b].push(g[k+1]+x)}c=g[c],f=g[f]}f!==c&&(r.push([c,f]),s+=f-c)}return{outSplits:o,valueSlices:r,numValues:s}}function oee(e){let t=[];for(let a=0;a<e.length;++a){let n=e[a].length,r=C.getArrayFromDType("int32",n);t.push(r),e[a].forEach((s,i)=>r[i]=s)}return t}function TE(e,t){let a=e.slice(0,t);for(;a.length<t;)a.push(1);for(let n=t;n<e.length;n++)a[t-1]*=e[n];return a}function lee(e,t,a,n,r,s){let i=TE(t,2)[1],o=TE(s,2)[1],u=0;for(let d of a)for(let c=d[0];c<d[1];++c){for(let f=0;f<n;++f)r[u*o+f]=e[c*i+f];++u}}function uee(e,t,a,n,r){let s=t.slice();s[0]=r;let i=C.getArrayFromDType(a,C.sizeFromShape(s)),o=e.length,u=o===0?0:o/t[0];return lee(e,t,n,u,i,s),[i,s]}function OF(e,t,a,n,r,s,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let u=t[0][0]-1;if(ree(s,i,u),n.length===0)throw new Error("params.rank must be nonzero");let d=n[0],{outSplits:c,valueSlices:f,numValues:m}=iee(s,i,e,d),g=oee(c),b=uee(a,n,r,f,m);return[g,b[0],b[1]]}var _E=2147483647;function zF(e,t,a,n,r,s,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,u=r.length===0,d=i.length===0,c=[];o||c.push(t[0]),u||c.push(r[0]),d||c.push(i[0]);for(let x=1;x<c.length;++x)if(c[x]!==c[x-1])throw new Error("starts, limits, and deltas must have the same shape");let f=c.length===0?1:c[0],m=C.getArrayFromDType("int32",f+1);m[0]=0;for(let x=0;x<f;++x){let k=o?e[0]:e[x],S=u?n[0]:n[x],N=d?s[0]:s[x];if(N===0)throw new Error("Requires delta != 0");let T;if(N>0&&S<k||N<0&&S>k)T=0;else if(T=Math.ceil(Math.abs((S-k)/N)),T>_E)throw new Error(`Requires ((limit - start) / delta) <= ${_E}`);m[x+1]=m[x]+T}let g=m[f],b=C.getArrayFromDType(a,g),v=0;for(let x=0;x<f;++x){let k=m[x+1]-m[x],S=o?e[0]:e[x],N=d?s[0]:s[x];for(let T=0;T<k;++T)b[v++]=S,S+=N}return[m,b]}var Ur=D.RowPartitionType,cee=class c1{constructor(t,a,n,r,s,i,o,u,d,c){this.shape=t,this.shapeShape=a,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=d,this.rowPartitionTypes=D.getRowPartitionTypesHelper(c),this.raggedRank=D.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Ur.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Ur.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let a=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Ur.VALUE_ROWIDS:return c1.getMaxWidthValueRowID(a);case Ur.ROW_SPLITS:return c1.getMaxWidthRowSplit(a);default:throw new Error(`Cannot handle partition type ${Ur[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let a=t.length;if(a===0||a===1)return 0;let n=0;for(let r=0;r<a-1;++r){let s=t[r+1]-t[r];s>n&&(n=s)}return n}static getMaxWidthValueRowID(t){let a=t.length;if(a===0)return 0;let n=0,r=t[0],s=0;for(let i=1;i<a;++i){let o=t[i];o!==r&&(r=o,s=Math.max(i-n,s),n=i)}return Math.max(a-n,s)}tensorShapeFromTensor(t,a,n=!0){if(a.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return EE(t,n)}calculateOutputSize(t){let a=this.valuesShape,n=this.defaultValueShape;D.validateDefaultValueShape(n,a);let r=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=D.combineRaggedTensorToTensorShapes(this.raggedRank,r,a);s[0]<0&&(s[0]=t);for(let i=1;i<=this.raggedRank;++i)s[i]<0&&(s[i]=this.getMaxWidth(i));return s}calculateFirstParentOutputIndex(t,a,n){let r=Math.min(t,n),s=[],i=0;for(let o=0;o<r;++o,i+=a)s.push(i);for(let o=r;o<t;++o)s.push(-1);return C.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,a,n,r){let s=t.length,i=[];for(let o=0;o<s-1;++o){let u=t[o+1]-t[o],d=Math.min(r,u),c=a[o];c===-1&&(d=0);for(let f=0;f<d;++f)i.push(c),c+=n;for(let f=0;f<u-d;++f)i.push(-1)}if(s>0&&i.length!==t[s-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,a,n,r){let s=t.length,i=[];if(s===0)return[];let o=0,u=t[0];if(u>=a.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${a.length}`);let d=a[u];i.push(d);for(let c=1;c<s;++c){let f=t[c];if(f===u)d>=0&&(++o,o<r?d+=n:d=-1);else{if(o=0,u=f,f>=a.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${a.length}`);d=a[f]}i.push(d)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,a,n,r){let s=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Ur.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,a,n,r);case Ur.ROW_SPLITS:if(s.length-1>a.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${a.length}`);return this.calculateOutputIndexRowSplit(s,a,n,r);default:throw new Error(`Unsupported partition type: ${Ur[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let a=this.rowPartitionTypes[0];switch(a){case Ur.FIRST_DIM_SIZE:return t[0];case Ur.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ur.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ur[a]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),a=this.calculateOutputSize(t),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let i=n.length-2;i>=0;--i)n[i]=n[i+1]*a[i+1];let r=EE(a,!1),s=C.getArrayFromDType(this.valuesDType,C.sizeFromShape(r));if(n[0]*a[0]>0){let i=this.calculateFirstParentOutputIndex(t,n[0],a[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,n[o],a[o]);this.setOutput(this.raggedRank,i,s,r)}return[r,s]}setOutput(t,a,n,r){if(n.length===0)return;let s=this.values,i=n,o=r.slice();o=o.slice(t+1);let u=C.sizeFromShape(o),d=a.length,c=this.defaultValue;if(c.length!==u&&c.length!==1){let b=this.defaultValueShape;ae(()=>{let v=te(c,b);c=Ml(v,o).dataSync()})}let f=0,m=0,g=0;for(let b=0;b<=d;++b){let v=b<d?a[b]:-1;if(v===g){++g;continue}if(m<g){let x=s.subarray(f*u),k=i.subarray(m*u),S=(g-m)*u;CE(k,x,S)}if(b>=d){let x=n.length;v=Math.floor(x/u)}if(v>g)if(this.defaultValue.length===1)i.subarray(g*u,v*u).fill(this.defaultValue[0]),g=v;else for(;v>g;){let x=i.slice(g*u);CE(x,c,u),++g}v<0?(f=b+1,m=g):(f=b,m=g,g=m+1)}}};function CE(e,t,a){for(let n=0;n<a;n++)e[n]=t[n]}function EE(e,t){let a=[];for(let n of e){if(n<0){if(!t)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}a.push(n)}return a}function LF(e,t,a,n,r,s,i,o,u,d){return new cee(e,t,a,n,r,s,i,o,u,d).compute()}function Y2(e,t,a,n){let r=e===t,s=e<t&&a<0,i=t<e&&a>1;if(r||s||i)return C.makeZerosTypedArray(0,n);let o=Math.abs(Math.ceil((t-e)/a)),u=C.makeZerosTypedArray(o,n);t<e&&a===1&&(a=-1),u[0]=e;for(let d=1;d<u.length;d++)u[d]=u[d-1]+a;return u}var BF=js(e=>1/Math.sqrt(e)),dee=Ho(cc,BF),hee={kernelName:cc,backendName:"cpu",kernelFunc:dee};function Dl(e,t,a,n,r,s,i,o,u,d){let c=[n/r,r],f=e.values,m=t.values;if(n===0)return ct(a,t.dtype);let g=u instanceof Aa?u:ct(c,t.dtype);typeof u=="string"||typeof u=="number"?g.values.fill(u):typeof u=="boolean"&&g.values.fill(+u);for(let b=0;b<s;b++){let v=[],x=0;for(let k=0;k<i;k++){let S=f[b*i+k];v.push(S),x+=S*o[k]}if(x<0||x>=n/r)throw new Error(`Invalid indices: ${v} does not index into ${a}`);for(let k=0;k<r;k++)d?g.values[x*r+k]+=m[b*r+k]:g.values[x*r+k]=t.rank===0?m[0]:m[b*r+k]}return g}var pee=js(e=>1/(1+Math.exp(-e))),UF=Lt(mc,e=>1/(1+Math.exp(-e))),fee={kernelName:mc,backendName:"cpu",kernelFunc:UF};function hb(e,t,a,n,r){let s=Pa.isSliceContinous(n,t,a),i=C.sizeFromShape(a),o=C.computeStrides(n);if(s){let f=Pa.computeFlatOffset(t,o);return r==="string"?e.slice(f,f+i):e.subarray(f,f+i)}let u=r==="string"?D.fromUint8ToStringArray(e):e,d=ct(n,r,u),c=ct(a,r);for(let f=0;f<c.size;++f){let m=c.indexToLoc(f),g=m.map((b,v)=>b+t[v]);c.set(d.get(...g),...m)}return r==="string"?D.fromStringArrayToUint8(c.values):c.values}function Jl(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{begin:s,size:i}=n;Be(r,"slice");let[o,u]=Pa.parseSliceParams(r,s,i);Pa.assertParamsValid(r,o,u);let d=a.data.get(r.dataId).values,c=hb(d,o,u,r.shape,r.dtype);return a.makeTensorInfo(u,r.dtype,c)}var mee={kernelName:Bh,backendName:"cpu",kernelFunc:Jl};function PF(e,t,a,n,r,s,i){let o=t[0],u=s[0],d=new Array(u),c=new Array(o),f=t[1];if(u===0){if(o!==0)throw new Error(D.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let x=C.getArrayFromDType(a,0),k=C.getArrayFromDType(r,0);return[x,[0,f],k,d,c]}let m=!0,g=0,b=new Array(u).fill(0);for(let x=0;x<o;++x){let k=e[x*f];if(k<0)throw new Error(D.getSparseFillEmptyRowsNegativeIndexErrorMessage(x,k));if(k>=u)throw new Error(D.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(x,k,u));++b[k],m=m&&k>=g,g=k}let v=!0;for(let x=0;x<u;++x){let k=b[x]===0;d[x]=k,v=v&&!k,b[x]=Math.max(b[x],1),x>0&&(b[x]+=b[x-1])}if(v&&m){let x=e,k=n;for(let S=0;S<o;++S)c[S]=S;return[x,[o,f],k,d,c]}else{let x=b[u-1],k=C.getArrayFromDType(a,x*f),S=C.getArrayFromDType(r,x),N=new Array(u).fill(0);for(let T=0;T<o;++T){let _=e[T*f],R=N[_],M=(_===0?0:b[_-1])+R;N[_]++;for(let F=0;F<f;++F)k[M*f+F]=e[T*f+F];S[M]=n[T],c[T]=M}for(let T=0;T<u;++T)if(N[T]===0){let _=T===0?0:b[T-1];k[_*f+0]=T;for(let R=1;R<f;++R)k[_*f+R]=0;S[_]=i}return[k,[x,f],S,d,c]}}function WF(e,t,a,n,r){let s=C.sizeFromShape(n),i=t[0],o=r.length,u=[],d=1,c=-1;for(let v=0;v<o;++v){let x=r[v];if(x===-1){if(c!==-1)throw new Error(D.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,v));c=v,u.push(1)}else{if(x<0)throw new Error(D.getSparseReshapeNegativeOutputDimErrorMessage(v,x));d*=x,u.push(x)}}if(c!==-1){if(d<=0)throw new Error(D.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let v=Math.trunc(s/d);if(d*v!==s)throw new Error(D.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[c]=v}if(C.sizeFromShape(u)!==s)throw new Error(D.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let f=n.length,m=[];if(f>0){m[f-1]=1;for(let v=f-2;v>=0;--v)m[v]=m[v+1]*n[v+1]}let g=[];if(o>0){g[o-1]=1;for(let v=o-2;v>=0;--v)g[v]=g[v+1]*u[v+1]}let b=C.getArrayFromDType(a,i*o);for(let v=0;v<i;++v){let x=0;for(let k=0;k<f;++k)x+=e[v*f+k]*m[k];for(let k=0;k<o;++k)b[v*o+k]=Math.trunc(x/g[k]),x%=g[k]}return[b,[i,o],u]}function Z2(e,t,a,n,r,s=!1,i=0){let o=n.length,u=[t[0],e.length/t[0]],d=u[1],c=o>0?r[o-1]+1:0;if(c<0)throw new Error(D.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=t.slice();f[0]=c;let m=f.reduce((S,N)=>S*N,1),g=C.getArrayFromDType(a,m);if(o===0)return c>0&&g.fill(i),[g,f];if(c<=0)throw new Error(D.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let b=0,v=1,x=0,k=r[b];for(;;){let S=0;if(v<o){if(S=r[v],k===S){++v;continue}if(k>=S)throw new Error(D.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(k<0||k>=c)throw new Error(D.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(k,c));k>x&&g.fill(i,x*d,k*d);for(let N=b;N<v;++N){let T=n[N];if(T<0||T>=u[0])throw new Error(D.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(N,n[N],u[0]));for(let _=0;_<d;_++)g[k*d+_]+=e[T*d+_]}if(s)for(let N=0;N<d;N++)g[k*d+N]/=v-b;if(b=v,++v,x=k+1,k=S,v>o)break}return x<c&&g.fill(i,x*d,c*d),[g,f]}var gee=js(e=>Math.sqrt(e)),yee=Lt(yc,e=>Math.sqrt(e)),bee={kernelName:yc,backendName:"cpu",kernelFunc:yee},VF=Ia((e,t)=>{let a=e-t;return a*a}),vee=Ga(xc,VF),xee={kernelName:xc,backendName:"cpu",kernelFunc:vee},GF=js((e,t)=>{let{pattern:a,replaceGlobal:n,rewrite:r}=t;return e.replace(new RegExp(a,n?"g":""),r)}),wee=Ho(Nm,GF),kee={kernelName:Nm,backendName:"cpu",kernelFunc:wee};function HF(e,t,a,n){let r=ct(e,t.dtype);for(let s=0;s<r.size;s++){let i=r.indexToLoc(s),o=new Array(i.length);for(let u=0;u<o.length;u++)o[u]=i[u]*a[u]+n[u];r.set(t.get(...o),...i)}return r}var See=class{constructor(e,t,a,n,r,s){this.separator=C.encodeString(e),this.nGramWidths=t,this.leftPad=C.encodeString(a),this.rightPad=C.encodeString(n),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let a=this.getPadWidth(t);return Math.max(0,e+2*a-t+1)}createNGrams(e,t,a,n,r,s){for(let i=0;i<r;++i){let o=this.getPadWidth(s),u=Math.max(0,o-i),d=Math.max(0,o-(r-(i+1))),c=s-(u+d),f=t+(u>0?0:i-o),m=0;m+=u*this.leftPad.length;for(let k=0;k<c;++k)m+=e[f+k].length;m+=d*this.rightPad.length;let g=u+d+c-1;m+=g*this.separator.length,a[n+i]=new Uint8Array(m);let b=a[n+i],v=0,x=k=>k.forEach(S=>b[v++]=S);for(let k=0;k<u;++k)x(this.leftPad),x(this.separator);for(let k=0;k<c-1;++k)x(e[f+k]),x(this.separator);if(c>0){x(e[f+c-1]);for(let k=0;k<d;++k)x(this.separator),x(this.rightPad)}else{for(let k=0;k<d-1;++k)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,t){let a=e.length,n=t.length;if(n>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let u=1;u<n;++u){let d=t[u]>=o;if(d=d&&t[u]<=a,!d)throw new Error(`Invalid split value ${t[u]}, must be in [${o}, ${a}]`);o=t[u]}if(o!==a)throw new Error(`Last split value must be data size. Expected ${a}, got ${o}`)}let r=n-1,s=C.getArrayFromDType("int32",n);if(a===0||n===0){let o=new Array(a);for(let u=0;u<=r;++u)s[u]=0;return[o,s]}s[0]=0;for(let o=1;o<=r;++o){let u=t[o]-t[o-1],d=0;this.nGramWidths.forEach(c=>{d+=this.getNumNGrams(u,c)}),this.preserveShort&&u>0&&d===0&&(d=1),s[o]=s[o-1]+d}let i=new Array(s[r]);for(let o=0;o<r;++o){let u=t[o],d=s[o];if(this.nGramWidths.forEach(c=>{let f=t[o+1]-t[o],m=this.getNumNGrams(f,c);this.createNGrams(e,u,i,d,m,c),d+=m}),this.preserveShort&&d===s[o]){let c=t[o+1]-t[o];if(c===0)continue;let f=c+2*this.padWidth;this.createNGrams(e,u,i,d,1,f)}}return[i,s]}};function Q2(e,t,a,n,r,s,i,o){return new See(a,n,r,s,i,o).compute(e,t)}function Iee(e,t,a,n){if(!e.length)return;if(t.length===0){for(let s=0;s<e.length;++s)n.push(e.subarray(s,s+1));return}if(t.length===1){let s=t[0],i=e.indexOf(s);for(;i!==-1;){let o=e.subarray(0,i);(!a||o.length!==0)&&n.push(o),e=e.subarray(i+1),i=e.indexOf(s)}(!a||e.length!==0)&&n.push(e);return}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||t.indexOf(e[s])!==-1){let i=e.subarray(r,s);(!a||i.length!==0)&&n.push(i),r=s+1}}function J2(e,t,a){let n=e.length,r=[],s=0,i=0,o=new Array(n);for(let m=0;m<n;++m){let g=r.length;Iee(e[m],t,a,r);let b=r.length-g;o[m]=b,s+=b,i=Math.max(i,b)}let u=C.getArrayFromDType("int32",s*2),d=new Array(s),c=[n,i],f=0;for(let m=0;m<n;++m)for(let g=0;g<o[m];++g)u[f*2]=m,u[f*2+1]=g,d[f]=r[f],++f;return[u,d,c]}function eI(e,t){let a=C.getArrayFromDType("int32",e.length);for(let n=0;n<e.length;++n)a[n]=C.fingerPrint64(e[n]).modulo(t).getLowBitsUnsigned();return a}var qF=Ia((e,t)=>e-t),Nee=H2((e,t,a,n)=>({real:e-a,imag:t-n})),tI=Ga(wc,qF,Nee),Tee={kernelName:wc,backendName:"cpu",kernelFunc:tI};function jF(e,t){let a=new Array(e.rank);for(let r=0;r<a.length;r++)a[r]=e.shape[r]*t[r];let n=ct(a,e.dtype);for(let r=0;r<n.values.length;++r){let s=n.indexToLoc(r),i=new Array(e.rank);for(let u=0;u<i.length;u++)i[u]=s[u]%e.shape[u];let o=e.locToIndex(i);n.values[r]=e.values[o]}return n}var Af=(e,t)=>{let a=t.value-e.value;return a===0?e.index-t.index:a};function KF(e,t,a=0,n=e.length-1){for(;n>a;){if(n-a>600){let o=n-a+1,u=t-a+1,d=Math.log(o),c=.5*Math.exp(2*d/3),f=.5*Math.sqrt(d*c*(o-c)/o)*Math.sign(u-o/2),m=Math.max(a,Math.floor(t-u*c/o+f)),g=Math.min(n,Math.floor(t+(o-u)*c/o+f));KF(e,t,m,g)}let r=e[t],s=a,i=n;for(C.swap(e,a,t),Af(e[n],r)>0&&C.swap(e,a,n);s<i;){for(C.swap(e,s,i),s++,i--;Af(e[s],r)<0;)s=s+1;for(;Af(e[i],r)>0;)i=i-1}Af(e[a],r)===0?C.swap(e,a,i):(i=i+1,C.swap(e,i,n)),i<=t&&(a=i+1),t<=i&&(n=i-1)}}function XF(e,t,a,n,r){let s=t[t.length-1],[i,o]=[e.length/s,s],u=C.getTypedArrayFromDType(a,i*n),d=C.getTypedArrayFromDType("int32",i*n);for(let f=0;f<i;f++){let m=f*o,g=e.subarray(m,m+o),b=new Array(g.length);g.forEach((S,N)=>b[N]={value:S,index:N}),n<b.length&&(KF(b,n),b=b.slice(0,n)),r&&b.sort(Af);let v=f*n,x=u.subarray(v,v+n),k=d.subarray(v,v+n);for(let S=0;S<n;S++)x[S]=b[S].value,k[S]=b[S].index}let c=t.slice();return c[c.length-1]=n,[ct(c,a,u),ct(c,"int32",d)]}function aI(e,t,a,n){let r=C.parseAxisParam(t,a)[0],s=[1,a[0],1];for(let b=0;b<r;b++)s[0]*=a[b];s[1]=a[r];for(let b=r+1;b<a.length;b++)s[2]*=a[b];let i=new Map,o=new Int32Array(a[r]),u=new Aa(s,n,e),d=[],c=s[0]===1&&s[2]===1;for(let b=0;b<a[r];b++){let v;if(c)v=e[b].toString();else{let k=[];for(let S=0;S<s[0];S++)for(let N=0;N<s[2];N++)k.push(u.get(S,b,N));v=k.join(",")}let x=i.get(v);if(x!=null)o[b]=x;else{let k=i.size;i.set(v,k),o[b]=k,d.push(b)}}let f=s.slice();f[1]=i.size;let m=new Aa(f,n);d.forEach((b,v)=>{for(let x=0;x<s[0];x++)for(let k=0;k<s[2];k++)m.set(u.get(x,b,k),x,v,k)});let g=a.slice();return g[r]=f[1],{outputValues:m.values,outputShape:g,indices:o}}var _ee="4.22.0";Pb("cpu",()=>new V2,1);var YF=Lt(_u,e=>e>=0?e:Math.exp(e)-1),Cee={kernelName:_u,backendName:"cpu",kernelFunc:YF};function ZF(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{alpha:s}=n;Be([r],"leakyRelu");let i=C.sizeFromShape(r.shape),o=a.data.get(r.dataId).values,u=C.getTypedArrayFromDType("float32",i);for(let d=0;d<o.length;d++)u[d]=o[d]<0?s*o[d]:o[d];return a.makeTensorInfo(r.shape,"float32",u)}var Eee={kernelName:Bu,backendName:"cpu",kernelFunc:ZF},Aee=Ia((e,t)=>e<0?t*e:e);function QF(e){let{inputs:t,backend:a}=e,{x:n,alpha:r}=t;Be([n,r],"prelu");let s=a.data.get(n.dataId).values,i=a.data.get(r.dataId).values,[o,u]=Aee(n.shape,r.shape,s,i,"float32");return a.makeTensorInfo(u,"float32",o)}var $ee={kernelName:tc,backendName:"cpu",kernelFunc:QF},JF=Lt(rc,e=>Math.max(0,e)),Ree={kernelName:rc,backendName:"cpu",kernelFunc:JF},eO=Lt(oc,e=>Math.min(Math.max(0,e),6)),Dee={kernelName:oc,backendName:"cpu",kernelFunc:eO};function pb(e,t,a,n,r){if(a==="linear")return Vs({inputs:{x:t},backend:e});if(a==="relu")return JF({inputs:{x:t},backend:e});if(a==="elu")return YF({inputs:{x:t},backend:e});if(a==="relu6")return eO({inputs:{x:t},backend:e});if(a==="prelu")return QF({inputs:{x:t,alpha:n},backend:e});if(a==="leakyrelu")return ZF({inputs:{x:t},backend:e,attrs:{alpha:r}});if(a==="sigmoid")return UF({inputs:{x:t},backend:e});throw new Error(`Activation ${a} has not been implemented for the CPU backend.`)}function aa(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{shape:s}=n,i=C.sizeFromShape(r.shape),o=C.inferFromImplicitShape(s,i),u=C.sizeFromShape(o);C.assert(i===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),a.incRef(r.dataId);let d=a.data.get(r.dataId);if(d.complexTensorInfos!=null){let c=d.complexTensorInfos.real,f=d.complexTensorInfos.imag;c.shape=o,f.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}var Mee={kernelName:Rh,backendName:"cpu",kernelFunc:aa};function tO(e){let{inputs:t,backend:a,attrs:n}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=n;Be([r,s],"matMul");let u=r.shape.length,d=s.shape.length,c=i?r.shape[u-2]:r.shape[u-1],f=o?s.shape[d-1]:s.shape[d-2],m=i?r.shape[u-1]:r.shape[u-2],g=o?s.shape[d-2]:s.shape[d-1],b=r.shape.slice(0,-2),v=s.shape.slice(0,-2),x=C.sizeFromShape(b),k=C.sizeFromShape(v),S=Yh.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,g]);C.assert(c===f,()=>`Error in matMul: inner shapes (${c}) and (${f}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let N=i?[x,c,m]:[x,m,c],T=o?[k,g,f]:[k,f,g],_=aa({inputs:{x:r},backend:a,attrs:{shape:N}}),R=aa({inputs:{x:s},backend:a,attrs:{shape:T}}),M=i?_.shape[1]:_.shape[2],F=i?_.shape[2]:_.shape[1],B=o?R.shape[1]:R.shape[2],V=Math.max(x,k),P=a.data.get(_.dataId).values,A=a.data.get(R.dataId).values,G=C.computeStrides(_.shape),J=C.computeStrides(R.shape),[ee,W,X]=i?[G[0],1,G[1]]:[G[0],G[1],1],[Q,ce,L]=o?[1,J[1],J[0]]:[J[1],1,J[0]],q=F*B,le=ct([V,F,B],_.dtype),se=le.values,pe=a.blockSize;for(let ve=0;ve<V;ve++){let Ie=ve%x,Re=ve%k;for(let Ne=0;Ne<F;Ne+=pe){let Le=Math.min(Ne+pe,F);for(let je=0;je<B;je+=pe){let Je=Math.min(je+pe,B);for(let st=0;st<M;st+=pe){let At=Math.min(st+pe,M);for(let pt=Ne;pt<Le;pt++)for(let xt=je;xt<Je;xt++){let tt=0;for(let ot=st;ot<At;ot++){let Bt=P[Ie*ee+pt*W+ot*X],pn=A[ot*Q+xt*ce+Re*L];tt+=Bt*pn}se[ve*q+(pt*B+xt)]+=tt}}}}}return a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(R),a.makeTensorInfo(S,le.dtype,le.values)}var Fee={kernelName:mu,backendName:"cpu",kernelFunc:tO};function Oee(e){let{inputs:t,backend:a,attrs:n}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:d,activation:c,leakyreluAlpha:f}=n,m,g,b,v=[];m=tO({inputs:{a:r,b:s},attrs:{transposeA:u,transposeB:d},backend:a}),i&&(g=Vd({inputs:{a:m,b:i},backend:a}),v.push(m),m=g),c&&(b=pb(a,m,c,o,f),v.push(m),m=b);for(let x of v)a.disposeIntermediateTensorInfo(x);return m}var zee={kernelName:Bl,backendName:"cpu",kernelFunc:Oee},Lee=Lt(iu,e=>Math.acos(e)),Bee={kernelName:iu,backendName:"cpu",kernelFunc:Lee},Uee=Lt(ou,e=>Math.acosh(e)),Pee={kernelName:ou,backendName:"cpu",kernelFunc:Uee};function Wee(e){let{inputs:t,backend:a}=e,n=t;Be(t,"addN");let r=n.map(o=>a.data.get(o.dataId).values),s=ct(n[0].shape,n[0].dtype),i=s.values;for(let o=0;o<n.length;o++){let u=r[o];for(let d=0;d<i.length;d++)i[d]+=u[d]}return a.makeTensorInfo(s.shape,s.dtype,s.values)}var Vee={kernelName:lu,backendName:"cpu",kernelFunc:Wee};function Gee(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n;Be(r,"all");let o=C.parseAxisParam(s,r.shape),u=o,d=D.getAxesPermutation(u,r.shape.length),c=r;d!=null&&(c=qn({inputs:{x:r},backend:a,attrs:{perm:d}}),u=D.getInnerMostAxes(u.length,r.shape.length)),D.assertAxesAreInnerMostDims("all",u,c.shape.length);let[f,m]=D.computeOutAndReduceShapes(c.shape,u),g=C.sizeFromShape(m),b=C.makeZerosTypedArray(C.sizeFromShape(f),c.dtype),v=a.data.get(c.dataId).values;for(let k=0;k<b.length;++k){let S=k*g,N=v[S];for(let T=0;T<g;++T){let _=v[S+T];N=N&&_}b[k]=N}d!=null&&a.disposeIntermediateTensorInfo(c);let x=a.makeTensorInfo(f,c.dtype,b);if(i){let k=D.expandShapeToKeepDim(f,o),S=aa({inputs:{x},backend:a,attrs:{shape:k}});return a.disposeIntermediateTensorInfo(x),S}return x}var Hee={kernelName:Xd,backendName:"cpu",kernelFunc:Gee};function qee(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n;Be(r,"any");let o=C.parseAxisParam(s,r.shape),u=o,d=D.getAxesPermutation(u,r.shape.length),c=r;d!=null&&(c=qn({inputs:{x:r},backend:a,attrs:{perm:d}}),u=D.getInnerMostAxes(u.length,r.shape.length)),D.assertAxesAreInnerMostDims("any",u,c.shape.length);let[f,m]=D.computeOutAndReduceShapes(c.shape,u),g=C.sizeFromShape(m),b=C.makeZerosTypedArray(C.sizeFromShape(f),c.dtype),v=a.data.get(c.dataId).values;for(let k=0;k<b.length;++k){let S=k*g,N=v[S];for(let T=0;T<g;++T){let _=v[S+T];N=N||_}b[k]=N}d!=null&&a.disposeIntermediateTensorInfo(c);let x=a.makeTensorInfo(f,c.dtype,b);if(i){let k=D.expandShapeToKeepDim(f,o),S=aa({inputs:{x},backend:a,attrs:{shape:k}});return a.disposeIntermediateTensorInfo(x),S}return x}var jee={kernelName:Yd,backendName:"cpu",kernelFunc:qee};function Kee(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s}=n;Be(r,"argMax");let i=C.parseAxisParam(s,r.shape),o=D.getAxesPermutation(i,r.shape.length),u=r,d=[];o!=null&&(u=qn({inputs:{x:r},backend:a,attrs:{perm:o}}),d.push(u),i=D.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],D.assertAxesAreInnerMostDims("argMax",i,u.shape.length);let[c,f]=D.computeOutAndReduceShapes(u.shape,i),m=C.sizeFromShape(c),g=C.makeZerosTypedArray(m,"int32"),b=C.sizeFromShape(f),v=a.data.get(u.dataId).values;for(let x=0;x<g.length;++x){let k=x*b,S=v[k],N=0;for(let T=0;T<b;++T){let _=v[k+T];_>S&&(S=_,N=T)}g[x]=N}return d.forEach(x=>a.disposeIntermediateTensorInfo(x)),a.makeTensorInfo(c,"int32",g)}var Xee={kernelName:Zd,backendName:"cpu",kernelFunc:Kee};function Yee(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s}=n;Be(r,"argMin");let i=C.parseAxisParam(s,r.shape),o=D.getAxesPermutation(i,r.shape.length),u=r,d=[];o!=null&&(u=qn({inputs:{x:r},backend:a,attrs:{perm:o}}),d.push(u),i=D.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],D.assertAxesAreInnerMostDims("argMin",i,u.shape.length);let[c,f]=D.computeOutAndReduceShapes(u.shape,i),m=C.sizeFromShape(c),g=C.makeZerosTypedArray(m,"int32"),b=C.sizeFromShape(f),v=a.data.get(u.dataId).values;for(let x=0;x<g.length;++x){let k=x*b,S=v[k],N=0;for(let T=0;T<b;++T){let _=v[k+T];_<S&&(S=_,N=T)}g[x]=N}return d.forEach(x=>a.disposeIntermediateTensorInfo(x)),a.makeTensorInfo(c,"int32",g)}var Zee={kernelName:Qd,backendName:"cpu",kernelFunc:Yee},Qee=Lt(uu,e=>Math.asin(e)),Jee={kernelName:uu,backendName:"cpu",kernelFunc:Qee},ete=Lt(cu,e=>Math.asinh(e)),tte={kernelName:cu,backendName:"cpu",kernelFunc:ete},ate=Lt(du,e=>Math.atan(e)),nte={kernelName:du,backendName:"cpu",kernelFunc:ate},rte=Ia((e,t)=>Math.atan2(e,t)),ste=Ga(pu,rte),ite={kernelName:pu,backendName:"cpu",kernelFunc:ste},ote=Lt(hu,e=>Math.atanh(e)),lte={kernelName:hu,backendName:"cpu",kernelFunc:ote};function nI(e,t,a,n,r,s){let i=r.strideHeight,o=r.strideWidth,u=r.dilationHeight,d=r.dilationWidth,c=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.top,g=r.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=ct(r.outShape,a),x=v.values,k=r.outShape[1]*r.outShape[2]*r.outShape[3],S=r.outShape[2]*r.outShape[3],N=r.outShape[3];for(let T=0;T<r.batchSize;++T){let _=T*k,R=T*n[0];for(let M=0;M<r.inChannels;++M)for(let F=0;F<r.outHeight;++F){let B=F*i-m,V=Math.max(0,B),P=Math.min(r.inHeight,c+B),A=_+F*S;for(let G=0;G<r.outWidth;++G){let J=G*o-g,ee=Math.max(0,J),W=Math.min(r.inWidth,f+J),X=b,Q=0,ce=0;for(let q=V;q<P;q+=u){let le=R+q*n[1];for(let se=ee;se<W;se+=d){let pe=le+se*n[2],ve=e[pe+M];s==="max"&&ve>X?X=ve:s==="avg"&&(Q+=ve,ce++)}if(isNaN(X))break}let L=A+G*N+M;x[L]=s==="avg"?Q/ce:X}}}return v}function aO(e,t,a,n,r=!1,s=!1){let i=ct(n.outShape,"int32"),o=n.strideHeight,u=n.strideWidth,d=n.dilationHeight,c=n.dilationWidth,f=n.effectiveFilterHeight,m=n.effectiveFilterWidth,g=n.padInfo.top,b=n.padInfo.left,v=ct(t,a,e);for(let x=0;x<n.batchSize;++x)for(let k=0;k<n.inChannels;++k)for(let S=0;S<n.outHeight;++S){let N=S*o-g,T=N;for(;T<0;)T+=d;let _=Math.min(n.inHeight,f+N);for(let R=0;R<n.outWidth;++R){let M=R*u-b,F=M;for(;F<0;)F+=c;let B=Math.min(n.inWidth,m+M),V=Number.NEGATIVE_INFINITY,P=-1;for(let A=T;A<_;A+=d){let G=A-N;for(let J=F;J<B;J+=c){let ee=J-M,W=v.get(x,A,J,k);W>V&&(V=W,r?P=s?((x*n.inHeight+A)*n.inWidth+J)*n.inChannels+k:(A*n.inWidth+J)*n.inChannels+k:P=G*m+ee)}}i.set(P,x,S,R,k)}}return i}function nO(e,t,a,n,r,s){let i=r.strideDepth,o=r.strideHeight,u=r.strideWidth,d=r.dilationDepth,c=r.dilationHeight,f=r.dilationWidth,m=r.effectiveFilterDepth,g=r.effectiveFilterHeight,b=r.effectiveFilterWidth,v=r.padInfo.front,x=r.padInfo.top,k=r.padInfo.left,S=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,N=ct(r.outShape,a),T=N.values,_=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],R=r.outShape[2]*r.outShape[3]*r.outShape[4],M=r.outShape[3]*r.outShape[4],F=r.outShape[4];for(let B=0;B<r.batchSize;++B){let V=B*_,P=B*n[0];for(let A=0;A<r.inChannels;++A)for(let G=0;G<r.outDepth;++G){let J=G*i-v,ee=J;for(;ee<0;)ee+=d;let W=Math.min(r.inDepth,m+J),X=V+G*R;for(let Q=0;Q<r.outHeight;++Q){let ce=Q*o-x,L=ce;for(;L<0;)L+=c;let q=Math.min(r.inHeight,g+ce),le=X+Q*M;for(let se=0;se<r.outWidth;++se){let pe=se*u-k,ve=pe;for(;ve<0;)ve+=f;let Ie=Math.min(r.inWidth,b+pe),Re=le+se*F,Ne=S,Le=0,je=0;for(let st=ee;st<W;st+=d){let At=P+st*n[1];for(let pt=L;pt<q;pt+=c){let xt=At+pt*n[2];for(let tt=ve;tt<Ie;tt+=f){let ot=xt+tt*n[3],Bt=e[ot+A];if(s==="max"&&Bt>Ne?Ne=Bt:s==="avg"&&(Le+=Bt,je++),isNaN(Ne))break}if(isNaN(Ne))break}if(isNaN(Ne))break}let Je=Re+A;T[Je]=s==="avg"?Le/Math.max(je,1):Ne}}}}return N}function ute(e,t){let a=ct(t.outShape,"int32"),n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,d=t.effectiveFilterDepth,c=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.front,g=t.padInfo.top,b=t.padInfo.left;for(let v=0;v<t.batchSize;++v)for(let x=0;x<t.inChannels;++x)for(let k=0;k<t.outDepth;++k){let S=k*n-m,N=S;for(;N<0;)N+=i;let T=Math.min(t.inDepth,d+S);for(let _=0;_<t.outHeight;++_){let R=_*r-g,M=R;for(;M<0;)M+=o;let F=Math.min(t.inHeight,c+R);for(let B=0;B<t.outWidth;++B){let V=B*s-b,P=V;for(;P<0;)P+=u;let A=Math.min(t.inWidth,f+V),G=Number.NEGATIVE_INFINITY,J=-1;for(let ee=N;ee<T;ee+=i){let W=ee-S;for(let X=M;X<F;X+=o){let Q=X-R;for(let ce=P;ce<A;ce+=u){let L=ce-V,q=e.get(v,ee,X,ce,x);q>=G&&(G=q,J=W*c*f+Q*c+L)}}}a.set(J,v,k,_,B,x)}}}return a}function cte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t;Be(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=n,d=1;C.assert(D.eitherStridesOrDilationsAreOne(i,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=D.computePool2DInfo(r.shape,s,i,d,o,u),f;if(c.filterWidth===1&&c.filterHeight===1&&C.arraysEqual(c.inShape,c.outShape))f=Vs({inputs:{x:r},backend:a});else{let m=a.data.get(r.dataId).values,g=C.computeStrides(r.shape),b=nI(m,r.shape,r.dtype,g,c,"avg");f=a.makeTensorInfo(c.outShape,r.dtype,b.values)}return f}var dte={kernelName:fu,backendName:"cpu",kernelFunc:cte};function hte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=n;Be(r,"avgPool3d");let c=D.computePool3DInfo(r.shape,s,i,1,o,u,d),f=a.data.get(r.dataId).values,m=nO(f,r.shape,r.dtype,C.computeStrides(r.shape),c,"avg");return a.makeTensorInfo(m.shape,"float32",m.values)}var pte={kernelName:Jd,backendName:"cpu",kernelFunc:hte};function fte(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=n;Be([r,s],"avgPool3DGrad");let c=D.computePool3DInfo(s.shape,i,o,1,u,d),f=c.strideDepth,m=c.strideHeight,g=c.strideWidth,b=c.filterDepth,v=c.filterHeight,x=c.filterWidth,k=c.dilationDepth,S=c.dilationHeight,N=c.dilationWidth,T=c.effectiveFilterDepth,_=c.effectiveFilterHeight,R=c.effectiveFilterWidth,M=T-1-c.padInfo.front,F=R-1-c.padInfo.left,B=_-1-c.padInfo.top,V=ct(s.shape,"float32"),P=1/(b*v*x),A=a.bufferSync(r);for(let G=0;G<c.batchSize;++G)for(let J=0;J<c.inChannels;++J)for(let ee=0;ee<c.inDepth;++ee)for(let W=0;W<c.inHeight;++W)for(let X=0;X<c.inWidth;++X){let Q=ee-M,ce=W-B,L=X-F,q=0;for(let le=0;le<T;le+=k){let se=(Q+le)/f;if(!(se<0||se>=c.outDepth||Math.floor(se)!==se))for(let pe=0;pe<_;pe+=S){let ve=(ce+pe)/m;if(!(ve<0||ve>=c.outHeight||Math.floor(ve)!==ve))for(let Ie=0;Ie<R;Ie+=N){let Re=(L+Ie)/g;if(Re<0||Re>=c.outWidth||Math.floor(Re)!==Re)continue;let Ne=A.get(G,se,ve,Re,J);q+=Ne}}}V.set(q*P,G,ee,W,X,J)}return a.makeTensorInfo(V.shape,V.dtype,V.values)}var mte={kernelName:dm,backendName:"cpu",kernelFunc:fte};function gte(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,i=s;Be([r,s],"avgPoolGrad");let{filterSize:o,strides:u,pad:d}=n,c=D.computePool2DInfo(i.shape,o,u,1,d),f=c.strideHeight,m=c.strideWidth,g=c.filterHeight,b=c.filterWidth,v=c.dilationHeight,x=c.dilationWidth,k=c.effectiveFilterHeight,S=c.effectiveFilterWidth,N=S-1-c.padInfo.left,T=k-1-c.padInfo.top,_=ct(i.shape,"float32"),R=1/(g*b),M=a.data.get(r.dataId).values,F=ct(r.shape,"float32",M);for(let B=0;B<c.batchSize;++B)for(let V=0;V<c.inChannels;++V)for(let P=0;P<c.inHeight;++P)for(let A=0;A<c.inWidth;++A){let G=P-T,J=A-N,ee=0;for(let W=0;W<k;W+=v){let X=(G+W)/f;if(!(X<0||X>=c.outHeight||Math.floor(X)!==X))for(let Q=0;Q<S;Q+=x){let ce=(J+Q)/m;if(ce<0||ce>=c.outWidth||Math.floor(ce)!==ce)continue;let L=F.get(B,X,ce,V);ee+=L}}_.set(ee*R,B,P,A,V)}return a.makeTensorInfo(_.shape,_.dtype,_.values)}var yte={kernelName:cm,backendName:"cpu",kernelFunc:gte};function bte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,scale:s,offset:i,mean:o,variance:u}=t;C.assert(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C.assert(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Be([r,o,u,s,i],"batchNorm");let{varianceEpsilon:d}=n;d==null&&(d=.001);let c=a.data.get(r.dataId).values,f=a.data.get(o.dataId).values,m=a.data.get(u.dataId).values,g=s?a.data.get(s.dataId).values:new Float32Array([1]),b=i?a.data.get(i.dataId).values:new Float32Array([0]),v=new Float32Array(c.length),x=b.length,k=g.length,S=m.length,N=f.length,T=0,_=0,R=0,M=0;for(let F=0;F<c.length;++F)v[F]=b[T++]+(c[F]-f[_++])*g[R++]/Math.sqrt(m[M++]+d),T>=x&&(T=0),_>=N&&(_=0),R>=k&&(R=0),M>=S&&(M=0);return a.makeTensorInfo(r.shape,r.dtype,v)}var vte={kernelName:Du,backendName:"cpu",kernelFunc:bte};function xte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{blockShape:s,crops:i}=n;Be([r],"batchToSpaceND");let o=s.reduce((k,S)=>k*S),u=D.getReshaped(r.shape,s,o),d=D.getPermuted(u.length,s.length),c=D.getReshapedPermuted(r.shape,s,o),f=D.getSliceBeginCoords(i,s.length),m=D.getSliceSize(c,i,s.length),g=aa({inputs:{x:r},backend:a,attrs:{shape:u}}),b=qn({inputs:{x:g},backend:a,attrs:{perm:d}}),v=aa({inputs:{x:b},backend:a,attrs:{shape:c}}),x=Jl({inputs:{x:v},backend:a,attrs:{begin:f,size:m}});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),x}var wte={kernelName:eh,backendName:"cpu",kernelFunc:xte};function kte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,weights:s}=t,{size:i}=n,o=a.data.get(r.dataId).values,u=a.data.get(s.dataId).values,d=q2(o,u,s.dtype,s.shape,i);return a.makeTensorInfo([i],s.dtype,d)}var Ste={kernelName:th,backendName:"cpu",kernelFunc:kte};function Ite(e){let{inputs:t,backend:a}=e,{s0:n,s1:r}=t,s=a.data.get(n.dataId).values,i=a.data.get(r.dataId).values,o=D.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return a.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Nte={kernelName:hm,backendName:"cpu",kernelFunc:Ite},Tte=Lt(zo,(e,t)=>{let a=t;return e>a.clipValueMax?a.clipValueMax:e<a.clipValueMin?a.clipValueMin:e}),_te={kernelName:zo,backendName:"cpu",kernelFunc:Tte},Cte=e=>{let{x:t}=e.inputs,a=e.backend,n=new Float32Array(C.sizeFromShape(t.shape)),r=a.data.get(t.dataId),s=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,o=a.data.get(s.dataId).values,u=a.data.get(i.dataId).values;for(let d=0;d<o.length;d++){let c=o[d],f=u[d];n[d]=Math.hypot(c,f)}return a.makeOutput(n,t.shape,"float32")},Ete={kernelName:pm,backendName:"cpu",kernelFunc:Cte};function Gd(e){let{inputs:t,backend:a}=e,{input:n}=t,r=a.data.get(n.dataId).complexTensorInfos.imag,s=a.data.get(r.dataId).values;return a.makeTensorInfo(r.shape,r.dtype,s)}var Ate={kernelName:Mb,backendName:"cpu",kernelFunc:Gd};function Hd(e){let{inputs:t,backend:a,attrs:n}=e,{axis:r}=n,s=C.parseAxisParam(r,t[0].shape)[0],i=t.map(v=>v.shape);D.assertParamsConsistent(i,s);let o=D.computeOutShape(t.map(v=>v.shape),s);if(C.sizeFromShape(o)===0)return a.makeTensorInfo(o,t[0].dtype,[]);let u=t.filter(v=>C.sizeFromShape(v.shape)>0);if(u.length===1)return Vs({inputs:{x:u[0]},backend:a});if(u[0].dtype==="complex64"){let v=u.map(T=>Ql({inputs:{input:T},backend:a})),x=u.map(T=>Gd({inputs:{input:T},backend:a})),k=Hd({inputs:v,backend:a,attrs:{axis:s}}),S=Hd({inputs:x,backend:a,attrs:{axis:s}}),N=rr({inputs:{real:k,imag:S},backend:a});return v.forEach(T=>a.disposeIntermediateTensorInfo(T)),x.forEach(T=>a.disposeIntermediateTensorInfo(T)),a.disposeIntermediateTensorInfo(k),a.disposeIntermediateTensorInfo(S),N}let d=u.map(v=>{let x=[-1,C.sizeFromShape(v.shape.slice(s))];return aa({inputs:{x:v},backend:a,attrs:{shape:x}})}),c=d.map(v=>({vals:a.data.get(v.dataId).values,shape:v.shape}));o=D.computeOutShape(d.map(v=>v.shape),1);let f=d[0].shape[0]===1,m=j2(c,o,t[0].dtype,f),g=D.computeOutShape(u.map(v=>v.shape),s),b=a.makeTensorInfo(g,t[0].dtype,m);return d.forEach(v=>a.disposeIntermediateTensorInfo(v)),b}var $te={kernelName:nh,backendName:"cpu",kernelFunc:Hd};function rO(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:u,dilations:d,dimRoundingMode:c}=n;Be([r,s],"conv2d");let f=D.convertConv2DDataFormat(u),m=D.computeConv2DInfo(r.shape,s.shape,i,d,o,c,!1,f),g=m.filterHeight,b=m.filterWidth,v=m.dilationHeight,x=m.dilationWidth,k=m.padInfo.left,S=m.padInfo.top,N=m.dataFormat==="channelsLast",T=new Aa(m.outShape,r.dtype),_=C.computeStrides(r.shape),R=C.computeStrides(s.shape),M=_[0],F=N?_[1]:_[2],B=N?_[2]:1,V=N?1:_[1],P=T.strides[0],A=N?T.strides[1]:T.strides[2],G=N?T.strides[2]:1,J=N?1:T.strides[1],ee=a.data.get(r.dataId).values,W=a.data.get(s.dataId).values,X=T.values;for(let Q=0;Q<m.batchSize;++Q){let ce=Q*M,L=Q*P;for(let q=0;q<m.outHeight;++q){let le=L+q*A,se=q*m.strideHeight-S;for(let pe=0;pe<g;++pe){let ve=se+pe*v;if(ve<0||ve>=m.inHeight)continue;let Ie=pe*R[0],Re=ce+ve*F;for(let Ne=0;Ne<m.outWidth;++Ne){let Le=le+Ne*G,je=Ne*m.strideWidth-k;for(let Je=0;Je<b;++Je){let st=je+Je*x;if(st<0||st>=m.inWidth)continue;let At=Ie+Je*R[1],pt=Re+st*B,xt=At;for(let tt=0;tt<m.inChannels;++tt){let ot=ee[pt+tt*V];for(let Bt=0;Bt<m.outChannels;++Bt)X[Le+Bt*J]+=ot*W[xt+Bt];xt+=m.outChannels}}}}}}return a.makeTensorInfo(T.shape,T.dtype,X)}var Rte={kernelName:bu,backendName:"cpu",kernelFunc:rO};function Dte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:d,filterShape:c}=n;Be([r,s],"conv2dBackpropFilter");let f=D.convertConv2DDataFormat(u),m=D.computeConv2DInfo(r.shape,c,i,1,o,d,!1,f),{strideHeight:g,strideWidth:b,filterHeight:v,filterWidth:x}=m,k=m.dataFormat==="channelsLast",S=new Aa(m.filterShape,"float32"),N=m.padInfo.left,T=m.padInfo.top,_=a.data.get(r.dataId).values,R=a.data.get(s.dataId).values,M=new Aa(r.shape,r.dtype,_),F=new Aa(s.shape,s.dtype,R);for(let B=0;B<v;++B){let V=Math.max(0,Math.ceil((T-B)/g)),P=Math.min(m.outHeight,(m.inHeight+T-B)/g);for(let A=0;A<x;++A){let G=Math.max(0,Math.ceil((N-A)/b)),J=Math.min(m.outWidth,(m.inWidth+N-A)/b);for(let ee=0;ee<m.inChannels;++ee)for(let W=0;W<m.outChannels;++W){let X=0;for(let Q=0;Q<m.batchSize;++Q)for(let ce=V;ce<P;++ce){let L=B+ce*g-T;for(let q=G;q<J;++q){let le=A+q*b-N;k?X+=M.get(Q,L,le,ee)*F.get(Q,ce,q,W):X+=M.get(Q,ee,L,le)*F.get(Q,W,ce,q)}}S.set(X,B,A,ee,W)}}}return a.makeTensorInfo(S.shape,S.dtype,S.values)}var Mte={kernelName:_b,backendName:"cpu",kernelFunc:Dte};function Fte(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:u,dataFormat:d,dimRoundingMode:c}=n;Be([r,s],"conv2dBackpropInput");let f=C.computeStrides(s.shape),m=C.computeStrides(r.shape),g=D.convertConv2DDataFormat(d),b=D.computeConv2DInfo(i,s.shape,o,1,u,c,!1,g),v=new Aa(b.inShape,"float32"),x=v.values,k=a.data.get(r.dataId).values,S=a.data.get(s.dataId).values,[N,T,_]=f,{batchSize:R,filterHeight:M,filterWidth:F,inChannels:B,inHeight:V,inWidth:P,outChannels:A,outHeight:G,outWidth:J,strideHeight:ee,strideWidth:W}=b;g=b.dataFormat;let X=M-1-b.padInfo.top,Q=F-1-b.padInfo.left,ce=g==="channelsLast",L=v.strides[0],q=ce?v.strides[1]:v.strides[2],le=ce?v.strides[2]:1,se=ce?1:v.strides[1],pe=m[0],ve=ce?m[1]:m[2],Ie=ce?m[2]:1,Re=ce?1:m[1];for(let Ne=0;Ne<R;++Ne)for(let Le=0;Le<B;++Le)for(let je=0;je<V;++je){let Je=je-X,st=Math.max(0,Math.ceil(Je/ee)),At=Math.min(G,(M+Je)/ee);for(let pt=0;pt<P;++pt){let xt=pt-Q,tt=Math.max(0,Math.ceil(xt/W)),ot=Math.min(J,(F+xt)/W),Bt=0;for(let na=st;na<At;++na){let Fa=na*ee-Je;for(let Oa=tt;Oa<ot;++Oa){let nn=Oa*W-xt,Kn=pe*Ne+ve*na+Ie*Oa,wn=N*(M-1-Fa)+T*(F-1-nn)+_*Le;for(let Na=0;Na<A;++Na){let $t=k[Kn+Re*Na],ba=S[wn+Na];Bt+=$t*ba}}}let pn=L*Ne+q*je+le*pt+se*Le;x[pn]=Bt}}return a.makeTensorInfo(v.shape,v.dtype,v.values)}var Ote={kernelName:vu,backendName:"cpu",kernelFunc:Fte};function zte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=n;Be([r,s],"conv3d");let d=D.computeConv3DInfo(r.shape,s.shape,i,u,o),{filterDepth:c,filterHeight:f,filterWidth:m,dilationDepth:g,dilationHeight:b,dilationWidth:v,padInfo:x}=d,k=x.front,S=x.left,N=x.top,T=new Aa(d.outShape,r.dtype),_=a.data.get(r.dataId).values,R=a.data.get(s.dataId).values,M=T.values,F=C.computeStrides(r.shape),B=C.computeStrides(s.shape);for(let V=0;V<d.batchSize;++V){let P=V*F[0],A=V*T.strides[0];for(let G=0;G<d.outDepth;++G){let J=A+G*T.strides[1],ee=G*d.strideDepth-k;for(let W=0;W<c;++W){let X=ee+W*g;if(X<0||X>=d.inDepth)continue;let Q=W*B[0],ce=P+X*F[1];for(let L=0;L<d.outHeight;++L){let q=J+L*T.strides[2],le=L*d.strideHeight-N;for(let se=0;se<f;++se){let pe=le+se*b;if(pe<0||pe>=d.inHeight)continue;let ve=Q+se*B[1],Ie=ce+pe*F[2];for(let Re=0;Re<d.outWidth;++Re){let Ne=q+Re*d.outChannels,Le=Re*d.strideWidth-S;for(let je=0;je<m;++je){let Je=Le+je*v;if(Je<0||Je>=d.inWidth)continue;let st=ve+je*B[2],At=Ie+Je*d.inChannels,pt=st;for(let xt=0;xt<d.inChannels;++xt){let tt=_[At+xt];for(let ot=0;ot<d.outChannels;++ot)M[Ne+ot]+=tt*R[pt+ot];pt+=d.outChannels}}}}}}}}return a.makeTensorInfo(T.shape,T.dtype,T.values)}var Lte={kernelName:xu,backendName:"cpu",kernelFunc:zte};function Bte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:u}=n;Be([r,s],"conv3dBackpropFilterV2");let d=C.computeStrides(r.shape),c=C.computeStrides(s.shape),f=D.computeConv3DInfo(r.shape,u,i,1,o),m=f.strideDepth,g=f.strideHeight,b=f.strideWidth,v=f.filterDepth,x=f.filterHeight,k=f.filterWidth,S=new Aa(f.filterShape,"float32"),N=S.values,[T,_,R,M]=S.strides,F=a.data.get(s.dataId).values,[B,V,P,A]=c,G=a.data.get(r.dataId).values,[J,ee,W,X]=d,Q=f.padInfo.front,ce=f.padInfo.left,L=f.padInfo.top;for(let q=0;q<v;++q){let le=Math.max(0,Math.ceil((Q-q)/m)),se=Math.min(f.outDepth,(f.inDepth+Q-q)/m),pe=q*T;for(let ve=0;ve<x;++ve){let Ie=Math.max(0,Math.ceil((L-ve)/g)),Re=Math.min(f.outHeight,(f.inHeight+L-ve)/g),Ne=ve*_+pe;for(let Le=0;Le<k;++Le){let je=Math.max(0,Math.ceil((ce-Le)/b)),Je=Math.min(f.outWidth,(f.inWidth+ce-Le)/b),st=Le*R+Ne;for(let At=0;At<f.inChannels;++At){let pt=At*M+st;for(let xt=0;xt<f.outChannels;++xt){let tt=0;for(let ot=0;ot<f.batchSize;++ot){let Bt=ot*J,pn=ot*B;for(let na=le;na<se;++na){let Fa=(q+na*m-Q)*ee+Bt,Oa=na*V+pn;for(let nn=Ie;nn<Re;++nn){let Kn=(ve+nn*g-L)*W+Fa,wn=nn*P+Oa;for(let Na=je;Na<Je;++Na){let $t=(Le+Na*b-ce)*X+Kn,ba=Na*A+wn;tt+=G[$t+At]*F[ba+xt]}}}}N[pt+xt]=tt}}}}}return a.makeTensorInfo(S.shape,S.dtype,S.values)}var Ute={kernelName:rh,backendName:"cpu",kernelFunc:Bte};function Pte(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:u}=n;Be([r],"conv3dBackpropInputV2");let d=C.computeStrides(r.shape),c=C.computeStrides(s.shape),f=D.computeConv3DInfo(u,s.shape,o,1,i),m=new Aa(f.inShape,"float32"),g=m.values,[b,v,x,k]=m.strides,S=a.data.get(r.dataId).values,[N,T,_,R]=d,M=a.data.get(s.dataId).values,[F,B,V,P]=c,{batchSize:A,filterDepth:G,filterHeight:J,filterWidth:ee,inChannels:W,inDepth:X,inHeight:Q,inWidth:ce,outChannels:L,outDepth:q,outHeight:le,outWidth:se,strideDepth:pe,strideHeight:ve,strideWidth:Ie}=f,Re=G-1-f.padInfo.front,Ne=J-1-f.padInfo.top,Le=ee-1-f.padInfo.left;for(let je=0;je<A;++je)for(let Je=0;Je<W;++Je)for(let st=0;st<X;++st){let At=st-Re,pt=Math.max(0,Math.ceil(At/pe)),xt=Math.min(q,(G+At)/pe);for(let tt=0;tt<Q;++tt){let ot=tt-Ne,Bt=Math.max(0,Math.ceil(ot/ve)),pn=Math.min(le,(J+ot)/ve);for(let na=0;na<ce;++na){let Fa=na-Le,Oa=Math.max(0,Math.ceil(Fa/Ie)),nn=Math.min(se,(ee+Fa)/Ie),Kn=0;for(let wn=pt;wn<xt;++wn){let Na=wn*pe-At;for(let $t=Bt;$t<pn;++$t){let ba=$t*ve-ot;for(let va=Oa;va<nn;++va){let Qo=va*Ie-Fa,Xr=N*je+T*wn+_*$t+R*va,Jo=F*(G-1-Na)+B*(J-1-ba)+V*(ee-1-Qo)+P*Je;for(let Fn=0;Fn<L;++Fn){let hr=S[Xr+Fn],ra=M[Jo+Fn];Kn+=hr*ra}}}}g[b*je+v*st+x*tt+k*na+Je]=Kn}}}return a.makeTensorInfo(m.shape,m.dtype,m.values)}var Wte={kernelName:sh,backendName:"cpu",kernelFunc:Pte},Vte=Lt(wu,e=>Math.cos(e)),Gte={kernelName:wu,backendName:"cpu",kernelFunc:Vte},Hte=Lt(ku,e=>Math.cosh(e)),qte={kernelName:ku,backendName:"cpu",kernelFunc:Hte};function jte(e){let{inputs:t,backend:a,attrs:n}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:d}=n,[c,f,m,g]=r.shape,b=s.shape[0],[v,x]=o,k=ct([b,v,x,g],"float32"),S=a.data.get(s.dataId).values,N=a.data.get(i.dataId).values,T=a.data.get(r.dataId).values,_=C.computeStrides(r.shape),R=C.computeStrides(k.shape);for(let M=0;M<b;M++){let F=M*4,B=S[F],V=S[F+1],P=S[F+2],A=S[F+3],G=N[M];if(G>=c)continue;let J=v>1?(P-B)*(f-1)/(v-1):0,ee=x>1?(A-V)*(m-1)/(x-1):0;for(let W=0;W<v;W++){let X=v>1?B*(f-1)+W*J:.5*(B+P)*(f-1);if(X<0||X>f-1){for(let Q=0;Q<x;Q++)for(let ce=0;ce<g;ce++){let L=ce+Q*R[2]+W*R[1]+M*R[0];k.values[L]=d}continue}if(u==="bilinear"){let Q=Math.floor(X),ce=Math.ceil(X),L=X-Q;for(let q=0;q<x;q++){let le=x>1?V*(m-1)+q*ee:.5*(V+A)*(m-1);if(le<0||le>m-1){for(let Ie=0;Ie<g;Ie++){let Re=Ie+q*R[2]+W*R[1]+M*R[0];k.values[Re]=d}continue}let se=Math.floor(le),pe=Math.ceil(le),ve=le-se;for(let Ie=0;Ie<g;Ie++){let Re=Ie+se*_[2]+Q*_[1]+G*_[0],Ne=T[Re];Re=Ie+pe*_[2]+Q*_[1]+G*_[0];let Le=T[Re];Re=Ie+se*_[2]+ce*_[1]+G*_[0];let je=T[Re];Re=Ie+pe*_[2]+ce*_[1]+G*_[0];let Je=T[Re],st=Ne+(Le-Ne)*ve,At=je+(Je-je)*ve;Re=Ie+q*R[2]+W*R[1]+M*R[0],k.values[Re]=st+(At-st)*L}}}else for(let Q=0;Q<x;++Q){let ce=x>1?V*(m-1)+Q*ee:.5*(V+A)*(m-1);if(ce<0||ce>m-1){for(let le=0;le<g;le++){let se=le+Q*R[2]+W*R[1]+M*R[0];k.values[se]=d}continue}let L=Math.round(ce),q=Math.round(X);for(let le=0;le<g;le++){let se=le+L*_[2]+q*_[1]+G*_[0],pe=le+Q*R[2]+W*R[1]+M*R[0];k.values[pe]=T[se]}}}}return a.makeTensorInfo(k.shape,k.dtype,k.values)}var Kte={kernelName:oh,backendName:"cpu",kernelFunc:jte};function Xte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=n;Be(r,"cumprod");let u=D.getAxesPermutation([s],r.shape.length),d=r;u!=null&&(d=qn({inputs:{x:r},backend:a,attrs:{perm:u}}));let c=D.getInnerMostAxes(1,r.shape.length)[0];if(c!==d.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${c}`);let f=Nr(d.dtype,"int32"),m=C.makeOnesTypedArray(C.sizeFromShape(d.shape),f),g=a.data.get(d.dataId).values,b=d.shape[d.shape.length-1],v=o?(k,S)=>k+b-S-1:(k,S)=>k+S;for(let k=0;k<g.length;k+=b)for(let S=0;S<b;S++){let N=v(k,S);if(S===0)m[N]=i?1:g[N];else{let T=v(k,S-1);m[N]=i?g[T]*m[T]:g[N]*m[T]}}let x=a.makeTensorInfo(d.shape,f,m);if(u!=null){let k=D.getUndoAxesPermutation(u),S=qn({inputs:{x},backend:a,attrs:{perm:k}});return a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(d),S}return x}var Yte={kernelName:ih,backendName:"cpu",kernelFunc:Xte};function Zte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=n;Be(r,"cumsum");let u=D.getAxesPermutation([s],r.shape.length),d=r;u!=null&&(d=qn({inputs:{x:r},backend:a,attrs:{perm:u}}));let c=D.getInnerMostAxes(1,r.shape.length)[0];if(c!==d.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${d.shape.length-1} but got axis=${c}`);let f=Nr(d.dtype,"int32"),m=C.makeZerosTypedArray(C.sizeFromShape(d.shape),f),g=a.data.get(d.dataId).values,b=d.shape[d.shape.length-1],v=o?(k,S)=>k+b-S-1:(k,S)=>k+S;for(let k=0;k<g.length;k+=b)for(let S=0;S<b;S++){let N=v(k,S);if(S===0)m[N]=i?0:g[N];else{let T=v(k,S-1);m[N]=i?g[T]+m[T]:g[N]+m[T]}}let x=a.makeTensorInfo(d.shape,f,m);if(u!=null){let k=D.getUndoAxesPermutation(u),S=qn({inputs:{x},backend:a,attrs:{perm:k}});return a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(d),S}return x}var Qte={kernelName:Su,backendName:"cpu",kernelFunc:Zte};function Jte(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=n;if(r.shape.length===1){let u=a.data.get(r.dataId).values,d=a.data.get(s.dataId).values,c=q2(u,d,s.dtype,s.shape,i);return a.makeTensorInfo([i],s.dtype,c)}else if(r.shape.length===2){let u=a.bufferSync(r),d=a.bufferSync(s),c=hF(u,d,i,o);return a.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var eae={kernelName:fm,backendName:"cpu",kernelFunc:Jte};function tae(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{blockSize:s,dataFormat:i}=n;C.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=r.shape[0],u=r.shape[1],d=r.shape[2],c=r.shape[3],f=u*s,m=d*s,g=c/(s*s),b=a.data.get(r.dataId).values,v=new Float32Array(o*f*m*g),x=0;for(let k=0;k<o;++k)for(let S=0;S<f;++S){let N=Math.floor(S/s),T=S%s;for(let _=0;_<m;++_){let R=Math.floor(_/s),M=_%s,F=(T*s+M)*g;for(let B=0;B<g;++B){let V=B+F+c*(R+d*(N+u*k));v[x++]=b[V]}}}return a.makeTensorInfo([o,f,m,g],r.dtype,v)}var aae={kernelName:lh,backendName:"cpu",kernelFunc:tae};function sO(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:d}=n;Be([r,s],"depthwiseConv2DNative");let c=C.computeStrides(r.shape),f=C.computeStrides(s.shape),m=u;m==null&&(m=[1,1]),C.assert(D.eitherStridesOrDilationsAreOne(i,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);let g=D.computeConv2DInfo(r.shape,s.shape,i,m,o,d,!0),{filterHeight:b,filterWidth:v,dilationHeight:x,dilationWidth:k,padInfo:S}=g,N=S.left,T=S.top,_=g.outChannels/g.inChannels,R=new Aa(g.outShape,r.dtype),M=a.data.get(r.dataId).values,F=a.data.get(s.dataId).values,B=R.values;for(let V=0;V<g.batchSize;++V){let P=V*c[0],A=V*R.strides[0];for(let G=0;G<g.outHeight;++G){let J=A+G*R.strides[1],ee=G*g.strideHeight-T;for(let W=0;W<b;++W){let X=ee+W*x;if(X<0||X>=g.inHeight)continue;let Q=W*f[0],ce=P+X*c[1];for(let L=0;L<g.outWidth;++L){let q=J+L*R.strides[2],le=L*g.strideWidth-N;for(let se=0;se<v;++se){let pe=le+se*k;if(pe<0||pe>=g.inWidth)continue;let ve=Q+se*f[1],Ie=ce+pe*g.inChannels,Re=q,Ne=ve;for(let Le=0;Le<g.inChannels;++Le){let je=M[Ie+Le];for(let Je=0;Je<_;++Je)B[Re+Je]+=je*F[Ne+Je];Re+=_,Ne+=_}}}}}}return a.makeTensorInfo(R.shape,R.dtype,R.values)}var nae={kernelName:Iu,backendName:"cpu",kernelFunc:sO};function rae(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:d,filterShape:c}=n;Be([r,s],"depthwiseConv2dNativeBackpropFilter");let f=D.computeConv2DInfo(r.shape,c,i,o,u,d,!0),{strideHeight:m,strideWidth:g,filterHeight:b,filterWidth:v}=f,x=new Aa(f.filterShape,"float32"),k=f.padInfo.left,S=f.padInfo.top,N=f.outChannels/f.inChannels,T=a.data.get(r.dataId).values,_=new Aa(r.shape,r.dtype,T),R=a.data.get(s.dataId).values,M=new Aa(s.shape,s.dtype,R);for(let F=0;F<b;++F){let B=Math.max(0,Math.ceil((S-F)/m)),V=Math.min(f.outHeight,(f.inHeight+S-F)/m);for(let P=0;P<v;++P){let A=Math.max(0,Math.ceil((k-P)/g)),G=Math.min(f.outWidth,(f.inWidth+k-P)/g);for(let J=0;J<f.outChannels;++J){let ee=Math.trunc(J/N),W=J%N,X=0;for(let Q=0;Q<f.batchSize;++Q)for(let ce=B;ce<V;++ce){let L=F+ce*m-S;for(let q=A;q<G;++q){let le=P+q*g-k;X+=_.get(Q,L,le,ee)*M.get(Q,ce,q,J)}}x.set(X,F,P,ee,W)}}}return a.makeTensorInfo(x.shape,x.dtype,x.values)}var sae={kernelName:Cb,backendName:"cpu",kernelFunc:rae};function iae(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:d,inputShape:c}=n;Be([r,s],"depthwiseConv2DNativeBackpropInput");let f=C.computeStrides(r.shape),m=C.computeStrides(s.shape),g=D.computeConv2DInfo(c,s.shape,i,o,u,d,!0),b=new Aa(g.inShape,"float32"),v=b.values,[x,k,S]=b.strides,N=a.data.get(r.dataId).values,[T,_,R]=f,M=a.data.get(s.dataId).values,[F,B,V]=m,{batchSize:P,filterHeight:A,filterWidth:G,inChannels:J,inHeight:ee,inWidth:W,outChannels:X,outHeight:Q,outWidth:ce,strideHeight:L,strideWidth:q}=g,le=A-1-g.padInfo.top,se=G-1-g.padInfo.left,pe=X/J;for(let ve=0;ve<P;++ve)for(let Ie=0;Ie<J;++Ie)for(let Re=0;Re<ee;++Re){let Ne=Re-le,Le=Math.max(0,Math.ceil(Ne/L)),je=Math.min(Q,(A+Ne)/L);for(let Je=0;Je<W;++Je){let st=Je-se,At=Math.max(0,Math.ceil(st/q)),pt=Math.min(ce,(G+st)/q),xt=0;for(let tt=Le;tt<je;++tt){let ot=tt*L-Ne;for(let Bt=At;Bt<pt;++Bt){let pn=Bt*q-st,na=T*ve+_*tt+R*Bt,Fa=F*(A-1-ot)+B*(G-1-pn)+V*Ie;for(let Oa=0;Oa<pe;++Oa){let nn=Ie*pe+Oa,Kn=N[na+nn],wn=M[Fa+Oa];xt+=Kn*wn}}}v[x*ve+k*Re+S*Je+Ie]=xt}}return a.makeTensorInfo(b.shape,b.dtype,b.values)}var oae={kernelName:Eb,backendName:"cpu",kernelFunc:iae};function lae(e){let{inputs:t,backend:a}=e,{x:n}=t,r=C.sizeFromShape(n.shape),s=a.data.get(n.dataId).values,i=ct([r,r],n.dtype),o=i.values;for(let d=0;d<s.length;d++)o[d*r+d]=s[d];let u=[...n.shape,...n.shape];return a.makeTensorInfo(u,i.dtype,i.values)}var uae={kernelName:mm,backendName:"cpu",kernelFunc:lae},cae={kernelName:Nu,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:a})=>{let{x:n,filter:r}=e,{strides:s,pad:i,dilations:o}=a,u=t,d=u.data.get(n.dataId).values,c=n.shape.length,f=u.data.get(r.dataId).values,m=r.shape.length,{batchSize:g,inHeight:b,inWidth:v,inChannels:x,outHeight:k,outWidth:S,padInfo:N,strideHeight:T,strideWidth:_,filterHeight:R,filterWidth:M,dilationHeight:F,dilationWidth:B,outShape:V}=D.computeDilation2DInfo(n.shape,r.shape,s,i,"NHWC",o),P=C.sizeFromShape(V),A=V.length,G=C.getArrayFromDType(n.dtype,P);for(let J=0;J<g;++J)for(let ee=0;ee<k;++ee){let W=ee*T-N.top;for(let X=0;X<S;++X){let Q=X*_-N.left;for(let ce=0;ce<x;++ce){let L=Number.MIN_SAFE_INTEGER;for(let le=0;le<R;++le){let se=W+le*F;if(se>=0&&se<b)for(let pe=0;pe<M;++pe){let ve=Q+pe*B;if(ve>=0&&ve<v){let Ie=C.locToIndex([J,se,ve,ce],c,C.computeStrides(n.shape)),Re=C.locToIndex([le,pe,ce],m,C.computeStrides(r.shape)),Ne=d[Ie]+f[Re];Ne>L&&(L=Ne)}}}let q=C.locToIndex([J,ee,X,ce],A,C.computeStrides(V));G[q]=L}}}return{dataId:u.write(C.toTypedArray(G,n.dtype),V,n.dtype),shape:V,dtype:n.dtype}}},dae={kernelName:$d,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:a})=>{let{x:n,filter:r,dy:s}=e,{strides:i,pad:o,dilations:u}=a,d=t,c=C.toNestedArray(n.shape,d.data.get(n.dataId).values),f=C.toNestedArray(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:b,inChannels:v,outHeight:x,outWidth:k,padInfo:S,strideHeight:N,strideWidth:T,filterHeight:_,filterWidth:R,dilationHeight:M,dilationWidth:F,outShape:B}=D.computeDilation2DInfo(n.shape,r.shape,i,o,"NHWC",u);C.assert(s.rank===B.length,()=>`Error in ${$d}, dy must have the same rank as output ${B.length}, but got ${s.rank}`);let V=C.toNestedArray(B,d.data.get(s.dataId).values),P=C.makeZerosNestedTypedArray(r.shape,r.dtype);for(let A=0;A<m;++A)for(let G=0;G<x;++G){let J=G*N-S.top;for(let ee=0;ee<k;++ee){let W=ee*T-S.left;for(let X=0;X<v;++X){let Q=Number.MIN_SAFE_INTEGER,ce=0,L=0;for(let q=0;q<_;++q){let le=J+q*M;if(le>=0&&le<g)for(let se=0;se<R;++se){let pe=W+se*F;if(pe>=0&&pe<b){let ve=c[A][le][pe][X]+f[q][se][X];ve>Q&&(Q=ve,ce=q,L=se)}}}P[ce][L][X]+=V[A][G][ee][X]}}}return{dataId:d.write(C.toTypedArray(P,n.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},hae={kernelName:Ad,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:a})=>{let{x:n,filter:r,dy:s}=e,{strides:i,pad:o,dilations:u}=a,d=t,c=C.toNestedArray(n.shape,d.data.get(n.dataId).values),f=C.toNestedArray(r.shape,d.data.get(r.dataId).values),{batchSize:m,inHeight:g,inWidth:b,inChannels:v,outHeight:x,outWidth:k,padInfo:S,strideHeight:N,strideWidth:T,filterHeight:_,filterWidth:R,dilationHeight:M,dilationWidth:F,outShape:B}=D.computeDilation2DInfo(n.shape,r.shape,i,o,"NHWC",u);C.assert(s.rank===B.length,()=>`Error in ${Ad}, dy must have the same rank as output ${B.length}, but got ${s.rank}`);let V=C.toNestedArray(B,d.data.get(s.dataId).values),P=C.makeZerosNestedTypedArray(n.shape,n.dtype);for(let A=0;A<m;++A)for(let G=0;G<x;++G){let J=G*N-S.top;for(let ee=0;ee<k;++ee){let W=ee*T-S.left;for(let X=0;X<v;++X){let Q=Number.MIN_SAFE_INTEGER,ce=J<0?0:J,L=W<0?0:W;for(let q=0;q<_;++q){let le=J+q*M;if(le>=0&&le<g)for(let se=0;se<R;++se){let pe=W+se*F;if(pe>=0&&pe<b){let ve=c[A][le][pe][X]+f[q][se][X];ve>Q&&(Q=ve,ce=le,L=pe)}}}P[A][ce][L][X]+=V[A][G][ee][X]}}}return{dataId:d.write(C.toTypedArray(P,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function pae(e){let{inputs:t,backend:a,attrs:n}=e,{image:r}=t,{canvas:s,options:i}=n,{contextOptions:o,imageOptions:u}=i||{},d=(u==null?void 0:u.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let f=s.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(f==null)throw new Error(`Could not get the context with ${c} type.`);let[m,g]=r.shape.slice(0,2),b=r.shape.length===2?1:r.shape[2],v=a.data.get(r.dataId).values,x=r.dtype==="float32"?255:1,k=new Uint8ClampedArray(g*m*4);for(let N=0;N<m*g;++N){let T=[0,0,0,255*d];for(let R=0;R<b;R++){let M=v[N*b+R];if(r.dtype==="float32"){if(M<0||M>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${M}.`)}else if(r.dtype==="int32"&&(M<0||M>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${M}.`);b===1?(T[0]=M*x,T[1]=M*x,T[2]=M*x):T[R]=M*x}let _=N*4;k[_+0]=Math.round(T[0]),k[_+1]=Math.round(T[1]),k[_+2]=Math.round(T[2]),k[_+3]=Math.round(T[3])}s.width=g,s.height=m;let S=new ImageData(k,g,m);return f.putImageData(S,0,0),r}var fae={kernelName:Ab,backendName:"cpu",kernelFunc:pae};function sg(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n;Be(r,"sum");let o;r.dtype==="bool"?o=Ro({inputs:{x:r},backend:a,attrs:{dtype:"int32"}}):o=Vs({inputs:{x:r},backend:a});let u=o.shape.length,d=C.parseAxisParam(s,o.shape),c=D.getAxesPermutation(d,u),f=d,m=o;c!=null&&(m=qn({inputs:{x:o},backend:a,attrs:{perm:c}}),f=D.getInnerMostAxes(f.length,u)),D.assertAxesAreInnerMostDims("sum",f,m.shape.length);let[g,b]=D.computeOutAndReduceShapes(m.shape,f),v=D.upcastType(m.dtype,"int32"),x=db(a,g,v),k=C.sizeFromShape(b),S=a.data.get(x.dataId).values,N=a.data.get(m.dataId).values;for(let T=0;T<S.length;++T){let _=T*k,R=0;for(let M=0;M<k;++M)R+=N[_+M];S[T]=R}if(i){let T=D.expandShapeToKeepDim(x.shape,d),_=x;x=aa({inputs:{x},backend:a,attrs:{shape:T}}),a.disposeIntermediateTensorInfo(_)}return a.disposeIntermediateTensorInfo(o),c!=null&&a.disposeIntermediateTensorInfo(m),x}var mae={kernelName:bc,backendName:"cpu",kernelFunc:sg};function gae(e){let{inputs:t,backend:a,attrs:n}=e,{equation:r}=n,s=t,{allDims:i,summedDims:o,idDims:u}=D.decodeEinsumEquation(r,s.length);D.checkEinsumDimSizes(i.length,u,s);let{path:d,steps:c}=D.getEinsumComputePath(o,u),f=c.length,m=null,g=i.length,b=[];for(let v=0;v<f;++v){for(let x of c[v]){let{permutationIndices:k,expandDims:S}=D.getEinsumPermutation(g,u[x]),N;D.isIdentityPermutation(k)?N=s[x]:(N=qn({inputs:{x:s[x]},backend:a,attrs:{perm:k}}),b.push(N));let T=N.shape.slice();for(let _=0;_<S.length;++_)T.splice(S[_],0,1);C.arraysEqual(N.shape,T)||(N=aa({inputs:{x:N},backend:a,attrs:{shape:T}}),b.push(N)),m===null?m=N:(m=Gv({inputs:{a:N,b:m},backend:a}),b.push(m))}v<f-1&&(d[v]>=0&&(m=sg({inputs:{x:m},backend:a,attrs:{axis:d[v]-(i.length-g),keepDims:!1}}),b.push(m)),g--)}for(let v of b)v!==m&&a.disposeIntermediateTensorInfo(v);return m}var yae={kernelName:$b,backendName:"cpu",kernelFunc:gae};function bae(e){let{inputs:t,backend:a}=e,{dy:n,y:r}=t;Be([n,r],"eluGrad");let s=new Float32Array(C.sizeFromShape(r.shape)),i=a.data.get(r.dataId).values,o=a.data.get(n.dataId).values;for(let u=0;u<i.length;++u){let d=i[u];d>=0?s[u]=o[u]:s[u]=o[u]*(d+1)}return a.makeTensorInfo(r.shape,"float32",s)}var vae={kernelName:uh,backendName:"cpu",kernelFunc:bae},xae=D.ERF_P,wae=D.ERF_A1,kae=D.ERF_A2,Sae=D.ERF_A3,Iae=D.ERF_A4,Nae=D.ERF_A5,Tae=Lt(Cu,e=>{let t=Math.sign(e),a=Math.abs(e),n=1/(1+xae*a);return t*(1-((((Nae*n+Iae)*n+Sae)*n+kae)*n+wae)*n*Math.exp(-a*a))}),_ae={kernelName:Cu,backendName:"cpu",kernelFunc:Tae};function fb(e){let{inputs:t,backend:a,attrs:n}=e,{input:r}=t,{dim:s}=n,i=r.shape.length,o=r.shape.slice(),u=s;return s<0&&(C.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),o.splice(u,0,1),aa({inputs:{x:r},backend:a,attrs:{shape:o}})}var Cae={kernelName:dh,backendName:"cpu",kernelFunc:fb},Eae=Ia((e,t)=>e/t),rI=Ga(Tu,Eae),d1={kernelName:Tu,backendName:"cpu",kernelFunc:rI};function iO(e,t,a){let n=e.shape,r=n[0],s=n[1],i=a.data.get(e.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,d=[r,s],c=C.sizeFromShape(d),f=C.getTypedArrayFromDType("float32",c),m=C.getTypedArrayFromDType("float32",c);for(let x=0;x<r;x++){let k=Jl({inputs:{x:o},backend:a,attrs:{begin:[x,0],size:[1,s]}}),S=Jl({inputs:{x:u},backend:a,attrs:{begin:[x,0],size:[1,s]}}),N=rr({inputs:{real:k,imag:S},backend:a}),{real:T,imag:_}=Aae(N,t,a),R=D.mergeRealAndImagArrays(T,_);for(let M=0;M<s;M++){let F=D.getComplexWithIndex(R,M);f[x*s+M]=F.real,m[x*s+M]=F.imag}a.disposeIntermediateTensorInfo(k),a.disposeIntermediateTensorInfo(S),a.disposeIntermediateTensorInfo(N)}let g=a.makeTensorInfo(d,"float32",f),b=a.makeTensorInfo(d,"float32",m),v=rr({inputs:{real:g,imag:b},backend:a});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),v}function Aae(e,t,a){let n=C.sizeFromShape(e.shape),r=a.data.get(e.dataId),s=a.data.get(r.complexTensorInfos.real.dataId).values,i=a.data.get(r.complexTensorInfos.imag.dataId).values;if($ae(n)){let o=h1(s,i,n,t,a),u=[e.shape[0],e.shape[1]];if(t){let d=a.makeTensorInfo(u,"float32",o.real),c=a.makeTensorInfo(u,"float32",o.imag),f=a.makeTensorInfo([],"float32",C.createScalarValue(n,"float32")),m=Vs({inputs:{x:f},backend:a}),g=d1.kernelFunc({inputs:{a:d,b:f},backend:a}),b=d1.kernelFunc({inputs:{a:c,b:m},backend:a}),v=a.data.get(g.dataId).values,x=a.data.get(b.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),{real:v,imag:x}}return o}else{let o=D.mergeRealAndImagArrays(s,i),u=Rae(o,n,t);return D.splitRealAndImagArrays(u)}}function $ae(e){return(e&e-1)===0}function h1(e,t,a,n,r){if(a===1)return{real:e,imag:t};let s=D.mergeRealAndImagArrays(e,t),i=a/2,o=D.complexWithEvenIndex(s),u=o.real,d=o.imag,c=[u.length],f=r.makeTensorInfo(c,"float32",u),m=r.makeTensorInfo(c,"float32",d),g=rr({inputs:{real:f,imag:m},backend:r}),b=D.complexWithOddIndex(s),v=b.real,x=b.imag,k=[v.length],S=r.makeTensorInfo(k,"float32",v),N=r.makeTensorInfo(k,"float32",x),T=rr({inputs:{real:S,imag:N},backend:r}),_=h1(u,d,i,n,r),R=_.real,M=_.imag,F=[R.length],B=r.makeTensorInfo(F,"float32",R),V=r.makeTensorInfo(F,"float32",M),P=rr({inputs:{real:B,imag:V},backend:r}),A=h1(v,x,i,n,r),G=A.real,J=A.imag,ee=[G.length],W=r.makeTensorInfo(ee,"float32",G),X=r.makeTensorInfo(ee,"float32",J),Q=rr({inputs:{real:W,imag:X},backend:r}),ce=D.exponents(a,n),L=[ce.real.length],q=r.makeTensorInfo(L,"float32",ce.real),le=r.makeTensorInfo(L,"float32",ce.imag),se=rr({inputs:{real:q,imag:le},backend:r}),pe=Gv({inputs:{a:se,b:Q},backend:r}),ve=Vd({inputs:{a:P,b:pe},backend:r}),Ie=tI({inputs:{a:P,b:pe},backend:r}),Re=Ql({inputs:{input:ve},backend:r}),Ne=Ql({inputs:{input:Ie},backend:r}),Le=Gd({inputs:{input:ve},backend:r}),je=Gd({inputs:{input:Ie},backend:r}),Je=Hd({inputs:[Re,Ne],backend:r,attrs:{axis:0}}),st=Hd({inputs:[Le,je],backend:r,attrs:{axis:0}}),At=r.data.get(Je.dataId).values,pt=r.data.get(st.dataId).values;return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(le),r.disposeIntermediateTensorInfo(se),r.disposeIntermediateTensorInfo(pe),r.disposeIntermediateTensorInfo(ve),r.disposeIntermediateTensorInfo(Ie),r.disposeIntermediateTensorInfo(Re),r.disposeIntermediateTensorInfo(Le),r.disposeIntermediateTensorInfo(Ne),r.disposeIntermediateTensorInfo(je),r.disposeIntermediateTensorInfo(Je),r.disposeIntermediateTensorInfo(st),{real:At,imag:pt}}function Rae(e,t,a){let n=new Float32Array(t*2);for(let r=0;r<t;r++){let s=0,i=0;for(let o=0;o<t;o++){let u=D.exponent(r*o,t,a),d=D.getComplexWithIndex(e,o);s+=d.real*u.real-d.imag*u.imag,i+=d.real*u.imag+d.imag*u.real}a&&(s/=t,i/=t),D.assignToTypedArray(n,s,i,r)}return n}function Dae(e){let{inputs:t,backend:a}=e,{input:n}=t,r=C.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=r/s,o=aa({inputs:{x:n},backend:a,attrs:{shape:[i,s]}}),u=iO(o,!1,a),d=aa({inputs:{x:u},backend:a,attrs:{shape:n.shape}});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(u),d}var Mae={kernelName:Rb,backendName:"cpu",kernelFunc:Dae};function sI(e){let{backend:t,attrs:a}=e,{shape:n,value:r,dtype:s}=a,i=s||C.inferDtype(r),o=C.getArrayFromDType(i,C.sizeFromShape(n));return Oae(o,r),t.makeTensorInfo(n,i,o)}var Fae={kernelName:gm,backendName:"cpu",kernelFunc:sI};function Oae(e,t,a){e.fill(t)}var zae={kernelName:hh,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:a})=>{let{image:n}=e,r=a,s=C.getTypedArrayFromDType(n.dtype,C.sizeFromShape(n.shape)),[i,o,u,d]=n.shape,c=r.data.get(n.dataId).values;for(let f=0;f<i;f++){let m=f*u*o*d;for(let g=0;g<o;g++){let b=g*(u*d);for(let v=0;v<u;v++){let x=v*d;for(let k=0;k<d;k++){let S=Math.round(u-v-1),N=m+b+x+k,T=c[N];if(S>=0&&S<u){let _=S*d,R=m+b+_+k;T=c[R]}s[N]=T}}}}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function Lae(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dataFormat:c,dilations:f,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=n,v=rO({inputs:{x:r,filter:s},backend:a,attrs:{strides:u,pad:d,dataFormat:c,dilations:f,dimRoundingMode:m}});if(i){let x=v;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let k=aa({inputs:{x:i},backend:a,attrs:{shape:[i.shape[0],1,1]}});v=Vd({inputs:{a:v,b:k},backend:a}),a.disposeIntermediateTensorInfo(k)}else v=Vd({inputs:{a:v,b:i},backend:a});a.disposeIntermediateTensorInfo(x)}if(g){let x=v;if(c==="NCHW"&&g==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let k=aa({inputs:{x:o},backend:a,attrs:{shape:[o.shape[0],1,1]}});v=pb(a,v,g,k,b),a.disposeIntermediateTensorInfo(k)}else v=pb(a,v,g,o,b);a.disposeIntermediateTensorInfo(x)}return v}var Bae={kernelName:Ul,backendName:"cpu",kernelFunc:Lae};function Uae(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dataFormat:c,dilations:f,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=n,v=sO({inputs:{x:r,filter:s},backend:a,attrs:{strides:u,pad:d,dataFormat:c,dilations:f,dimRoundingMode:m}});if(i){let x=v;v=Vd({inputs:{a:v,b:i},backend:a}),a.disposeIntermediateTensorInfo(x)}if(g){let x=v;v=pb(a,v,g,o,b),a.disposeIntermediateTensorInfo(x)}return v}var Pae={kernelName:Pl,backendName:"cpu",kernelFunc:Uae};function Wae(e){let{inputs:t,backend:a}=e,{params:n,indices:r}=t,s=C.sizeFromShape(n.shape),i=r.shape,o=i[i.length-1],[u,d,c,f]=D.prepareAndValidate(n,r);if(d===0)return a.makeTensorInfo(u,n.dtype,[]);let m=a.data.get(r.dataId).values,g=a.bufferSync(n),b=kF(m,g,n.dtype,d,o,c,f,n.shape,s);return a.makeTensorInfo(u,n.dtype,b.values)}var Vae={kernelName:fh,backendName:"cpu",kernelFunc:Wae};function Gae(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=n;Be([r,s],"gatherV2");let u=C.parseAxisParam(i,r.shape)[0],d=a.data.get(s.dataId).values,c=r.shape[u];for(let T=0;T<d.length;++T){let _=d[T];C.assert(_<=c-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${c-1}]`)}let f=o;o==null&&(f=0);let m=C.sizeFromShape(s.shape),g=D.segment_util.collectGatherOpShapeInfo(r,s,u,f),b=aa({inputs:{x:r},backend:a,attrs:{shape:[g.batchSize,g.outerSize,g.dimSize,g.sliceSize]}}),v=aa({inputs:{x:s},backend:a,attrs:{shape:[g.batchSize,m/g.batchSize]}}),x=[g.batchSize,g.outerSize,m/g.batchSize,g.sliceSize],k=a.bufferSync(v),S=a.bufferSync(b),N=SF(S,k,x);return a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.makeTensorInfo(g.outputShape,N.dtype,N.values)}var Hae={kernelName:ph,backendName:"cpu",kernelFunc:Gae};function qae(e){let{inputs:t,backend:a}=e,{input:n}=t,r=C.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=r/s,o=aa({inputs:{x:n},backend:a,attrs:{shape:[i,s]}}),u=iO(o,!0,a),d=aa({inputs:{x:u},backend:a,attrs:{shape:n.shape}});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(u),d}var jae={kernelName:Db,backendName:"cpu",kernelFunc:qae},Kae=Lt(Ou,e=>Number.isFinite(e)?1:0,"bool"),Xae={kernelName:Ou,backendName:"cpu",kernelFunc:Kae},Yae=Lt(zu,e=>Math.abs(e)===1/0?1:0,"bool"),Zae={kernelName:zu,backendName:"cpu",kernelFunc:Yae},Qae=Lt(Lu,e=>Number.isNaN(e)?1:0,"bool"),Jae={kernelName:Lu,backendName:"cpu",kernelFunc:Qae};function ene(e){let{backend:t,attrs:a}=e,{start:n,stop:r,num:s}=a,i=CF(n,r,s);return t.makeTensorInfo([i.length],"float32",i)}var tne={kernelName:bh,backendName:"cpu",kernelFunc:ene},ane=Lt(Pu,e=>Math.log1p(e)),nne={kernelName:Pu,backendName:"cpu",kernelFunc:ane},rne=Ia((e,t)=>e&&t),sne=Ga(vh,rne,null,"bool"),ine={kernelName:vh,backendName:"cpu",kernelFunc:sne},one=Lt(xh,e=>e?0:1,"bool"),lne={kernelName:xh,backendName:"cpu",kernelFunc:one},une=Ia((e,t)=>e||t),cne=Ga(wh,une,null,"bool"),dne={kernelName:wh,backendName:"cpu",kernelFunc:cne};function hne(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:u}=n;Be(r,"LRN");let d=r.shape[3],c=d-1,f=a.data.get(r.dataId).values,m=C.sizeFromShape(r.shape),g=new Float32Array(m);function b(v){let x=v%d,k=v-x+Math.max(0,x-s),S=v-x+Math.min(x+s,c),N=0;for(;k<=S;k++){let T=f[k];N+=T*T}return N}for(let v=0;v<m;v++){let x=b(v),k=f[v]*Math.pow(i+o*x,-u);g[v]=k}return a.makeTensorInfo(r.shape,r.dtype,g)}var pne={kernelName:Wu,backendName:"cpu",kernelFunc:hne};function fne(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:u,alpha:d,beta:c}=n;Be(i,"LRNGrad");let f=C.sizeFromShape(i.shape),m=i.shape[3],g=a.data.get(i.dataId).values,b=a.data.get(r.dataId).values,v=a.data.get(s.dataId).values,x=new Float32Array(f),k=f;for(let S=0;S<k;S++){let N=S%m,T=S-N+Math.max(0,N-o),_=S-N+Math.min(m,N+o+1),R=0;for(let M=T;M<_;M++)R+=Math.pow(b[M],2);R=d*R+u;for(let M=T;M<_;M++){let F=-2*d*c*b[M]*v[S]/R;S===M&&(F+=Math.pow(R,-c)),F*=g[S],x[M]+=F}}return a.makeTensorInfo(i.shape,r.dtype,x)}var mne={kernelName:kh,backendName:"cpu",kernelFunc:fne};function oO(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=n,o=a,u=r.shape,d=u.length,c=C.parseAxisParam(s,u),f=c,m=D.getAxesPermutation(f,d),g=o.data.get(r.dataId).values;if(m!=null){let T=new Array(d);for(let _=0;_<T.length;_++)T[_]=u[m[_]];g=X2(g,u,r.dtype,m,T),f=D.getInnerMostAxes(f.length,d),u=T}Be(r,"max"),D.assertAxesAreInnerMostDims("max",f,d);let[b,v]=D.computeOutAndReduceShapes(u,f),x=C.sizeFromShape(v),k=AF(g,x,b,r.dtype),S=o.write(k,b,r.dtype),N=b;return i&&(N=D.expandShapeToKeepDim(b,c)),{dataId:S,shape:N,dtype:r.dtype}}var gne={kernelName:Vu,backendName:"cpu",kernelFunc:oO};function yne(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t;Be(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=n,d=1;C.assert(D.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=D.computePool2DInfo(r.shape,s,i,d,o,u),f;if(c.filterWidth===1&&c.filterHeight===1&&C.arraysEqual(c.inShape,c.outShape))f=Vs({inputs:{x:r},backend:a});else{let m=a.data.get(r.dataId).values,g=C.computeStrides(r.shape),b=nI(m,r.shape,r.dtype,g,c,"max");f=a.makeTensorInfo(c.outShape,r.dtype,b.values)}return f}var bne={kernelName:Hu,backendName:"cpu",kernelFunc:yne};function vne(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=n;Be(r,"maxPool3d");let c=D.computePool3DInfo(r.shape,s,i,1,o,u,d),f=a.data.get(r.dataId).values,m=nO(f,r.shape,r.dtype,C.computeStrides(r.shape),c,"max");return a.makeTensorInfo(m.shape,"float32",m.values)}var xne={kernelName:Sh,backendName:"cpu",kernelFunc:vne};function wne(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=n;Be([r,s],"maxPool3DGrad");let c=D.computePool3DInfo(s.shape,i,o,1,u,d),f=a.bufferSync(s),m=ute(f,c),g=c.strideDepth,b=c.strideHeight,v=c.strideWidth,x=c.dilationDepth,k=c.dilationHeight,S=c.dilationWidth,N=c.effectiveFilterDepth,T=c.effectiveFilterHeight,_=c.effectiveFilterWidth,R=N-1-c.padInfo.front,M=_-1-c.padInfo.left,F=T-1-c.padInfo.top,B=ct(s.shape,"float32"),V=a.bufferSync(r);for(let P=0;P<c.batchSize;++P)for(let A=0;A<c.inChannels;++A)for(let G=0;G<c.inDepth;++G)for(let J=0;J<c.inHeight;++J)for(let ee=0;ee<c.inWidth;++ee){let W=G-R,X=J-F,Q=ee-M,ce=0;for(let L=0;L<N;L+=x){let q=(W+L)/g;if(!(q<0||q>=c.outDepth||Math.floor(q)!==q))for(let le=0;le<T;le+=k){let se=(X+le)/b;if(!(se<0||se>=c.outHeight||Math.floor(se)!==se))for(let pe=0;pe<_;pe+=S){let ve=(Q+pe)/v;if(ve<0||ve>=c.outWidth||Math.floor(ve)!==ve)continue;let Ie=N*T*_-1-m.get(P,q,se,ve,A),Re=L*T*_+le*_+pe,Ne=Ie===Re?1:0;if(Ne===0)continue;let Le=V.get(P,q,se,ve,A);ce+=Le*Ne}}}B.set(ce,P,G,J,ee,A)}return a.makeTensorInfo(B.shape,B.dtype,B.values)}var kne={kernelName:bm,backendName:"cpu",kernelFunc:wne};function Sne(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s,output:i}=t,o=s;Be([s,i],"maxPoolGrad");let{filterSize:u,strides:d,pad:c,dimRoundingMode:f}=n,m=D.computePool2DInfo(o.shape,u,d,1,c,f),g=a.data.get(o.dataId).values,b=ct(m.outShape,o.dtype,aO(g,o.shape,o.dtype,m).values),v=m.strideHeight,x=m.strideWidth,k=m.dilationHeight,S=m.dilationWidth,N=m.effectiveFilterHeight,T=m.effectiveFilterWidth,_=T-1-m.padInfo.left,R=N-1-m.padInfo.top,M=ct(o.shape,"float32"),F=a.data.get(r.dataId).values,B=ct(r.shape,"float32",F);for(let V=0;V<m.batchSize;++V)for(let P=0;P<m.inChannels;++P)for(let A=0;A<m.inHeight;++A)for(let G=0;G<m.inWidth;++G){let J=A-R,ee=G-_,W=0;for(let X=0;X<N;X+=k){let Q=(J+X)/v;if(!(Q<0||Q>=m.outHeight||Math.floor(Q)!==Q))for(let ce=0;ce<T;ce+=S){let L=(ee+ce)/x;if(L<0||L>=m.outWidth||Math.floor(L)!==L)continue;let q=N*T-1-b.get(V,Q,L,P),le=X*T+ce,se=q===le?1:0;if(se===0)continue;let pe=B.get(V,Q,L,P);W+=pe*se}}M.set(W,V,A,G,P)}return a.makeTensorInfo(M.shape,M.dtype,M.values)}var Ine={kernelName:ym,backendName:"cpu",kernelFunc:Sne};function Nne(e,t,a,n,r){let s=C.computeStrides(t),i=nI(e,t,a,s,r,"max"),o=aO(e,t,a,r,!0,n);return[i.values,o.values]}var Tne={kernelName:vm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:a})=>{let{x:n}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,u=a;Be(n,"MaxPoolWithArgmax");let d=u.data.get(n.dataId).values,c=D.computePool2DInfo(n.shape,r,s,[1,1],i),[f,m]=Nne(d,n.shape,n.dtype,o,c),g=u.write(f,c.outShape,n.dtype),b=u.write(m,c.outShape,n.dtype);return[{dataId:g,shape:c.outShape,dtype:n.dtype},{dataId:b,shape:c.outShape,dtype:"int32"}]}};function _ne(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n,o=C.parseAxisParam(s,r.shape),u=D.computeOutAndReduceShapes(r.shape,o)[1],d=C.sizeFromShape(u),c=[],f=a.makeTensorInfo([],"float32",new Float32Array([d]));c.push(f);let m=Ro({inputs:{x:r},backend:a,attrs:{dtype:"float32"}});c.push(m);let g=rI({inputs:{a:m,b:f},backend:a});c.push(g);let b=sg({inputs:{x:g},backend:a,attrs:{axis:s,keepDims:i}});return c.forEach(v=>a.disposeIntermediateTensorInfo(v)),b}var Cne={kernelName:qu,backendName:"cpu",kernelFunc:_ne};function Ene(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n;Be(r,"min");let o=C.parseAxisParam(s,r.shape),u=o,d=D.getAxesPermutation(u,r.shape.length),c=r;d!=null&&(c=qn({inputs:{x:r},backend:a,attrs:{perm:d}}),u=D.getInnerMostAxes(u.length,r.shape.length)),D.assertAxesAreInnerMostDims("min",u,c.shape.length);let[f,m]=D.computeOutAndReduceShapes(c.shape,u),g=C.sizeFromShape(m),b=C.makeZerosTypedArray(C.sizeFromShape(f),c.dtype),v=a.data.get(c.dataId).values;for(let k=0;k<b.length;++k){let S=k*g,N=v[S];for(let T=0;T<g;++T){let _=v[S+T];(Number.isNaN(_)||_<N)&&(N=_)}b[k]=N}d!=null&&a.disposeIntermediateTensorInfo(c);let x=a.makeTensorInfo(f,c.dtype,b);if(i){let k=D.expandShapeToKeepDim(f,o),S=aa({inputs:{x},backend:a,attrs:{shape:k}});return a.disposeIntermediateTensorInfo(x),S}return x}var Ane={kernelName:ju,backendName:"cpu",kernelFunc:Ene};function $ne(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{paddings:s,mode:i}=n;Be(r,"mirrorPad");let o=s.map((S,N)=>S[0]+r.shape[N]+S[1]),u=s.map(S=>S[0]),d=s.map((S,N)=>S[0]+r.shape[N]),c=i==="reflect"?0:1,f=a.data.get(r.dataId).values,m=r.shape.length,g=C.computeStrides(r.shape),b=C.sizeFromShape(o),v=o.length,x=C.computeStrides(o),k=C.getTypedArrayFromDType(r.dtype,b);for(let S=0;S<b;S++){let N=C.indexToLoc(S,v,x);for(let _=0;_<v;_++)N[_]<u[_]?N[_]=u[_]*2-N[_]-c:N[_]>=d[_]&&(N[_]=(d[_]-1)*2-N[_]+c);N=N.map((_,R)=>_-u[R]);let T=C.locToIndex(N,m,g);k[S]=f[T]}return{dataId:a.write(k,o,r.dtype),shape:o,dtype:r.dtype}}var Rne={kernelName:Xu,backendName:"cpu",kernelFunc:$ne},Dne=Ia((e,t)=>{let a=e%t;return e<0&&t<0||e>=0&&t>=0?a:(a+t)%t}),Mne=Ga(Yu,Dne),Fne={kernelName:Yu,backendName:"cpu",kernelFunc:Mne},One=Fo(kb());function lO(e){let{inputs:t,backend:a,attrs:n}=e,{logits:r}=t,{dim:s}=n,i=r.shape.length,o=s;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let u=C.parseAxisParam([o],r.shape),d=oO({inputs:{x:r},backend:a,attrs:{reductionIndices:u,keepDims:!1}}),c=D.expandShapeToKeepDim(d.shape,u),f=aa({inputs:{x:d},backend:a,attrs:{shape:c}}),m=tI({inputs:{a:r,b:f},backend:a}),g=bF({inputs:{x:m},backend:a}),b=sg({inputs:{x:g},backend:a,attrs:{axis:u,keepDims:!1}}),v=aa({inputs:{x:b},backend:a,attrs:{shape:c}}),x=rI({inputs:{a:g,b:v},backend:a});return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),x}var zne={kernelName:vc,backendName:"cpu",kernelFunc:lO};function Lne(e){let{inputs:t,backend:a,attrs:n}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=n;Be(r,"multinomial");let u=o?r:lO({inputs:{logits:r},backend:a,attrs:{dim:-1}}),d=u.shape[0],c=u.shape[1],f=a.data.get(u.dataId).values,m=[d,s],g=C.makeZerosTypedArray(C.sizeFromShape(m),"int32");for(let b=0;b<d;++b){let v=b*c,x=new Float32Array(c-1);x[0]=f[v];for(let N=1;N<x.length;++N)x[N]=x[N-1]+f[v+N];let k=One.alea(i.toString()),S=b*s;for(let N=0;N<s;++N){let T=k();g[S+N]=x.length;for(let _=0;_<x.length;_++)if(T<x[_]){g[S+N]=_;break}}}return o||a.disposeIntermediateTensorInfo(u),a.makeTensorInfo(m,"int32",g)}var Bne={kernelName:Ih,backendName:"cpu",kernelFunc:Lne},Une=qs.nonMaxSuppressionV3Impl;function Pne(e){let{inputs:t,backend:a,attrs:n}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=n;Be(r,"NonMaxSuppression");let d=a.data.get(r.dataId).values,c=a.data.get(s.dataId).values,{selectedIndices:f}=Une(d,c,i,o,u);return a.makeTensorInfo([f.length],"int32",new Int32Array(f))}var Wne={kernelName:_h,backendName:"cpu",kernelFunc:Pne},Vne=qs.nonMaxSuppressionV4Impl;function Gne(e){let{inputs:t,backend:a,attrs:n}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:d}=n;Be(r,"NonMaxSuppressionPadded");let c=a.data.get(r.dataId).values,f=a.data.get(s.dataId).values,{selectedIndices:m,validOutputs:g}=Vne(c,f,i,o,u,d);return[a.makeTensorInfo([m.length],"int32",new Int32Array(m)),a.makeTensorInfo([],"int32",new Int32Array([g]))]}var Hne={kernelName:Ch,backendName:"cpu",kernelFunc:Gne},qne=qs.nonMaxSuppressionV5Impl;function jne(e){let{inputs:t,backend:a,attrs:n}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:d}=n;Be(r,"NonMaxSuppressionWithScore");let c=a.data.get(r.dataId).values,f=a.data.get(s.dataId).values,m=i,g=o,b=u,v=d,{selectedIndices:x,selectedScores:k}=qne(c,f,m,g,b,v);return[a.makeTensorInfo([x.length],"int32",new Int32Array(x)),a.makeTensorInfo([k.length],"float32",new Float32Array(k))]}var Kne={kernelName:Eh,backendName:"cpu",kernelFunc:jne};function Xne(e){let{inputs:t,backend:a,attrs:n}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:u}=n;Be(r,"oneHot");let d=C.sizeFromShape(r.shape),c=new Float32Array(d*i);c.fill(u);let f=a.data.get(r.dataId).values;for(let m=0;m<d;++m)f[m]>=0&&f[m]<i&&(c[m*i+f[m]]=o);return a.makeTensorInfo([...r.shape,i],s,c)}var Yne={kernelName:Qu,backendName:"cpu",kernelFunc:Xne};function mb(e){let{inputs:t,backend:a}=e,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let r=Ql({inputs:{input:n},backend:a}),s=mb({inputs:{x:r},backend:a}),i=Gd({inputs:{input:n},backend:a}),o=mb({inputs:{x:i},backend:a}),u=rr({inputs:{real:s,imag:o},backend:a});return a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),u}else return sI({backend:a,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var Zne={kernelName:Kh,backendName:"cpu",kernelFunc:mb};function uO(e){let{inputs:t,backend:a}=e,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let r=Ql({inputs:{input:n},backend:a}),s=uO({inputs:{x:r},backend:a}),i=Gd({inputs:{input:n},backend:a}),o=mb({inputs:{x:i},backend:a}),u=rr({inputs:{real:s,imag:o},backend:a});return a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),u}else return sI({backend:a,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var Qne={kernelName:Ah,backendName:"cpu",kernelFunc:uO};function cO(e){let{inputs:t,backend:a,attrs:n}=e,{axis:r}=n;if(t.length===1)return fb({inputs:{input:t[0]},backend:a,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{C.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),C.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(c=>{let f=fb({inputs:{input:c},backend:a,attrs:{dim:r}});return o.push(f),f}),d=Hd({inputs:u,backend:a,attrs:{axis:r}});return o.forEach(c=>a.disposeIntermediateTensorInfo(c)),d}var Jne={kernelName:$h,backendName:"cpu",kernelFunc:cO};function ere(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{paddings:s,constantValue:i}=n;Be(r,"pad");let o=s.map((k,S)=>k[0]+r.shape[S]+k[1]),u=s.map(k=>k[0]),d=a.data.get(r.dataId).values,c=C.sizeFromShape(r.shape),f=r.shape.length,m=C.computeStrides(r.shape),g=C.sizeFromShape(o),b=o.length,v=C.computeStrides(o),x=C.getTypedArrayFromDType(r.dtype,g);i!==0&&x.fill(i);for(let k=0;k<c;k++){let S=C.indexToLoc(k,f,m).map((T,_)=>T+u[_]),N=C.locToIndex(S,b,v);x[N]=d[k]}return{dataId:a.write(x,o,r.dtype),shape:o,dtype:r.dtype}}var dO={kernelName:Ju,backendName:"cpu",kernelFunc:ere},tre=Ia((e,t)=>Math.pow(e,t)),are=Ga(ec,tre),nre={kernelName:ec,backendName:"cpu",kernelFunc:are};function rre(e){let{inputs:t,backend:a,attrs:n}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=n,u=r.map(k=>a.data.get(k.dataId).values),d=r.map(k=>k.shape),c=a.data.get(s.dataId).values,f=a.data.get(i.dataId).values,[m,g,b]=OF(u,d,c,s.shape,s.dtype,f,i.shape),v=m.map(k=>a.makeTensorInfo([k.length],"int32",k)),x=a.makeTensorInfo(b,s.dtype,g);return v.concat([x])}var sre={kernelName:Fb,backendName:"cpu",kernelFunc:rre};function ire(e){let{inputs:t,backend:a}=e,{starts:n,limits:r,deltas:s}=t,i=a.data.get(n.dataId).values,o=a.data.get(r.dataId).values,u=a.data.get(s.dataId).values,[d,c]=zF(i,n.shape,n.dtype,o,r.shape,u,s.shape),f=a.makeTensorInfo([d.length],"int32",d),m=a.makeTensorInfo([c.length],n.dtype,c);return[f,m]}var ore={kernelName:Ob,backendName:"cpu",kernelFunc:ire};function lre(e){let{inputs:t,backend:a,attrs:n}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=n,d=a.data.get(r.dataId).values,c=a.data.get(s.dataId).values,f=a.data.get(i.dataId).values,m=o.map(x=>a.data.get(x.dataId).values),g=o.map(x=>x.shape),[b,v]=LF(d,r.shape,c,s.shape,s.dtype,f,i.shape,m,g,u);return a.makeTensorInfo(b,s.dtype,v)}var ure={kernelName:zb,backendName:"cpu",kernelFunc:lre};function cre(e){let{backend:t,attrs:a}=e,{start:n,stop:r,dtype:s,step:i}=a,o=Y2(n,r,i,s);return t.makeTensorInfo([o.length],s,o)}var dre={kernelName:xm,backendName:"cpu",kernelFunc:cre},hre=Lt(nc,e=>1/e),pre={kernelName:nc,backendName:"cpu",kernelFunc:hre};function fre(e){let{inputs:t,backend:a,attrs:n}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=n;Be(r,"resizeBilinear");let u=C.computeStrides(r.shape),[d,c]=o,[f,m,g,b]=r.shape,v=a.data.get(r.dataId).values,x=new Float32Array(C.sizeFromShape([f,d,c,b])),k=[s&&d>1?m-1:m,s&&c>1?g-1:g],S=[s&&d>1?d-1:d,s&&c>1?c-1:c],N=0,T=k[0]/S[0],_=k[1]/S[1];for(let R=0;R<f;R++)for(let M=0;M<d;M++){let F;i?F=T*(M+.5)-.5:F=T*M;let B=Math.max(0,Math.floor(F)),V=F-B,P=Math.min(m-1,Math.ceil(F)),A=R*u[0]+B*u[1],G=R*u[0]+P*u[1];for(let J=0;J<c;J++){let ee;i?ee=_*(J+.5)-.5:ee=_*J;let W=Math.max(0,Math.floor(ee)),X=ee-W,Q=Math.min(g-1,Math.ceil(ee)),ce=A+W*u[2],L=G+W*u[2],q=A+Q*u[2],le=G+Q*u[2];for(let se=0;se<b;se++){let pe=v[ce+se],ve=v[L+se],Ie=v[q+se],Re=v[le+se],Ne=pe+(Ie-pe)*X,Le=ve+(Re-ve)*X,je=Ne+(Le-Ne)*V;x[N++]=je}}}return a.makeTensorInfo([f,d,c,b],"float32",x)}var mre={kernelName:ic,backendName:"cpu",kernelFunc:fre};function gre(e){let{inputs:t,backend:a,attrs:n}=e,{images:r,dy:s}=t,{alignCorners:i}=n;Be([s,r],"resizeBilinearGrad");let o=C.computeStrides(r.shape),[u,d,c,f]=r.shape,[,m,g]=s.shape,b=new Float32Array(u*d*c*f),v=[i&&m>1?d-1:d,i&&g>1?c-1:c],x=[i&&m>1?m-1:m,i&&g>1?g-1:g],k=v[0]/x[0],S=v[1]/x[1],N=a.data.get(s.dataId).values,T=0;for(let _=0;_<u;_++){let R=_*o[0];for(let M=0;M<m;M++){let F=M*k,B=Math.floor(F),V=Math.min(Math.ceil(F),d-1),P=R+B*o[1],A=R+V*o[1],G=F-B,J=1-G;for(let ee=0;ee<g;ee++){let W=ee*S,X=Math.floor(W),Q=Math.min(Math.ceil(W),c-1),ce=W-X,L=1-ce,q=P+X*o[2],le=P+Q*o[2],se=A+X*o[2],pe=A+Q*o[2],ve=J*L,Ie=J*ce,Re=G*L,Ne=G*ce;for(let Le=0;Le<f;Le++){let je=N[T++];b[q+Le]+=je*ve,b[le+Le]+=je*Ie,b[se+Le]+=je*Re,b[pe+Le]+=je*Ne}}}}return a.makeTensorInfo([u,c,d,f],"float32",b)}var yre={kernelName:Mh,backendName:"cpu",kernelFunc:gre};function bre(e){let{inputs:t,backend:a,attrs:n}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=n;Be(r,"resizeNearestNeighbor");let u=C.computeStrides(r.shape),[d,c]=o,[f,m,g,b]=r.shape,v=a.data.get(r.dataId).values,x=new Float32Array(f*d*c*b),k=[s&&d>1?m-1:m,s&&c>1?g-1:g],S=[s&&d>1?d-1:d,s&&c>1?c-1:c],N=k[0]/S[0],T=k[1]/S[1],_=0;for(let R=0;R<f;R++){let M=R*u[0];for(let F=0;F<d;F++){let B=i?N*(F+.5):N*F,V=Math.min(m-1,s?Math.round(B):Math.floor(B));i&&(V=Math.max(0,V));let P=M+V*u[1];for(let A=0;A<c;A++){let G=i?T*(A+.5):T*A,J=Math.min(g-1,s?Math.round(G):Math.floor(G));i&&(J=Math.max(0,J));let ee=P+J*u[2];for(let W=0;W<b;W++){let X=v[ee+W];x[_++]=X}}}}return a.makeTensorInfo([f,d,c,b],r.dtype,x)}var vre={kernelName:sc,backendName:"cpu",kernelFunc:bre};function xre(e){let{inputs:t,backend:a,attrs:n}=e,{images:r,dy:s}=t,{alignCorners:i}=n;Be([s,r],"resizeNearestNeighborGrad");let o=C.computeStrides(r.shape),u=C.computeStrides(s.shape),[d,c,f,m]=r.shape,[,g,b]=s.shape,v=new Float32Array(d*c*f*m),x=a.data.get(s.dataId).values,k=[i&&g>1?c-1:c,i&&b>1?f-1:f],S=[i&&g>1?g-1:g,i&&b>1?b-1:b],N=k[0]/S[0],T=k[1]/S[1],_=1/N,R=1/T,M=Math.ceil(_)*2+2,F=Math.ceil(R)*2+2;for(let B=0;B<d;B++){let V=B*o[0];for(let P=0;P<c;P++){let A=V+P*o[1],G=Math.floor(P*_),J=Math.floor(G-M/2);for(let ee=0;ee<f;ee++){let W=A+ee*o[2],X=Math.floor(ee*R),Q=Math.floor(X-F/2);for(let ce=0;ce<m;ce++){let L=0;for(let q=0;q<M;q++){let le=q+J;if(le<0||le>=g)continue;let se=V+le*u[1],pe=le*N,ve=Math.min(c-1,i?Math.round(pe):Math.floor(pe));if(P===ve)for(let Ie=0;Ie<F;Ie++){let Re=Ie+Q;if(Re<0||Re>=b)continue;let Ne=se+Re*u[2],Le=Re*T,je=Math.min(f-1,i?Math.round(Le):Math.floor(Le));ee===je&&(L+=x[Ne+ce])}}v[W+ce]=L}}}}return a.makeTensorInfo(r.shape,r.dtype,v)}var wre={kernelName:Dh,backendName:"cpu",kernelFunc:xre};function kre(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{dims:s}=n;Be(r,"reverse");let i=r.shape.length,o=C.parseAxisParam(s,r.shape);if(i===0)return Vs({inputs:{x:r},backend:a});let u=new Aa(r.shape,r.dtype),d=a.bufferSync(r);for(let c=0;c<u.size;c++){let f=u.indexToLoc(c),m=f.slice();o.forEach(g=>m[g]=r.shape[g]-1-m[g]),u.set(d.get(...m),...f)}return a.makeTensorInfo(u.shape,u.dtype,u.values)}var Sre={kernelName:lc,backendName:"cpu",kernelFunc:kre},Ire={kernelName:Xh,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:a})=>{let{image:n}=e,{radians:r,fillValue:s,center:i}=t,o=a,u=C.getTypedArrayFromDType(n.dtype,C.sizeFromShape(n.shape)),[d,c,f,m]=n.shape,[g,b]=D.getImageCenter(i,c,f),v=255,x=Math.sin(r),k=Math.cos(r),S=o.data.get(n.dataId).values;for(let N=0;N<d;N++){let T=N*f*c*m;for(let _=0;_<c;_++){let R=_*(f*m);for(let M=0;M<f;M++){let F=M*m;for(let B=0;B<m;B++){let V=[d,_,M,B],P=V[2],A=V[1],G=(P-g)*k-(A-b)*x,J=(P-g)*x+(A-b)*k;G=Math.round(G+g),J=Math.round(J+b);let ee=s;if(typeof s!="number"&&(B===3?ee=v:ee=s[B]),G>=0&&G<f&&J>=0&&J<c){let X=J*(f*m),Q=G*m,ce=T+X+Q+B;ee=S[ce]}let W=T+R+F+B;u[W]=ee}}}}return{dataId:o.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Nre=Lt(uc,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),Tre={kernelName:uc,backendName:"cpu",kernelFunc:Nre};function _re(e){let{inputs:t,backend:a,attrs:n}=e,{indices:r,updates:s}=t,{shape:i}=n,{sliceRank:o,numUpdates:u,sliceSize:d,strides:c,outputSize:f}=D.calculateShapes(s,r,i),m=!0,g=a.bufferSync(r),b=a.bufferSync(s),v=Dl(g,b,i,f,d,u,o,c,0,m);return a.makeTensorInfo(i,v.dtype,v.values)}var Cre={kernelName:Fh,backendName:"cpu",kernelFunc:_re};function Ere(e,t){let a=0,n=e.length,r=0;for(;a<n;)r=Math.floor((a+n)/2),e[r]<t?a=r+1:n=r;return n}function Are(e,t){let a=0,n=e.length,r=0;for(;a<n;)r=Math.floor((a+n)/2),e[r]<=t?a=r+1:n=r;return n}function $re(e,t,a,n,r,s){let i=C.getArrayFromDType("int32",a*r);for(let o=0;o<a;++o){let u=e.slice(o*n,(o+1)*n),d=o*r;for(let c=0;c<r;++c)i[d+c]=s==="left"?Ere(u,t[c+d]):Are(u,t[c+d])}return i}function Rre(e){let{inputs:t,backend:a,attrs:n}=e,{sortedSequence:r,values:s}=t,{side:i}=n,o=a.data.get(r.dataId).values,u=a.data.get(s.dataId).values,d=$re(o,u,r.shape[0],r.shape[1],s.shape[1],i);return a.makeTensorInfo(s.shape,"int32",d)}var Dre={kernelName:zh,backendName:"cpu",kernelFunc:Rre};function Mre(e){let{inputs:t,backend:a}=e,{condition:n,t:r,e:s}=t;Be([n,r,s],"select");let i=n.shape.length,o=a.data.get(n.dataId).values,u=a.data.get(r.dataId).values,d=a.data.get(s.dataId).values,c=Nr(r.dtype,s.dtype),f=C.makeZerosTypedArray(C.sizeFromShape(r.shape),c),m=0,g=i===0||i>1||r.shape.length===1?1:C.sizeFromShape(r.shape.slice(1));for(let b=0;b<o.length;b++)for(let v=0;v<g;v++)o[b]===1?f[m++]=u[b]:f[m++]=d[b];return a.makeTensorInfo(r.shape,c,f)}var Fre={kernelName:Lh,backendName:"cpu",kernelFunc:Mre},Ore=D.SELU_SCALEALPHA,zre=D.SELU_SCALE,Lre=Lt(dc,e=>e>=0?zre*e:Ore*(Math.exp(e)-1)),Bre={kernelName:dc,backendName:"cpu",kernelFunc:Lre},Ure=Lt(fc,e=>e<0?-1:e>0?1:0),Pre={kernelName:fc,backendName:"cpu",kernelFunc:Ure},Wre=Lt(hc,e=>Math.sin(e)),Vre={kernelName:hc,backendName:"cpu",kernelFunc:Wre},Gre=Lt(pc,e=>Math.sinh(e)),Hre={kernelName:pc,backendName:"cpu",kernelFunc:Gre},qre=11920928955078125e-23,AE=Math.log(qre)+2,jre=Lt(gc,e=>{let t=e>-AE,a=e<AE,n=Math.exp(e),r;return a?r=n:t?r=e:r=Math.log(1+n),r}),Kre={kernelName:gc,backendName:"cpu",kernelFunc:jre};function Xre(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{blockShape:s,paddings:i}=n;Be([r],"spaceToBatchND");let o=C.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let x=1+s.length;x<r.shape.length;++x)u.push([0,0]);let d=dO.kernelFunc({inputs:{x:r},backend:a,attrs:{paddings:u,constantValue:0}}),c=D.getReshaped(d.shape,s,o,!1),f=D.getPermuted(c.length,s.length,!1),m=D.getReshapedPermuted(d.shape,s,o,!1),g=aa({inputs:{x:d},backend:a,attrs:{shape:c}}),b=qn({inputs:{x:g},backend:a,attrs:{perm:f}}),v=aa({inputs:{x:b},backend:a,attrs:{shape:m}});return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),v}var Yre={kernelName:Uh,backendName:"cpu",kernelFunc:Xre};function Zre(e){let{inputs:t,backend:a}=e,{indices:n,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=a.data.get(n.dataId).values,u=a.data.get(r.dataId).values,d=a.data.get(s.dataId).values,c=a.data.get(i.dataId).values[0],[f,m,g,b,v]=PF(o,n.shape,n.dtype,u,r.dtype,d,c);return[a.makeTensorInfo(m,n.dtype,f),a.makeTensorInfo([m[0]],r.dtype,g),a.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(x=>Number(x)))),a.makeTensorInfo([v.length],n.dtype,new Int32Array(v))]}var Qre={kernelName:wm,backendName:"cpu",kernelFunc:Zre};function Jre(e){let{inputs:t,backend:a}=e,{inputIndices:n,inputShape:r,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(a.data.get(r.dataId).values),o=a.data.get(n.dataId).values,u=Array.from(a.data.get(s.dataId).values),[d,c,f]=WF(o,n.shape,n.dtype,i,u);return[a.makeTensorInfo(c,n.dtype,d),a.makeTensorInfo([f.length],s.dtype,new Int32Array(f))]}var ese={kernelName:Wh,backendName:"cpu",kernelFunc:Jre};function tse(e){let{inputs:t,backend:a}=e,{data:n,indices:r,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=a.data.get(n.dataId).values,o=a.data.get(r.dataId).values,u=a.data.get(s.dataId).values,[d,c]=Z2(i,n.shape,n.dtype,o,u,!0);return a.makeTensorInfo(c,n.dtype,d)}var ase={kernelName:km,backendName:"cpu",kernelFunc:tse};function nse(e){let{inputs:t,backend:a}=e,{data:n,indices:r,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=a.data.get(n.dataId).values,o=a.data.get(r.dataId).values,u=a.data.get(s.dataId).values,[d,c]=Z2(i,n.shape,n.dtype,o,u);return a.makeTensorInfo(c,n.dtype,d)}var rse={kernelName:Sm,backendName:"cpu",kernelFunc:nse};function sse(e){let{inputs:t,backend:a,attrs:n}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=n,{sliceRank:u,numUpdates:d,sliceSize:c,strides:f,outputSize:m}=D.calculateShapes(s,r,o),g=!1,b=a.bufferSync(r),v;switch(s.dtype){case"bool":{let x=a.bufferSync(s),k=!!a.data.get(i.dataId).values[0];v=Dl(b,x,o,m,c,d,u,f,k,g);break}case"float32":{let x=a.bufferSync(s),k=a.data.get(i.dataId).values[0];v=Dl(b,x,o,m,c,d,u,f,k,g);break}case"int32":{let x=a.bufferSync(s),k=a.data.get(i.dataId).values[0];v=Dl(b,x,o,m,c,d,u,f,k,g);break}case"string":{let x=a.bufferSync(s),k=C.decodeString(a.data.get(i.dataId).values[0]);v=Dl(b,x,o,m,c,d,u,f,k,g);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return a.makeTensorInfo(o,v.dtype,v.values)}var ise={kernelName:Vh,backendName:"cpu",kernelFunc:sse};function ose(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=n,o=C.parseAxisParam(i,r.shape)[0],u=D.prepareSplitSize(r,s,o),d=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(f=>{let m=[...c];m[o]=f;let g=Jl({inputs:{x:r},backend:a,attrs:{begin:d,size:m}});return d[o]+=f,g})}var lse={kernelName:Ph,backendName:"cpu",kernelFunc:ose},use={kernelName:Im,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:a}=e,n=t;Be(a,"square");let r=n.data.get(a.dataId).values,s=new Float32Array(r.length);for(let i=0;i<r.length;++i){let o=r[i];s[i]=o*o}return{dataId:n.write(s,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},cse=Lt(Bo,(e,t)=>{let a=t;return isNaN(e)?NaN:e>0?1:a.alpha}),dse={kernelName:Bo,backendName:"cpu",kernelFunc:cse};function hse(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:f,shrinkAxisMask:m}=n;Be(r,"stridedSlice");let{finalShapeSparse:g,finalShape:b,isIdentity:v,sliceDim0:x,isSimpleSlice:k,begin:S,end:N,strides:T}=Pa.sliceInfo(r.shape,s,i,o,u,d,c,f,m),_;if(v)_=aa({inputs:{x:r},backend:a,attrs:{shape:b}});else if(x||k){C.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let R=Pa.computeOutShape(S,N,T),M=Jl({inputs:{x:r},backend:a,attrs:{begin:S,size:R}});_=aa({inputs:{x:M},backend:a,attrs:{shape:b}}),a.disposeIntermediateTensorInfo(M)}else{let R=a.bufferSync(r),M=HF(g,R,T,S);_=a.makeTensorInfo(b,M.dtype,M.values)}return _}var pse={kernelName:Gh,backendName:"cpu",kernelFunc:hse};function fse(e){let{inputs:t,backend:a,attrs:n}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:d}=n,{data:c,dataSplits:f}=t,m=a.data.get(c.dataId).values,g=a.data.get(f.dataId).values,[b,v]=Q2(m,g,r,s,i,o,u,d);return[a.makeTensorInfo([b.length],"string",b),a.makeTensorInfo(f.shape,"int32",v)]}var mse={kernelName:Tm,backendName:"cpu",kernelFunc:fse};function gse(e){let{inputs:t,backend:a,attrs:n}=e,{skipEmpty:r}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=a.data.get(s.dataId).values,u=a.data.get(i.dataId).values[0],[d,c,f]=J2(o,u,r),m=c.length;return[a.makeTensorInfo([m,2],"int32",d),a.makeTensorInfo([m],"string",c),a.makeTensorInfo([2],"int32",new Int32Array(f))]}var yse={kernelName:_m,backendName:"cpu",kernelFunc:gse};function bse(e){let{inputs:t,backend:a,attrs:n}=e,{numBuckets:r}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=a.data.get(s.dataId).values,o=eI(i,r);return a.makeTensorInfo(s.shape,"int32",o)}var vse={kernelName:Cm,backendName:"cpu",kernelFunc:bse},xse=Lt(kc,e=>Math.tan(e)),wse={kernelName:kc,backendName:"cpu",kernelFunc:xse},kse=Lt(Sc,e=>Math.tanh(e)),Sse={kernelName:Sc,backendName:"cpu",kernelFunc:kse};function Ise(e){let{inputs:t,backend:a}=e,{tensor:n,indices:r,updates:s}=t,{sliceRank:i,numUpdates:o,sliceSize:u,strides:d,outputSize:c}=D.calculateShapes(s,r,n.shape),f=!1,m=a.bufferSync(r),g=a.bufferSync(s),b=a.bufferSync(n),v=Dl(m,g,n.shape,c,u,o,i,d,b,f);return a.makeTensorInfo(n.shape,v.dtype,v.values)}var Nse={kernelName:Oh,backendName:"cpu",kernelFunc:Ise};function Tse(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{reps:s}=n;Be(r,"tile");let i=jF(a.bufferSync(r),s);return a.makeTensorInfo(i.shape,i.dtype,i.values)}var _se={kernelName:Lo,backendName:"cpu",kernelFunc:Tse};function Cse(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{k:s,sorted:i}=n;Be(r,"topk");let o=a.data.get(r.dataId).values,[u,d]=XF(o,r.shape,r.dtype,s,i);return[a.makeTensorInfo(u.shape,u.dtype,u.values),a.makeTensorInfo(d.shape,d.dtype,d.values)]}var Ese={kernelName:Hh,backendName:"cpu",kernelFunc:Cse};function Ase(e){let{inputs:t,attrs:a,backend:n}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:d}=a,[c,f,m,g]=r.shape,[b,v]=d??[f,m],x=[c,b,v,g],k=C.computeStrides(r.shape),S=k[0],N=k[1],T=k[2],_=C.computeStrides(x),R=_[0],M=_[1],F=_[2],B=C.getTypedArrayFromDType(r.dtype,C.sizeFromShape(x));B.fill(u);let V=n.data.get(r.dataId).values,P=n.data.get(s.dataId).values;for(let A=0;A<c;++A){let G=s.shape[0]===1?P:P.subarray(A*8,A*8+8);for(let J=0;J<b;++J)for(let ee=0;ee<v;++ee)for(let W=0;W<g;++W){let X,Q=G[6]*ee+G[7]*J+1;if(Q===0)continue;let ce=(G[0]*ee+G[1]*J+G[2])/Q,L=(G[3]*ee+G[4]*J+G[5])/Q,q=$E(ce,m,o),le=$E(L,f,o);switch(i){case"nearest":X=Ose(V,f,m,S,N,T,A,le,q,W,u);break;case"bilinear":X=zse(V,f,m,S,N,T,A,le,q,W,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let se=A*R+J*M+ee*F+W;B[se]=X}return n.makeTensorInfo(x,r.dtype,B)}return{dataId:n.write(B,x,r.dtype),shape:r.shape,dtype:r.dtype}}var $se={kernelName:qh,backendName:"cpu",kernelFunc:Ase};function $E(e,t,a){switch(a){case"reflect":return Rse(e,t);case"wrap":return Dse(e,t);case"nearest":return Fse(e,t);case"constant":default:return Mse(e)}}function Rse(e,t){let a=e;if(a<0)if(t<=1)a=0;else{let n=2*t;a<n&&(a=n*Math.trunc(-a/n)+a),a=a<-t?a+n:-a-1}else if(a>t-1)if(t<=1)a=0;else{let n=2*t;a-=n*Math.trunc(a/n),a>=t&&(a=n-a-1)}return C.clamp(0,a,t-1)}function Dse(e,t){let a=e;if(a<0)if(t<=1)a=0;else{let n=t-1;a+=t*(Math.trunc(-a/n)+1)}else if(a>t-1)if(t<=1)a=0;else{let n=t-1;a-=t*Math.trunc(a/n)}return C.clamp(0,a,t-1)}function Mse(e,t){return e}function Fse(e,t){return C.clamp(0,e,t-1)}function $f(e,t,a,n,r,s,i,o,u,d,c){let f=i*n+o*r+u*s+d;return 0<=o&&o<t&&0<=u&&u<a?e[f]:c}function Ose(e,t,a,n,r,s,i,o,u,d,c){let f=Math.round(o),m=Math.round(u);return $f(e,t,a,n,r,s,i,f,m,d,c)}function zse(e,t,a,n,r,s,i,o,u,d,c){let f=Math.floor(o),m=Math.floor(u),g=f+1,b=m+1,v=(b-u)*$f(e,t,a,n,r,s,i,f,m,d,c)+(u-m)*$f(e,t,a,n,r,s,i,f,b,d,c),x=(b-u)*$f(e,t,a,n,r,s,i,g,m,d,c)+(u-m)*$f(e,t,a,n,r,s,i,g,b,d,c);return(g-o)*v+(o-f)*x}function Lse(e){let{inputs:t,attrs:a,backend:n}=e,{axis:r}=a,{x:s}=t;Be(s,"unique");let i=n.data.get(s.dataId).values,{outputValues:o,outputShape:u,indices:d}=aI(i,r,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,o),n.makeTensorInfo([d.length],"int32",d)]}var Bse={kernelName:Em,backendName:"cpu",kernelFunc:Lse};function Use(e){let{inputs:t,backend:a,attrs:n}=e,{value:r}=t,{axis:s}=n;s<0&&(s+=r.shape.length);let i=r.shape.length,o=r.shape[s],u=new Array(i-1),d=0;for(let g=0;g<i;g++)g!==s&&(u[d++]=r.shape[g]);let c=new Array(i).fill(0),f=r.shape.slice();f[s]=1;let m=new Array(o);for(let g=0;g<m.length;g++){c[s]=g;let b=Jl({inputs:{x:r},backend:a,attrs:{begin:c,size:f}});m[g]=aa({inputs:{x:b},backend:a,attrs:{shape:u}}),a.disposeIntermediateTensorInfo(b)}return m}var Pse={kernelName:jh,backendName:"cpu",kernelFunc:Use};function Wse(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,segmentIds:s}=t,{numSegments:i}=n;Be(r,"unsortedSegmentSum");let o=r.shape.length,u=s.shape.length,d=[],c=[],f=o-u,m=s;for(let b=0;b<f;++b){let v=fb({inputs:{input:m},backend:a,attrs:{dim:b+1}});m=v,c.push(v)}for(let b=0;b<i;++b){let v=C.createScalarValue(b,"int32"),x=a.makeTensorInfo([],"int32",v),k=gF({inputs:{a:x,b:m},backend:a}),S=Ro({inputs:{x:k},backend:a,attrs:{dtype:"float32"}}),N=Gv({inputs:{a:S,b:r},backend:a}),T=sg({inputs:{x:N},backend:a,attrs:{axis:0,keepDims:!1}});d.push(T),c.push(x),c.push(k),c.push(S),c.push(N),c.push(T)}let g=cO({inputs:d,backend:a,attrs:{axis:0}});return c.forEach(b=>a.disposeIntermediateTensorInfo(b)),g}var Vse={kernelName:Am,backendName:"cpu",kernelFunc:Wse},Gse=[zee,gJ,Bee,Pee,kJ,Vee,Hee,jee,Xee,Zee,Jee,tte,nte,ite,lte,dte,pte,mte,yte,Fee,vte,wte,Ste,IJ,Nte,xJ,TJ,_te,yJ,Ete,$te,Rte,Mte,Ote,Lte,Ute,Wte,Gte,qte,Kte,Yte,Qte,eae,aae,nae,sae,oae,uae,cae,dae,hae,fae,yae,Cee,vae,_J,_ae,CJ,Cae,AJ,Mae,Fae,zae,RJ,MJ,Bae,Pae,Vae,Hae,OJ,LJ,bJ,jae,Ate,Xae,Zae,Jae,Eee,UJ,WJ,tne,GJ,nne,ine,lne,dne,pne,mne,gne,qJ,bne,xne,kne,Ine,Tne,Cne,Ane,KJ,Rne,Fne,Bne,YJ,QJ,Wne,Hne,Kne,eee,Yne,Qne,Jne,dO,nre,$ee,nee,sre,ore,ure,dre,vJ,d1,pre,Ree,Dee,Mee,mre,yre,vre,wre,Sre,Ire,Tre,hee,Cre,Dre,Fre,Bre,fee,Pre,Vre,Hre,mee,zne,Kre,Yre,Qre,ese,ase,rse,ise,lse,bee,use,xee,kee,dse,pse,mse,yse,vse,Tee,mae,wse,Sse,Nse,_se,Ese,$se,tee,Bse,Pse,Vse,Zne];for(let e of Gse)$m(e);var hO={};rt(hO,{assertNotComplex:()=>lp,bindCanvasToFramebuffer:()=>tie,bindColorTextureToFramebuffer:()=>Py,bindTextureToProgramUniformSampler:()=>CO,bindTextureUnit:()=>NO,bindVertexBufferToProgramAttribute:()=>p1,callAndCheck:()=>Ae,canBeRepresented:()=>fO,createFragmentShader:()=>yO,createFramebuffer:()=>IO,createProgram:()=>bO,createStaticIndexBuffer:()=>wO,createStaticVertexBuffer:()=>xO,createTexture:()=>kO,createVertexShader:()=>gO,getBatchDim:()=>eu,getExtensionOrThrow:()=>Rf,getFramebufferErrorMessage:()=>EO,getMaxTexturesInShader:()=>DO,getNumChannels:()=>Jse,getProgramUniformLocation:()=>_O,getProgramUniformLocationOrThrow:()=>TO,getRowsCols:()=>tu,getShapeAs3D:()=>Mf,getTextureShapeFromLogicalShape:()=>$O,getWebGLDisjointQueryTimerVersion:()=>MO,getWebGLErrorMessage:()=>mO,getWebGLMaxTextureSize:()=>RO,hasExtension:()=>kr,isCapableOfRenderingToFloatTexture:()=>FO,isDownloadFloatTextureEnabled:()=>OO,isReshapeFree:()=>tm,isWebGLFenceEnabled:()=>zO,isWebGLVersionEnabled:()=>m1,linkProgram:()=>vO,logShaderSourceAndInfoLog:()=>oI,resetMaxTextureSize:()=>aie,resetMaxTexturesInShader:()=>nie,unbindColorTextureFromFramebuffer:()=>f1,unbindTextureUnit:()=>eie,validateFramebuffer:()=>Df,validateProgram:()=>Uy,validateTextureSize:()=>SO});var $l={},Ay={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function pO(e,t){$l[e]=t}function fs(e,t){if(!(e in $l)||t!=null){let n=qse(e,t);if(n!==null)$l[e]=n;else return console.log("Could not get context for WebGL version",e),null}let a=$l[e];return a==null||a.isContextLost()?(delete $l[e],fs(e)):(a.disable(a.DEPTH_TEST),a.disable(a.STENCIL_TEST),a.disable(a.BLEND),a.disable(a.DITHER),a.disable(a.POLYGON_OFFSET_FILL),a.disable(a.SAMPLE_COVERAGE),a.enable(a.SCISSOR_TEST),a.enable(a.CULL_FACE),a.cullFace(a.BACK),$l[e])}function Hse(e){if(!ie().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function qse(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let a=t??Hse(e);return a.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete $l[e]},!1),ie().getBool("SOFTWARE_WEBGL_ENABLED")&&(Ay.failIfMajorPerformanceCaveat=!1),e===1?a.getContext("webgl",Ay)||a.getContext("experimental-webgl",Ay):a.getContext("webgl2",Ay)}var em;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(em||(em={}));var wr;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(wr||(wr={}));var cn;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(cn||(cn={}));function ig(e,t){return[t,e]}function jse(e,t){return e*t}function $y(e){let t=C.sizeFromShape(e),a=Math.ceil(t/4);return C.sizeToSquarishShape(a)}function op(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function Kse(e,t){let[a,n]=op(e,t);return a*n*4}function iI(e,t){let a=e,n,r,s,i,o,u,d,c,f,m;return ie().getNumber("WEBGL_VERSION")===2?(n=a.R32F,r=a.R16F,s=a.RGBA16F,i=a.RGBA32F,o=a.RED,d=4,c=1,f=a.HALF_FLOAT,m=a.FLOAT,u=a.RGBA8):(n=e.RGBA,r=e.RGBA,s=e.RGBA,i=a.RGBA,o=e.RGBA,d=4,c=4,f=t!=null?t.HALF_FLOAT_OES:null,m=e.FLOAT,u=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:d,defaultNumChannels:c,textureTypeHalfFloat:f,textureTypeFloat:m}}function Ae(e,t){let a=t();return ie().getBool("DEBUG")&&Xse(e),a}function Xse(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+mO(e,t))}var Yse=596e-10,Zse=65504;function fO(e){return!!(ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||Yse<Math.abs(e)&&Math.abs(e)<Zse)}function mO(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function Rf(e,t){return Ai(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function gO(e,t){let a=Ai(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ae(e,()=>e.shaderSource(a,t)),Ae(e,()=>e.compileShader(a)),e.getShaderParameter(a,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(a)),new Error("Failed to compile vertex shader.");return a}function yO(e,t){let a=Ai(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ae(e,()=>e.shaderSource(a,t)),Ae(e,()=>e.compileShader(a)),ie().get("ENGINE_COMPILE_ONLY"))return a;if(e.getShaderParameter(a,e.COMPILE_STATUS)===!1)throw oI(t,e.getShaderInfoLog(a)),new Error("Failed to compile fragment shader.");return a}var Qse=/ERROR: [0-9]+:([0-9]+):/g;function oI(e,t){let a=Qse.exec(t);if(a==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let n=+a[1],r=e.split(`
`),s=r.length.toString().length+2,i=r.map((f,m)=>C.rightPad((m+1).toString(),s)+f),o=0;for(let f=0;f<i.length;f++)o=Math.max(i[f].length,o);let u=i.slice(0,n-1),d=i.slice(n-1,n),c=i.slice(n);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${C.rightPad(d[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function bO(e){return Ai(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function vO(e,t){if(Ae(e,()=>e.linkProgram(t)),!ie().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Uy(e,t){if(Ae(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function xO(e,t){let a=Ai(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Ae(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),Ae(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),a}function wO(e,t){let a=Ai(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return Ae(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,a)),Ae(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),a}function Jse(){return ie().getNumber("WEBGL_VERSION")===2?1:4}function kO(e){return Ai(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function SO(e,t){let a=ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>a||t>a){let n=`[${e}x${t}]`,r=`[${a}x${a}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+r+".")}}function IO(e){return Ai(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function p1(e,t,a,n,r,s,i){let o=e.getAttribLocation(t,a);return o===-1?!1:(Ae(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),Ae(e,()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,s,i)),Ae(e,()=>e.enableVertexAttribArray(o)),!0)}function NO(e,t,a){AO(e,a),Ae(e,()=>e.activeTexture(e.TEXTURE0+a)),Ae(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function eie(e,t){AO(e,t),Ae(e,()=>e.activeTexture(e.TEXTURE0+t)),Ae(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function TO(e,t,a){return Ai(e,()=>e.getUniformLocation(t,a),'uniform "'+a+'" not present in program.')}function _O(e,t,a){return e.getUniformLocation(t,a)}function CO(e,t,a,n){Ae(e,()=>NO(e,t,n)),Ae(e,()=>e.uniform1i(a,n))}function tie(e){Ae(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ae(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),Ae(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function Py(e,t,a){Ae(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,a)),Ae(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function f1(e,t){Ae(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),Ae(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Df(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+EO(e,t))}function EO(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Ai(e,t,a){let n=Ae(e,()=>t());if(n==null)throw new Error(a);return n}function AO(e,t){let a=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+e.TEXTURE0;if(n<e.TEXTURE0||n>a){let r=`[gl.TEXTURE0, gl.TEXTURE${a}]`;throw new Error(`textureUnit must be in ${r}.`)}}function eu(e,t=2){return C.sizeFromShape(e.slice(0,e.length-t))}function tu(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Mf(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[eu(e),...tu(e)]),t}function $O(e,t=!1){let a=ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=a/2),t&&(a=a*2,n=n*2,e=e.map((o,u)=>u>=e.length-2?C.nearestLargerEven(e[u]):e[u]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=C.squeezeShape(e).newShape);let r=C.sizeFromShape(e),s=null;e.length<=1&&r<=a?s=[1,r]:e.length===2&&e[0]<=a&&e[1]<=a?s=e:e.length===3&&e[0]*e[1]<=a&&e[2]<=a?s=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=a&&e[1]*e[2]<=a?s=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=a&&e[3]<=a?s=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=a&&e[1]*e[2]*e[3]<=a&&(s=[e[0],e[1]*e[2]*e[3]]);let i=s!=null&&Math.max(...s)>n&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||i)if(t){let o=eu(e),u=2,d=2;e.length&&([u,d]=tu(e)),r=o*(u/2)*(d/2),s=C.sizeToSquarishShape(r).map(c=>c*2)}else s=C.sizeToSquarishShape(r);return s}function Ry(e){return e%2===0}function tm(e,t){if(e=e.slice(-2),t=t.slice(-2),C.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let a=e[e.length-1],n=t[t.length-1];if(a===n||Ry(a)&&Ry(n)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Ry(e[0])&&Ry(t[0])}var Wy,Vy;function RO(e){if(Wy==null){let t=fs(e);Wy=t.getParameter(t.MAX_TEXTURE_SIZE)}return Wy}function aie(){Wy=null}function nie(){Vy=null}function DO(e){if(Vy==null){let t=fs(e);Vy=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Vy)}function MO(e){if(e===0)return 0;let t,a=fs(e);return kr(a,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:kr(a,"EXT_disjoint_timer_query")?t=1:t=0,t}function kr(e,t){return e.getExtension(t)!=null}function m1(e){try{if(fs(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function FO(e){if(e===0)return!1;let t=fs(e);if(e===1){if(!kr(t,"OES_texture_float"))return!1}else if(!kr(t,"EXT_color_buffer_float"))return!1;return g1(t)}function OO(e){if(e===0)return!1;let t=fs(e);if(e===1){if(!kr(t,"OES_texture_float")||!kr(t,"WEBGL_color_buffer_float"))return!1}else{if(kr(t,"EXT_color_buffer_float"))return g1(t);let a="EXT_color_buffer_half_float";if(kr(t,a)){let n=t.getExtension(a);return rie(t,n)}return!1}return g1(t)}function g1(e){let t=iI(e),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);let r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(n),r}function rie(e,t){let a=iI(e,t),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,a.internalFormatHalfFloat,1,1,0,a.textureFormatFloat,a.textureTypeHalfFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function zO(e){return e!==2?!1:fs(e).fenceSync!=null}function lp(e,t){Array.isArray(e)||(e=[e]),e.forEach(a=>{a!=null&&C.assert(a.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Pe=ie();Pe.registerFlag("HAS_WEBGL",()=>Pe.getNumber("WEBGL_VERSION")>0);Pe.registerFlag("WEBGL_VERSION",()=>m1(2)?2:m1(1)?1:0);Pe.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Pe.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Pe.get("WEBGL_VERSION")===2);Pe.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Pe.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Pe.registerFlag("WEBGL_PACK",()=>Pe.getBool("HAS_WEBGL"));Pe.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_PACK_CLIP",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_PACK_REDUCE",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_LAZILY_UNPACK",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_CONV_IM2COL",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Pe.getBool("WEBGL_PACK"));Pe.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>RO(Pe.getNumber("WEBGL_VERSION")));Pe.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>DO(Pe.getNumber("WEBGL_VERSION")));Pe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=Pe.getNumber("WEBGL_VERSION");return e===0?0:MO(e)});Pe.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Pe.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Mm.isMobile());Pe.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>FO(Pe.getNumber("WEBGL_VERSION")));Pe.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Pe.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Pe.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Pe.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>OO(Pe.getNumber("WEBGL_VERSION")));Pe.registerFlag("WEBGL_FENCE_API_ENABLED",()=>zO(Pe.getNumber("WEBGL_VERSION")));Pe.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Pe.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Pe.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});Pe.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Mm.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});Pe.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Pe.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Pe.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Pe.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Pe.registerFlag("WEBGL_EXP_CONV",()=>!1);Pe.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Pe.getBool("IS_TEST"));Pe.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Pe.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Pe.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Pe.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function Mn(){let e,t,a,n,r,s,i,o,u,d;return ie().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",a="out",n="in",r="texture",s="outputColor",i="out vec4 outputColor;",o=ie().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",d=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",a="varying",n="varying",r="texture2D",s="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,d=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:a,varyingFs:n,texture2D:r,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:d}}function $c(e,t,a="index"){let n=C.computeStrides(t);return n.map((r,s)=>{let i=`int ${e[s]} = ${a} / ${r}`,o=s===n.length-1?`int ${e[s+1]} = ${a} - ${e[s]} * ${r}`:`index -= ${e[s]} * ${r}`;return`${i}; ${o};`}).join("")}function Hv(e,t,a="index"){let n=C.computeStrides(t);return n.map((r,s)=>{let i=`int ${e[s]} = ${a} / outShapeStrides[${s}]`,o=s===n.length-1?`int ${e[s+1]} = ${a} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`;return`${i}; ${o};`}).join("")}function sie(e,t){let a=e.length,n=e.map(s=>`${t}[${s}]`),r=new Array(a-1);r[a-2]=n[a-1];for(let s=a-3;s>=0;--s)r[s]=`(${r[s+1]} * ${n[s+1]})`;return r}function iie(e,t,a="index"){let n=e.map((s,i)=>i),r=sie(n,t);return r.map((s,i)=>{let o=`int ${e[i]} = ${a} / ${r[i]}`,u=i===r.length-1?`int ${e[i+1]} = ${a} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`;return`${o}; ${u};`}).join("")}function lI(e){let t=C.computeStrides(e).map(a=>a.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function uI(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var LO=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:BO}=D;function oie(e,t,a){let n=[];if(e.forEach(m=>{let g=C.sizeFromShape(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?n.push(`uniform float ${m.name}${g>1?`[${g}]`:""};`):(n.push(`uniform sampler2D ${m.name};`),n.push(`uniform int offset${m.name};`)),a.enableShapeUniforms){let{uniformShape:b}=cI(a.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(b.length){case 1:n.push(`uniform int ${m.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${m.name}Shape;`);break}n.push(`uniform ivec2 ${m.name}TexShape;`)}}),a.enableShapeUniforms){switch(t.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break}n.push("uniform ivec2 outTexShape;")}a.customUniforms&&a.customUniforms.forEach(m=>{n.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});let r=n.join(`
`),s=e.map(m=>lie(m,t,a.packedInputs,a.enableShapeUniforms)).join(`
`),i=t.texShape,o=Mn(),u=die(o),d,c,f=fie(o);return t.isPacked?(d=uie(t.logicalShape,i,a.enableShapeUniforms),c=pie(o)):(d=cie(t.logicalShape,i,a.enableShapeUniforms),c=hie(o)),a.packedInputs&&(f+=bie),[f,u,c,r,d,s,a.userCode].join(`
`)}function up(e,t=!1){let a=e.shapeInfo.logicalShape;switch(a.length){case 0:return Aie(e,t);case 1:return Rie(e,t);case 2:return Mie(e,t);case 3:return Oie(e,t);case 4:return Lie(e,t);case 5:return Bie(e);case 6:return Uie(e);default:throw new Error(`${a.length}-D input sampling is not yet supported`)}}function UO(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return Eie(e);case 1:return $ie(e,t);case 2:return Die(e,t);case 3:return Fie(e,t);default:return zie(e,t)}}function lie(e,t,a=!1,n){let r="";a?r+=UO(e,n):r+=up(e,n);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(a?r+=Pie(e,t):r+=Wie(e,t)),r}function uie(e,t,a){switch(e.length){case 0:return PO();case 1:return vie(e,t,a);case 2:return _ie(e,t,a);case 3:return wie(e,t,a);default:return Sie(e,t,a)}}function cie(e,t,a){switch(e.length){case 0:return PO();case 1:return xie(e,t,a);case 2:return Cie(e,t,a);case 3:return kie(e,t,a);case 4:return Iie(e,t,a);case 5:return Nie(e,t);case 6:return Tie(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function die(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function hie(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function pie(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function fie(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${mie}
    ${gie}
    ${yie}
  `}var mie=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,gie=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,yie=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,bie=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function PO(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function vie(e,t,a){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return n[0]===1?a?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?a?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:a?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function xie(e,t,a){return t[0]===1?a?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?a?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:a?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function wie(e,t,a){if(a)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function kie(e,t,a){if(a)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Hv(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let n=$c(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function Sie(e,t,a){if(a)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2),i=s,o="",u="b, r, c";for(let d=2;d<e.length-1;d++)i*=e[e.length-d-1],o=`
      int b${d} = index / ${i};
      index -= b${d} * ${i};
    `+o,u=`b${d}, `+u;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${e.length}(${u});
    }
  `}function Iie(e,t,a){if(a)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Hv(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let n=$c(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function Nie(e,t){let a=$c(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${a}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Tie(e,t){let a=$c(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${a}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function _ie(e,t,a){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(C.arraysEqual(e,t))return a?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let r=Math.ceil(e[1]/2);return a?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function Cie(e,t,a){return C.arraysEqual(e,t)?a?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?a?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?a?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:a?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Rc(e){return`offset${e}`}function Eie(e){let t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),n=Mn();return`
    vec4 ${a}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function Aie(e,t){let a=e.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${a};}`;let[r,s]=e.shapeInfo.texShape;if(r===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${a}, halfCR);
      }
    `;let i=Rc(a);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], ${i});
      return sampleTexture(${a}, uv);
    }
  `;let[o,u]=e.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${o}, ${u}, ${i});
      return sampleTexture(${a}, uv);
    }
  `}function $ie(e,t){let a=e.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1),r=e.shapeInfo.texShape,s=Mn();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${a}, uv);
    }
  `;let i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${a}, uv);
    }
  `}function Rie(e,t){let a=e.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1);if(e.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${cp(e)}
      }
    `;let r=e.shapeInfo.texShape,s=r[0],i=r[1];if(i===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${a}, halfCR);
      }
    `;let o=Rc(a);return i===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${a}TexShape[0]));
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${a}, uv);
      }
    `:s===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${a}TexShape[1]), 0.5);
        return sampleTexture(${a}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${a}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${a}TexShape[0], ${a}TexShape[1], index + ${o});
      return sampleTexture(${a}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});
      return sampleTexture(${a}, uv);
    }
  `}function Die(e,t){let a=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],u=Mn();if(s!=null&&C.arraysEqual(a,s))return t?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let d=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(a[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${d[0]}, ${d[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function Mie(e,t){let a=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape;if(s!=null&&C.arraysEqual(a,s)){if(t)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let m=s[0],g=s[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${g}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:i,keptDims:o}=C.squeezeShape(a),u=i;if(u.length<a.length){let m=dp(e,u),g=["row","col"];return`
      ${up(m,t)}
      float ${r}(int row, int col) {
        return ${r}(${hp(g,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${a[1]}, 1)));
        ${cp(e)}
      }
    `;let d=s[0],c=s[1],f=Rc(n);return c===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${a[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
      return sampleTexture(${n}, uv);
    }
  `:d===1?t?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${a[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:t?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${a[1]} + col + ${f};
    vec2 uv = uvFromFlat(${d}, ${c}, index);
    return sampleTexture(${n}, uv);
  }
`}function Fie(e,t){let a=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(a[0]===1){let m=a.slice(1),g=[1,2],b=dp(e,m),v=["b","row","col"];return`
        ${UO(b,t)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${hp(v,g)});
        }
      `}let o=Mn();if(t)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${n}, uv);
    }
  `;let u=i[0],d=i[1],c=Math.ceil(a[2]/2),f=c*Math.ceil(a[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${d}, ${f}, ${c}, b, row, col);
      return ${o.texture2D}(${n}, uv);
    }
  `}function Oie(e,t){let a=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=a[1]*a[2],i=a[2],{newShape:o,keptDims:u}=C.squeezeShape(a),d=o;if(d.length<a.length){let v=dp(e,d),x=["row","col","depth"];return`
        ${up(v,t)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${hp(x,u)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${cp(e)}
      }
    `;let c=e.shapeInfo.texShape,f=c[0],m=c[1],g=e.shapeInfo.flatOffset;if(m===s&&g==null)return t?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${f}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(m===i&&g==null)return t?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${a[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${n}, uv);
    }
  `;let b=Rc(n);return t?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${b};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${b};
        vec2 uv = uvFromFlat(${f}, ${m}, index);
        return sampleTexture(${n}, uv);
      }
  `}function zie(e,t){let a=e.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1),r=Mn();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${a}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${a}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${a}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${a}TexShape[0]) / 2.0), ceil(float(${a}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${a}, uv);
    }
  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],d=u[0],c=u[1],f=Math.ceil(s[i-1]/2),m=f*Math.ceil(s[i-2]/2),g="int b, int row, int col",b=`b * ${m} + (row / 2) * ${f} + (col / 2)`;for(let v=2;v<i-1;v++)g=`int b${v}, `+g,m*=s[i-v-1],b=`b${v} * ${m} + `+b;return`
    vec4 ${n}(${g}) {
      int index = ${b};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${d});
      return ${r.texture2D}(${a}, uv);
    }
  `}function Lie(e,t){let a=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=a[3],i=a[2]*s,o=a[1]*i,{newShape:u,keptDims:d}=C.squeezeShape(a);if(u.length<a.length){let S=dp(e,u),N=["row","col","depth","depth2"];return`
      ${up(S,t)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${hp(N,d)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${s}, 1)));
        ${cp(e)}
      }
    `;let c=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,m=f[0],g=f[1],b=`int stride2 = ${n}Shape[3];`,v=`int stride1 = ${n}Shape[2] * stride2;`,x=`int stride0 = ${n}Shape[1] * stride1;`;if(g===o&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${b}
        ${v}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(g===s&&c==null)return t?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${a[1]*a[2]}, ${a[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let k=Rc(n);return t?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${b}
      ${v}
      ${x}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${k});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${g}, index + ${k});
      return sampleTexture(${n}, uv);
    }
  `}function Bie(e){let t=e.shapeInfo.logicalShape,a=e.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1),r=t[4],s=t[3]*r,i=t[2]*s,o=t[1]*i,{newShape:u,keptDims:d}=C.squeezeShape(t);if(u.length<t.length){let v=dp(e,u),x=["row","col","depth","depth2","depth3"];return`
      ${up(v)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${hp(x,d)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${s}, ${r})) +
          depth3;
        ${cp(e)}
      }
    `;let c=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,m=f[0],g=f[1];if(g===o&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${m}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(g===r&&c==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${m}.0);
        return sampleTexture(${a}, uv);
      }
    `;let b=Rc(a);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${s} +
          depth2 * ${r} + depth3 + ${b};
      vec2 uv = uvFromFlat(${m}, ${g}, index);
      return sampleTexture(${a}, uv);
    }
  `}function Uie(e){let t=e.shapeInfo.logicalShape,a=e.name,n="get"+a.charAt(0).toUpperCase()+a.slice(1),{newShape:r,keptDims:s}=C.squeezeShape(t);if(r.length<t.length){let x=dp(e,r),k=["row","col","depth","depth2","depth3","depth4"];return`
      ${up(x)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${hp(k,s)});
      }
    `}let i=t[5],o=t[4]*i,u=t[3]*o,d=t[2]*u,c=t[1]*d;if(e.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${d}, ${u}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${cp(e)}
      }
    `;let f=e.shapeInfo.flatOffset,m=e.shapeInfo.texShape,g=m[0],b=m[1];if(b===c&&f==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${d}, ${u}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${b}.0, ${g}.0);
        return sampleTexture(${a}, uv);
      }
    `;if(b===i&&f==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${b}.0, ${g}.0);
        return sampleTexture(${a}, uv);
      }
    `;let v=Rc(a);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${d} + depth * ${u} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${v};
      vec2 uv = uvFromFlat(${g}, ${b}, index);
      return sampleTexture(${a}, uv);
    }
  `}function cp(e){let t=e.name,a=C.sizeFromShape(e.shapeInfo.logicalShape);return a<2?`return ${t};`:`
    for (int i = 0; i < ${a}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Pie(e,t){let a=e.name,n=a.charAt(0).toUpperCase()+a.slice(1),r="get"+n+"AtOutCoords",s=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=BO(e.shapeInfo.logicalShape,t.logicalShape),u=qt(i),d=i-s,c,f=["x","y","z","w","u","v"];s===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(x=>`coords.${f[x+d]} = 0;`).join(`
`);let m="";i<2&&s>0?m="coords":m=e.shapeInfo.logicalShape.map((x,k)=>`coords.${f[k+d]}`).join(", ");let g="return outputValue;",b=C.sizeFromShape(e.shapeInfo.logicalShape)===1,v=C.sizeFromShape(t.logicalShape)===1;if(s===1&&!b&&!v)g=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(b&&!v)i===1?g=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:g=`
        return vec4(outputValue.x);
      `;else if(o.length){let x=s-2,k=s-1;o.indexOf(x)>-1&&o.indexOf(k)>-1?g="return vec4(outputValue.x);":o.indexOf(x)>-1?g="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(k)>-1&&(g="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${n}(${m});
      ${g}
    }
  `}function Wie(e,t){let a=e.name,n=a.charAt(0).toUpperCase()+a.slice(1),r="get"+n+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===u&&e.shapeInfo.flatOffset==null&&C.arraysEqual(i,s))return`
      float ${r}() {
        return sampleTexture(${a}, resultUV);
      }
    `;let d=qt(u),c=BO(e.shapeInfo.logicalShape,t.logicalShape),f=u-o,m,g=["x","y","z","w","u","v"];o===0?m="":u<2&&c.length>=1?m="coords = 0;":m=c.map(v=>`coords.${g[v+f]} = 0;`).join(`
`);let b="";return u<2&&o>0?b="coords":b=e.shapeInfo.logicalShape.map((v,x)=>`coords.${g[x+f]}`).join(", "),`
    float ${r}() {
      ${d} coords = getOutputCoords();
      ${m}
      return get${n}(${b});
    }
  `}function qt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function cI(e,t,a){let{newShape:n,keptDims:r}=C.squeezeShape(t),s=t.length,i=e&&s===3&&t[0]===1,o=i?t.slice(1):n,u=!e&&s>1&&!C.arraysEqual(t,a)&&n.length<s||i;return{useSqueezeShape:u,uniformShape:u?o:t,keptDims:r}}function dp(e,t){let a=JSON.parse(JSON.stringify(e));return a.shapeInfo.logicalShape=t,a}function hp(e,t){return t.map(a=>e[a]).join(", ")}function Vie(e,t,a,n){let r=a.map((c,f)=>{let m={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(m.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[f],shapeInfo:m}}),s=r.map(c=>c.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},o=oie(r,i,t),u=yO(e.gl,o),d=e.createProgram(u);return ie().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:o,webGLProgram:d,inShapeInfos:s,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(d),Object.assign({program:t,fragmentShader:u,source:o,webGLProgram:d,inShapeInfos:s,outShapeInfo:i},WO(e,t,d)))}function WO(e,t,a){let n=[],r=[],s,i,o,u=null,d=null;d=e.getUniformLocation(a,"NAN",!1),ie().getNumber("WEBGL_VERSION")===1&&(u=e.getUniformLocation(a,"INFINITY",!1));let c=!1;for(let f of t.variableNames){let m={name:f,uniform:e.getUniformLocation(a,f,c),offset:e.getUniformLocation(a,`offset${f}`,c)};t.enableShapeUniforms&&(m.shape=e.getUniformLocation(a,`${f}Shape`,c),m.texShape=e.getUniformLocation(a,`${f}TexShape`,c)),n.push(m)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(a,"outShape",c),o=e.getUniformLocation(a,"outShapeStrides",c),i=e.getUniformLocation(a,"outTexShape",c)),t.customUniforms)for(let f of t.customUniforms)r.push(e.getUniformLocation(a,f.name,c));return{variablesLocations:n,customUniformLocations:r,infLoc:u,nanLoc:d,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}}function RE(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((a,n)=>{let r=a.logicalShape,s=t[n],i=s.shape;if(!C.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(a.isUniform&&s.isUniform)return;let o=a.texShape,u=s.isUniform?null:s.texData.texShape;if(!C.arraysEqual(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function Gie(e,t,a,n,r){t.program.enableShapeUniforms||(RE(t.inShapeInfos,a),RE([t.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),ie().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<a.length;++u){let d=a[u],{uniform:c,offset:f,shape:m,texShape:g}=t.variablesLocations[u];if(m){let{uniformShape:b}=cI(t.program.packedInputs,d.shape,d.texData.texShape);switch(b.length){case 1:e.gl.uniform1iv(m,new Int32Array(b));break;case 2:e.gl.uniform2iv(m,new Int32Array(b));break;case 3:e.gl.uniform3iv(m,new Int32Array(b));break;case 4:e.gl.uniform4iv(m,new Int32Array(b));break}}if(g&&e.gl.uniform2i(g,d.texData.texShape[0],d.texData.texShape[1]),c!=null){if(d.isUniform){if(C.sizeFromShape(d.shape)<2)e.gl.uniform1f(c,d.uniformValues[0]);else{let b=d.uniformValues;b instanceof Float32Array||(b=new Float32Array(b)),e.gl.uniform1fv(c,b)}continue}d.texData.slice!=null&&f!=null&&e.gl.uniform1i(f,d.texData.slice.flatOffset),e.setInputMatrixTexture(d.texData.texture.texture,c,u)}}let o=t.outShapeLocation;if(o)switch(n.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(n.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(n.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(n.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(n.shape));break}if(t.outShapeStridesLocation){let u=C.computeStrides(n.shape);switch(n.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&r)for(let u=0;u<t.program.customUniforms.length;++u){let d=t.program.customUniforms[u],c=t.customUniformLocations[u],f=r[u];if(d.type==="float")e.gl.uniform1fv(c,f);else if(d.type==="vec2")e.gl.uniform2fv(c,f);else if(d.type==="vec3")e.gl.uniform3fv(c,f);else if(d.type==="vec4")e.gl.uniform4fv(c,f);else if(d.type==="int")e.gl.uniform1iv(c,f);else if(d.type==="ivec2")e.gl.uniform2iv(c,f);else if(d.type==="ivec3")e.gl.uniform3iv(c,f);else if(d.type==="ivec4")e.gl.uniform4iv(c,f);else throw Error(`uniform type ${d.type} is not supported yet.`)}e.executeProgram()}function Hie(e,t,a){let n="";t.concat(a).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:d,uniformShape:c,keptDims:f}=cI(e.packedInputs,i.shape,u),m="",g="",b="";if(c.length===1&&e.packedInputs){let _=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${_[0]>1}_${_[1]>1}`}else if(c.length===2&&!e.packedInputs)g=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let _=C.computeStrides(c);b=`${_[0]===u[1]}_${_[_.length-1]===u[1]}`}let v=i.shape.length,x=c.length===2&&C.arraysEqual(i.shape,u),k=C.sizeFromShape(i.shape)===1,S=D.getBroadcastDims(i.shape,a.shape),N=!e.packedInputs&&v===a.shape.length&&C.arraysEqual(u,a.texData.texShape),T=e.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${v}_${N}_${d?f:""}_${c.length}_${k}_${S}_${x}_${m}_${g}_${b}_${T}_${o}`}else{let u=i.isUniform?"uniform":i.texData.texShape;n+=`${i.shape}_${u}_${o}`}});let r=e.userCode,s=e.constructor.name;return s+="_"+n+"_"+r+`${ie().getNumber("WEBGL_VERSION")}`,s}function xn(e){return ie().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var qie=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=em.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Mn();this.outputShape=e,this.enableShapeUniforms=xn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Hv(["r","c","d"],e):$c(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},jie=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=em.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Mn();this.outputShape=e,this.enableShapeUniforms=xn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Hv(["r","c","d"],e):$c(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},Kie=class{constructor(e){this.variableNames=["A"],this.outTexUsage=wr.DOWNLOAD;let t=Mn();this.outputShape=e,this.userCode=`
      ${LO}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},Xie=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=wr.DOWNLOAD;let t=Mn();this.outputShape=e,this.userCode=`
      ${LO}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},Yie={R:0,G:1,B:2,A:3},DE=class{constructor(e,t=!1,a="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Mn();this.outputShape=e,this.enableShapeUniforms=xn(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let s="";for(let i=0;i<a.length;i++){let o=a[i];s+=`
          if(offset == ${i}) {
            result = values[${Yie[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?uI():lI(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${a.length});

        flatIndex = idiv(flatIndex, ${a.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${n.texture2D}(A, uv);
          ${s}
        }
        ${n.output} = vec4(${r}, 0., 0., 0.);
      }
    `}},Zie=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let a=Mn();this.outputShape=e,this.enableShapeUniforms=xn(this.outputShape.length);let n="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let o=s*2+i;n+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${s};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${a.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?uI():lI(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${n}

          ${a.output} = ${r};
        }
    `}},VO={};rt(VO,{bindVertexProgramAttributeStreams:()=>QO,createBufferFromOutputTexture:()=>t3,createFloat16MatrixTexture:()=>KO,createFloat16PackedMatrixTexture:()=>ZO,createFloat32MatrixTexture:()=>jO,createIndexBuffer:()=>qO,createPackedMatrixTexture:()=>YO,createUnsignedBytesMatrixTexture:()=>XO,createVertexBuffer:()=>HO,createVertexShader:()=>GO,downloadByteEncodedFloatMatrixFromOutputTexture:()=>n3,downloadFloat32MatrixFromBuffer:()=>a3,downloadMatrixFromPackedOutputTexture:()=>s3,downloadPackedMatrixFromBuffer:()=>r3,getInternalFormatForFloat16MatrixTexture:()=>hI,getInternalFormatForFloat16PackedMatrixTexture:()=>mI,getInternalFormatForFloat32MatrixTexture:()=>dI,getInternalFormatForPackedMatrixTexture:()=>fI,getInternalFormatForUnsignedBytesMatrixTexture:()=>pI,uploadDenseMatrixToTexture:()=>JO,uploadPixelDataToTexture:()=>e3});function GO(e){let t=Mn(),a=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return gO(e,a)}function HO(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return xO(e,t)}function qO(e){let t=new Uint16Array([0,1,2,2,1,3]);return wO(e,t)}function og(e,t,a,n,r,s){SO(t,a);let i=kO(e),o=e.TEXTURE_2D;return Ae(e,()=>e.bindTexture(o,i)),Ae(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),Ae(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),Ae(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),Ae(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),ie().getNumber("WEBGL_VERSION")===1?Ae(e,()=>e.texImage2D(o,0,n,t,a,0,r,s,null)):Ae(e,()=>e.texStorage2D(o,1,n,t,a)),Ae(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[a,t]}}function dI(e){return e.internalFormatFloat}function jO(e,t,a,n){let[r,s]=ig(t,a);return og(e,r,s,dI(n),n.textureFormatFloat,e.FLOAT)}function hI(e){return e.internalFormatHalfFloat}function KO(e,t,a,n){let[r,s]=ig(t,a);return og(e,r,s,hI(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function pI(e){return e.downloadTextureFormat}function XO(e,t,a,n){let[r,s]=ig(t,a);return og(e,r,s,pI(n),e.RGBA,e.UNSIGNED_BYTE)}function fI(e){return e.internalFormatPackedFloat}function YO(e,t,a,n){let[r,s]=op(t,a);return og(e,r,s,fI(n),e.RGBA,e.FLOAT)}function mI(e){return e.internalFormatPackedHalfFloat}function ZO(e,t,a,n){let[r,s]=op(t,a);return og(e,r,s,mI(n),e.RGBA,n.textureTypeHalfFloat)}function QO(e,t,a){return Ae(e,()=>e.bindBuffer(e.ARRAY_BUFFER,a)),p1(e,t,"clipSpacePos",a,3,20,0)&&p1(e,t,"uv",a,2,20,12)}function JO(e,t,a,n,r,s){Ae(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,u;r instanceof Uint8Array?(i=new Uint8Array(a*n*4),o=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(a*n*4),o=e.FLOAT,u=s.internalFormatPackedFloat),i.set(r),ie().getNumber("WEBGL_VERSION")===2?Ae(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,a,n,e.RGBA,o,i)):Ae(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,a,n,0,e.RGBA,o,i)),Ae(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function e3(e,t,a){Ae(e,()=>e.bindTexture(e.TEXTURE_2D,t)),a.data instanceof Uint8Array?ie().getNumber("WEBGL_VERSION")===2?Ae(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,a.width,a.height,e.RGBA,e.UNSIGNED_BYTE,a.data)):Ae(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,a.width,a.height,0,e.RGBA,e.UNSIGNED_BYTE,a.data)):ie().getNumber("WEBGL_VERSION")===2?Ae(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,a)):Ae(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,a)),Ae(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function t3(e,t,a,n){let r=e.createBuffer();Ae(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r));let s=4*4*t*a;return Ae(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ)),Ae(e,()=>e.readPixels(0,0,a,t,e.RGBA,e.FLOAT,0)),Ae(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),r}function a3(e,t,a){let n=e,r=new Float32Array(a);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,r),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),r}function n3(e,t,a,n){let[r,s]=ig(t,a),i=4,o=new Uint8Array(jse(t*a,i));return Ae(e,()=>e.readPixels(0,0,r,s,n.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function r3(e,t,a,n,r,s,i,o){let u=e,d=new Float32Array(Kse(s,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,d),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),d}function s3(e,t,a){let n=new Float32Array(t*a*4);return Ae(e,()=>e.readPixels(0,0,a,t,e.RGBA,e.FLOAT,n)),n}var Gy=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=ie().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,pO(t,e)):this.gl=fs(t),e=this.gl,ie().getNumber("WEBGL_VERSION")===2){let r=e;this.createVertexArray=()=>Ae(r,()=>r.createVertexArray()),this.bindVertexArray=s=>Ae(r,()=>r.bindVertexArray(s)),this.deleteVertexArray=s=>Ae(r,()=>r.deleteVertexArray(s)),this.getVertexArray=()=>Ae(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){let r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ae(e,()=>r.createVertexArrayOES()),this.bindVertexArray=s=>Ae(e,()=>r.bindVertexArrayOES(s)),this.deleteVertexArray=s=>Ae(e,()=>r.deleteVertexArrayOES(s)),this.getVertexArray=()=>Ae(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let a="WEBGL_color_buffer_float",n="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ie().getNumber("WEBGL_VERSION")===1){let r="OES_texture_float",s="OES_texture_half_float";if(this.textureFloatExtension=Rf(this.gl,r),kr(this.gl,s))this.textureHalfFloatExtension=Rf(this.gl,s);else if(ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(a),kr(this.gl,n))this.colorBufferHalfFloatExtension=Rf(this.gl,n);else if(ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(a="EXT_color_buffer_float",kr(this.gl,a))this.colorBufferFloatExtension=this.gl.getExtension(a);else if(kr(this.gl,n))this.colorBufferHalfFloatExtension=this.gl.getExtension(n);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=HO(this.gl),this.indexBuffer=qO(this.gl),this.framebuffer=IO(this.gl),this.textureConfig=iI(this.gl,this.textureHalfFloatExtension)}get debug(){return ie().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Ae(e,()=>e.finish()),Ae(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ae(e,()=>e.deleteFramebuffer(this.framebuffer)),Ae(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ae(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ae(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),jO(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),KO(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),XO(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),e3(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,a,n){this.throwIfDisposed(),JO(this.gl,e,t,a,n,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),ZO(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),YO(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(f1(this.gl,this.framebuffer),this.outputTexture=null),Ae(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,a){return this.downloadMatrixDriver(e,()=>n3(this.gl,t,a,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,a,n,r,s){return r3(this.gl,e,t,a,n,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return a3(this.gl,e,t)}createBufferFromTexture(e,t,a){this.bindTextureToFrameBuffer(e);let n=t3(this.gl,t,a,this.textureConfig);return this.unbindTextureToFrameBuffer(),n}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,a;if(ie().getBool("WEBGL_FENCE_API_ENABLED")){let n=e,r=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),a=()=>{let s=n.clientWaitSync(r,0,0);return s===n.ALREADY_SIGNALED||s===n.CONDITION_SATISFIED},t=r}else ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),a=()=>this.isQueryAvailable(t,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):a=()=>!0;return{query:t,isFencePassed:a}}downloadMatrixFromPackedTexture(e,t,a){return this.downloadMatrixDriver(e,()=>s3(this.gl,t,a))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=GO(t));let a=bO(t);Ae(t,()=>t.attachShader(a,this.vertexShader)),Ae(t,()=>t.attachShader(a,e)),vO(t,a);let n=Object.assign(a,{vao:this.createVertexArray()});return this.debug&&Uy(t,n),n}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;Ae(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),QO(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ae(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Uy(this.gl,this.program),Ae(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,a=!0){return this.throwIfDisposed(),a?TO(this.gl,e,t):_O(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ae(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,a){this.throwIfDisposed(),this.throwIfNoProgram(),CO(this.gl,e,t,a)}setOutputMatrixTexture(e,t,a){this.setOutputMatrixTextureDriver(e,a,t)}setOutputPackedMatrixTexture(e,t,a){this.throwIfDisposed();let[n,r]=op(t,a);this.setOutputMatrixTextureDriver(e,n,r)}setOutputMatrixWriteRegion(e,t,a,n){this.setOutputMatrixWriteRegionDriver(a,e,n,t)}setOutputPackedMatrixWriteRegion(e,t,a,n){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Uy(this.gl,this.program),Df(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ae(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ae(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Rf(this.gl,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let a=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=a.createQuery();return a.beginQuery(n.TIME_ELAPSED_EXT,r),r}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,a=this.getQueryTimerExtensionWebGL2();t.endQuery(a.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await C.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let a=this.gl;return a.getQueryParameter(e,a.QUERY_RESULT)/1e6}else{let a=this.getQueryTimerExtensionWebGL1();return a.getQueryObjectEXT(e,a.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let a=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=a.getQueryParameter(e,a.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{let a=this.getQueryTimerExtensionWebGL1(),n=a.getQueryObjectEXT(e,a.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Qie(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:a}=this.itemsToPoll[t];a()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let a;"setTimeoutCustom"in ie().platform&&(a=ie().platform.setTimeoutCustom.bind(ie().platform)),C.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,a)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Py(this.gl,e,this.framebuffer),this.debug&&Df(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Py(this.gl,this.outputTexture,this.framebuffer),this.debug&&Df(this.gl)):f1(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let a=t();return this.unbindTextureToFrameBuffer(),a}setOutputMatrixTextureDriver(e,t,a){this.throwIfDisposed();let n=this.gl;Py(n,e,this.framebuffer),this.debug&&Df(n),this.outputTexture=e,Ae(n,()=>n.viewport(0,0,t,a)),Ae(n,()=>n.scissor(0,0,t,a))}setOutputMatrixWriteRegionDriver(e,t,a,n){this.throwIfDisposed(),Ae(this.gl,()=>this.gl.scissor(e,t,a,n))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Qie(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Jie,bincountImpl:i3,bincountReduceImpl:eoe,bitwiseAndImpl:toe,castImpl:aoe,ceilImpl:noe,concatImpl:roe,equalImpl:soe,expImpl:ioe,expm1Impl:ooe,floorImpl:loe,gatherNdImpl:uoe,gatherV2Impl:coe,greaterImpl:doe,greaterEqualImpl:hoe,lessImpl:poe,lessEqualImpl:foe,linSpaceImpl:moe,logImpl:goe,maxImpl:yoe,maximumImpl:boe,minimumImpl:voe,multiplyImpl:xoe,negImpl:woe,notEqualImpl:koe,prodImpl:Soe,raggedGatherImpl:Ioe,raggedRangeImpl:Noe,raggedTensorToTensorImpl:Toe,rangeImpl:_oe,rsqrtImpl:Coe,scatterImpl:Eoe,sigmoidImpl:Aoe,simpleAbsImpl:o3,sliceImpl:$oe,sparseFillEmptyRowsImpl:Roe,sparseReshapeImpl:Doe,sparseSegmentReductionImpl:l3,sqrtImpl:Moe,staticRegexReplaceImpl:Foe,stridedSliceImpl:Ooe,stringNGramsImpl:zoe,stringSplitImpl:Loe,stringToHashBucketFastImpl:Boe,subImpl:Uoe,tileImpl:Poe,topKImpl:Woe,transposeImpl:gI,uniqueImpl:Voe}=G2;function u3(e,t){return["x","y","z","w","u","v"].slice(0,t).map(a=>`${e}.${a}`)}function Tn(e,t){return t===1?[e]:u3(e,t)}function Goe(e,t){if(e===1)return"rc";let a="";for(let n=0;n<e;n++)a+=t[n],n<e-1&&(a+=",");return a}var Hoe=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=xn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Tn("rc",this.rank),a=qt(this.rank),n=this.getOutOfBoundsCondition(t),r=this.getSetup(t),s=this.getOutput(t);this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();

          if(${n}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${s}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let a=0;a<=1;a++)for(let n=0;n<=1;n++){let r=`${a===0?"r":"rp1"}, ${n===0?"c":"cp1"}`;for(let s=2;s<this.rank;s++)r=`${e[e.length-1-s]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let a=this.rank-2;a<this.rank;a++)t+=`${e[a]} >= ${this.enableShapeUniforms?`outShape[${a}]`:this.outputShape[a]}`,a<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),a=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],n=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${a};
      bool rEdge = rp1 >= ${n};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},c3=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=xn(this.outputShape.length);let a="";for(let n=0;n<4;n++){let r="thisRC = rc;";n%2===1&&(r+="thisRC.z += 1;"),n>1&&(r+="thisRC.y += 1;"),a+=`
        ${r}
        ${n>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${n}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${n>0?"}":""}
      `}this.userCode=`
      ${qoe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?uI():lI(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${a}

        setOutput(result);
      }
    `}};function qoe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?iie(["r","c","d"],"inputShape"):$c(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var joe=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,a){let n=FE(t,a),r=OE(e,n,a);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);let s=ME(e,n,this.gpgpu.gl,this.gpgpu.textureConfig,a);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let o=this.freeTextures[r].pop();return this.usedTextures[r].push(o),o}let i;return n===cn.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):n===cn.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):n===cn.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):n===cn.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):n===cn.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),i}releaseTexture(e,t,a,n){if(this.freeTextures==null)return;let r=FE(a,n),s=OE(t,r,n);s in this.freeTextures||(this.freeTextures[s]=[]);let i=ME(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,n),o=ie().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let u=this.usedTextures[s],d=u&&u.indexOf(e);if(d==null||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[d]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Koe(e,t){let a=e;if(t===a.R32F)return 4;if(t===a.R16F)return 2;if(t===a.RGBA32F||t===e.RGBA)return 16;if(t===a.RGBA16F)return 8;if(t===a.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function ME(e,t,a,n,r){let s=Xoe(t,n),i;if(r){let[u,d]=op(e[0],e[1]);i=u*d}else{let[u,d]=ig(e[0],e[1]);i=u*d}let o=Koe(a,s);return i*o}function Xoe(e,t){switch(e){case cn.PACKED_2X2_FLOAT32:return fI(t);case cn.PACKED_2X2_FLOAT16:return mI(t);case cn.UNPACKED_FLOAT32:return dI(t);case cn.UNPACKED_FLOAT16:return hI(t);case cn.PACKED_4X1_UNSIGNED_BYTE:return pI(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function Yoe(e){return ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?cn.PACKED_2X2_FLOAT32:cn.UNPACKED_FLOAT32:e?cn.PACKED_2X2_FLOAT16:cn.UNPACKED_FLOAT16}function FE(e,t){if(e===wr.UPLOAD)return cn.PACKED_2X2_FLOAT32;if(e===wr.RENDER||e==null)return Yoe(t);if(e===wr.DOWNLOAD||e===wr.PIXELS)return cn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function OE(e,t,a){return`${e[0]}_${e[1]}_${t}_${a}`}var Os=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=xn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Kr="if (isnan(x)) return x;",Zoe="return x;",zE="return abs(x);",Qoe="return (x >= 0.0) ? x : (exp(x) - 1.0);",Joe=Kr+`
  return (x < 0.0) ? 0.0 : x;
`,ele=Kr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,co="return x;",tle="return 1.0 / (1.0 + exp(-1.0 * x));",ale="return x;",nle=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,rle=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sle=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ile="return 1.0 / (1.0 + exp(-1.0 * x));",go=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=xn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},ole=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=xn(this.outputShape.length);let t=e.length,a=Tn("rc",t),n=qt(t),r=Goe(t,a),s=a.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`
      void main() {
        ${n} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},lle=qs.whereImpl,ule=1e-7,cle=1e-4,yw={};function dle(e){return e in yw||(yw[e]={}),yw[e]}var hle=ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),ple=600;function fle(){return ie().global.screen==null?1024:ie().global.screen.height*ie().global.screen.width*window.devicePixelRatio*ple/1024/1024}var yI=class d3 extends lm{nextDataId(){return d3.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ie().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let a;if(t!=null){if(t instanceof Gy)a=t;else{let n=fs(ie().getNumber("WEBGL_VERSION"),t);a=new Gy(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=fs(ie().getNumber("WEBGL_VERSION"));a=new Gy(n),this.binaryCache=dle(ie().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=a,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new joe(this.gpgpu),this.numMBBeforeWarning=fle(),this.texData=new Sb(this,Pr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,a,n,r,s,i){let o=this.makeTensorInfo(a,n),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:t,texShape:[r,s]},u.texShape=[r,s];let d=Mf(a),c=new DE(d,!1,i),f=this.runWebGLProgram(c,[o],n,[[r,s]]);return f.shape=a,u.texture=null,this.disposeIntermediateTensorInfo(o),f.dataId}write(t,a,n){if((ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ie().getBool("DEBUG"))&&this.checkNumericalProblems(t),n==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:a,dtype:n,values:t,usage:wr.UPLOAD,refCount:1}),r}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let a=this.texData.get(t);a.refCount++}decRef(t){if(this.texData.has(t)){let a=this.texData.get(t);a.refCount--}}move(t,a,n,r,s){if(ie().getBool("DEBUG")&&this.checkNumericalProblems(a),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:r,values:a,usage:wr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let a=this.texData.get(t),{values:n,dtype:r,complexTensorInfos:s,slice:i,shape:o,isPacked:u}=a;if(i!=null){let m;u?m=new go(o,co):m=new Os(o,co);let g=this.runWebGLProgram(m,[{dataId:t,shape:o,dtype:r}],r),b=this.readSync(g.dataId);return this.disposeIntermediateTensorInfo(g),b}if(n!=null)return this.convertAndCacheOnCPU(t);if(r==="string")return n;let d=this.activeTimers!=null,c;d&&(c=C.now());let f;if(r==="complex64"){let m=this.readSync(s.real.dataId),g=this.readSync(s.imag.dataId);f=D.mergeRealAndImagArrays(m,g)}else f=this.getValuesFromTexture(t);return d&&(this.downloadWaitMs+=C.now()-c),this.convertAndCacheOnCPU(t,f)}async read(t){if(this.pendingRead.has(t)){let b=this.pendingRead.get(t);return new Promise(v=>b.push(v))}let a=this.texData.get(t),{values:n,shape:r,slice:s,dtype:i,complexTensorInfos:o,isPacked:u}=a;if(s!=null){let b;u?b=new go(r,co):b=new Os(r,co);let v=this.runWebGLProgram(b,[{dataId:t,shape:r,dtype:i}],i),x=this.read(v.dataId);return this.disposeIntermediateTensorInfo(v),x}if(n!=null)return this.convertAndCacheOnCPU(t);if(ie().getBool("DEBUG")&&!ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ie().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d=null,c;if(i!=="complex64"&&ie().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let b=this.texData.get(c.dataId);d=this.gpgpu.createBufferFromTexture(b.texture.texture,...$y(r))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(i==="complex64"){let b=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),v=b[0],x=b[1];f=D.mergeRealAndImagArrays(v,x)}else if(d==null)f=this.getValuesFromTexture(t);else{let b=C.sizeFromShape(r);f=this.gpgpu.downloadFloat32MatrixFromBuffer(d,b)}if(c!=null&&this.disposeIntermediateTensorInfo(c),d!=null){let b=this.gpgpu.gl;Ae(b,()=>b.deleteBuffer(d))}let m=this.convertAndCacheOnCPU(t,f),g=this.pendingRead.get(t);return this.pendingRead.delete(t),g.forEach(b=>b(m)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Pr().removeDataId(t,this),this.pendingDeletes--),m}readToGPU(t,a={}){let n=this.texData.get(t),{values:r,shape:s,slice:i,dtype:o,isPacked:u,texture:d}=n;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let g;u?g=new go(s,co):g=new Os(s,co);let b=this.runWebGLProgram(g,[{dataId:t,shape:s,dtype:o}],o),v=this.readToGPU(b,a);return this.disposeIntermediateTensorInfo(b),v}if(d==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,a.customTexShape),f=Pr().makeTensorFromTensorInfo(c),m=this.texData.get(c.dataId);return Object.assign({tensorRef:f},m.texture)}bufferSync(t){let a=this.readSync(t.dataId);if(t.dtype==="string")try{let n=a.map(r=>C.decodeString(r));return ct(t.shape,t.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ct(t.shape,t.dtype,a)}checkNumericalProblems(t){if(t!=null)for(let a=0;a<t.length;a++){let n=t[a];if(!fO(n))throw ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:a,dtype:n,isPacked:r}=this.texData.get(t),s=C.sizeFromShape(a);if(ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(t),g=this.texData.get(m.dataId),b=this.gpgpu.downloadMatrixFromPackedTexture(g.texture.texture,...$y(a)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),b}let i=ie().getBool("WEBGL_PACK")&&r===!0,o=i?Mf(a):a,u=i?new Xie(o):new Kie(o),d=this.runWebGLProgram(u,[{shape:o,dtype:n,dataId:t}],"float32"),c=this.texData.get(d.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(d),f}timerAvailable(){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let a=this.activeTimers,n=[],r=!1;this.programTimersStack==null?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,t();let s=C.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=C.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=a,r&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);o.kernelMs=C.sum(u),o.getExtraProfileInfo=()=>u.map((d,c)=>({name:i[c],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:C.now(),endMs:null}}endTimer(t){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=C.now(),t)}async getQueryTime(t){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let a=t;return a.endMs-a.startMs}disposeData(t,a=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(a?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!a&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:n}=this.texData.get(t);return n!=null&&(this.disposeData(n.real.dataId,a),this.disposeData(n.imag.dataId,a)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:a,dtype:n,texShape:r,usage:s,isPacked:i,slice:o}=this.texData.get(t),u=o&&o.origDataId||t,d=this.dataRefCount.get(u);d>1?this.dataRefCount.set(u,d-1):(this.dataRefCount.delete(u),a!=null&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(a,r,s,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,a=hle){return ie().getBool("WEBGL_CPU_FORWARD")&&t.every(n=>this.texData.get(n.dataId).texture==null&&C.sizeFromShape(n.shape)<a)}getGPGPUContext(){return this.gpgpu}where(t){D.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let a=t.dataSync();return lle(t.shape,a)}packedUnaryOp(t,a,n){let r=new go(t.shape,a),s=this.compileAndRun(r,[t],n);return Pr().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let r=o3(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,r)}if(ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,zE,t.dtype);let a=new Os(t.shape,zE),n=this.compileAndRun(a,[t]);return Pr().makeTensorFromTensorInfo(n)}makeTensorInfo(t,a,n){let r;if(a==="string"&&n!=null&&n.length>0&&C.isString(n[0])){let s=n.map(i=>C.encodeString(i));r=this.write(s,t,a)}else r=this.write(n,t,a);return this.texData.get(r).usage=null,{dataId:r,shape:t,dtype:a}}makeOutput(t,a,n){return Pr().makeTensorFromTensorInfo(this.makeTensorInfo(t,a,n),this)}unpackTensor(t){let a=new ole(t.shape);return this.runWebGLProgram(a,[t],t.dtype)}packTensor(t){let a=new Hoe(t.shape);return this.runWebGLProgram(a,[t],t.dtype,null,!0)}packedReshape(t,a){let n=[eu(t.shape),...tu(t.shape)],r={dtype:t.dtype,shape:n,dataId:t.dataId},s=[eu(a),...tu(a)],i=new c3(s,n),o=!0,u=[n],d=this.runWebGLProgram(i,[r],t.dtype,u,o);return{dataId:d.dataId,shape:a,dtype:d.dtype}}decode(t,a){let n=this.texData.get(t),{isPacked:r,shape:s,dtype:i}=n;if(a!=null){let m=C.sizeFromShape(s),g=a[0]*a[1]*4;C.assert(m<=g,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=Mf(s),u;r?u=new jie(o):u=new qie(o);let d=!0,c=[a??$y(o)],f=this.runWebGLProgram(u,[{shape:o,dtype:i,dataId:t}],i,c,d,a);return{dtype:i,shape:s,dataId:f.dataId}}runWebGLProgram(t,a,n,r,s=!1,i){let o=this.makeTensorInfo(t.outputShape,n),u=this.texData.get(o.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===em.DENSE){let k=i??$y(t.outputShape);u.texShape=k.map(S=>S*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),C.sizeFromShape(o.shape)===0)return u.values=C.getTypedArrayFromDType(o.dtype,0),o;let d=[],c=a.map(k=>{if(k.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let S=this.texData.get(k.dataId);if(S.texture==null){if(!t.packedInputs&&C.sizeFromShape(k.shape)<=ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:k.shape,texData:null,isUniform:!0,uniformValues:S.values};t.packedInputs&&(S.isPacked=!0,S.shape=k.shape)}if(this.uploadToGPU(k.dataId),!!S.isPacked!=!!t.packedInputs)k=S.isPacked?this.unpackTensor(k):this.packTensor(k),d.push(k),S=this.texData.get(k.dataId);else if(S.isPacked&&!tm(S.shape,k.shape)){let N=k,T=k.shape;k.shape=S.shape,k=this.packedReshape(k,T),d.push(k),S=this.texData.get(k.dataId),N.shape=T}return{shape:k.shape,texData:S,isUniform:!1}});this.uploadToGPU(o.dataId);let f={shape:o.shape,texData:u,isUniform:!1},m=Hie(t,c,f),g=this.getAndSaveBinary(m,()=>Vie(this.gpgpu,t,c,f)),b=this.activeTimers!=null,v;b&&(v=this.startTimer()),ie().get("ENGINE_COMPILE_ONLY")||Gie(this.gpgpu,g,c,f,r),d.forEach(k=>this.disposeIntermediateTensorInfo(k)),b&&(v=this.endTimer(v),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(v)}));let x=ie().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){let k=C.now();k-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=k)}if(!ie().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&s===!1){let k=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),k}return o}compileAndRun(t,a,n,r,s=!1){return n=n||a[0].dtype,this.runWebGLProgram(t,a,n,r,s)}getAndSaveBinary(t,a){return t in this.binaryCache||(this.binaryCache[t]=a()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ie().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ae(()=>{if(!ie().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=ie().getBool("DEBUG");ie().set("DEBUG",!1);let a=this.abs(We(1e-8)).dataSync()[0];if(ie().set("DEBUG",t),a>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?ule:cle}uploadToGPU(t){let a=this.texData.get(t),{shape:n,dtype:r,values:s,texture:i,usage:o,isPacked:u}=a;if(i!=null)return;let d=this.activeTimers!=null,c;d&&(c=C.now());let f=a.texShape;if(f==null&&(f=$O(n,u),a.texShape=f),s!=null){let m=Mf(n),g,b=f[1],v=f[0],x=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!x)&&([b,v]=op(f[0],f[1])),u?g=new Zie(m,x):g=new DE(m,x);let k=x?[v,b]:f,S=this.makeTensorInfo(k,r),N=this.texData.get(S.dataId);x?N.usage=wr.PIXELS:N.usage=wr.UPLOAD,N.texShape=k,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(S.dataId),b,v,s);let T=[[v,b]],_=this.runWebGLProgram(g,[S],r,T,!0),R=this.texData.get(_.dataId);a.texShape=R.texShape,a.isPacked=R.isPacked,a.usage=R.usage,ie().get("ENGINE_COMPILE_ONLY")?this.disposeData(_.dataId):(a.texture=R.texture,a.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(S),d&&(this.uploadWaitMs+=C.now()-c)}else{let m=this.acquireTexture(f,o,r,u);a.texture=m}}convertAndCacheOnCPU(t,a){let n=this.texData.get(t),{dtype:r}=n;return a!=null&&(n.values=mle(a,r)),n.values}acquireTexture(t,a,n,r){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,a,r)}computeBytes(t,a){return t[0]*t[1]*C.bytesPerElement(a)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,a]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(a));return Promise.all(t)}else{for(let[,a]of Object.entries(this.binaryCache)){let n=new Promise(r=>{try{this.checkCompletion_(a),r(!0)}catch(s){throw s}});t.push(n)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await iS(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(oI(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:a,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:u}=WO(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=a,t.customUniformLocations=n,t.infLoc=r,t.nanLoc=s,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=u}}createTensorFromGPUData(t,a,n){t.channels=t.channels||"RGBA";let{texture:r,height:s,width:i,channels:o}=t,u=Pr().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let d=u.writeTexture(r,a,n,s,i,o);return Pr().makeTensorFromDataId(d,a,n,u)}};yI.nextDataId=0;function mle(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let a=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let n=0;n<a.length;++n)a[n]=Math.round(e[n]);return a}else throw new Error(`Unknown dtype ${t}`)}var gle="4.22.0";function h3(){ie().set("WEBGL_FORCE_F16_TEXTURES",!0)}Mm.isBrowser()&&Pb("webgl",()=>new yI,2);var yle={forceHalfFloat:h3},bI=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,au=class{constructor(e,t,a){this.variableNames=["A","B"],this.outputShape=D.assertAndGetBroadcastShape(t,a),this.enableShapeUniforms=xn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},Dc=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,pp=class{constructor(e,t,a,n=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=D.assertAndGetBroadcastShape(t,a);let r=this.outputShape.length;this.enableShapeUniforms=xn(r);let s="";if(n)if(r===0||C.sizeFromShape(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          ${qt(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?s+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:s+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Tn("coords",r);this.enableShapeUniforms?s+=`
            bool nextRowOutOfBounds =
              (${i[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${i[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:s+=`
            bool nextRowOutOfBounds =
              (${i[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${i[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${s}

        setOutput(result);
      }
    `}};function cr(e){let{inputs:t,backend:a}=e,{x:n}=t;return a.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var ble={kernelName:Fu,backendName:"webgl",kernelFunc:cr};function qo(e){let{inputs:t,backend:a}=e,{real:n,imag:r}=t,s=a.makeTensorInfo(n.shape,"complex64"),i=a.texData.get(s.dataId),o=cr({inputs:{x:n},backend:a}),u=cr({inputs:{x:r},backend:a});return i.complexTensorInfos={real:o,imag:u},s}var vle={kernelName:Tb,backendName:"webgl",kernelFunc:qo},p3="return (a < 0.) ? b * a : a;",f3=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function xle(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{alpha:s}=n,i=a.makeTensorInfo([],"float32",C.createScalarValue(s,"float32")),o=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pp(f3,r.shape,i.shape):new au(p3,r.shape,i.shape),u=a.runWebGLProgram(o,[r,i],"float32");return a.disposeIntermediateTensorInfo(i),u}var wle={kernelName:Bu,backendName:"webgl",kernelFunc:xle},m3="return (a < 0.) ? b * a : a;",g3=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function kle(e){let{inputs:t,backend:a}=e,{x:n,alpha:r}=t,s=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pp(g3,n.shape,r.shape):new au(m3,n.shape,r.shape);return a.runWebGLProgram(s,[n,r],"float32")}var Sle={kernelName:tc,backendName:"webgl",kernelFunc:kle},fp="if (isnan(x)) return x;";function Tt({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:a,dtype:n}){return({inputs:r,backend:s})=>{let{x:i}=r,o=s,u=n||i.dtype;if(o.shouldExecuteOnCPU([i])&&a!=null){let f=o.texData.get(i.dataId),m=a(f.values,u);return o.makeTensorInfo(i.shape,u,m)}let d=ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return d?c=new go(i.shape,t):c=new Os(i.shape,e),o.runWebGLProgram(c,[i],u)}}function hn({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:a=!1,supportsComplex:n=!1,cpuKernelImpl:r,dtype:s}){return({inputs:i,backend:o})=>{let{a:u,b:d}=i,c=o;if(n&&u.dtype==="complex64"){let b=c.texData.get(u.dataId),v=c.texData.get(d.dataId),[x,k]=[[b.complexTensorInfos.real,v.complexTensorInfos.real],[b.complexTensorInfos.imag,v.complexTensorInfos.imag]].map(N=>{let[T,_]=N,R={dataId:T.dataId,dtype:T.dtype,shape:u.shape},M={dataId:_.dataId,dtype:_.dtype,shape:d.shape},F=new au(e,u.shape,d.shape);return c.runWebGLProgram(F,[R,M],Nr(T.dtype,_.dtype))}),S=qo({inputs:{real:x,imag:k},backend:c});return c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(k),S}let f=s||Nr(u.dtype,d.dtype);if((u.dtype==="string"||d.dtype==="string"||c.shouldExecuteOnCPU([u,d]))&&r!=null){let b=c.texData.get(u.dataId).values,v=c.texData.get(d.dataId).values,x=u.dtype==="string"?D.fromUint8ToStringArray(b):b,k=u.dtype==="string"?D.fromUint8ToStringArray(v):v,[S,N]=r(u.shape,d.shape,x,k,f),T=c.makeTensorInfo(N,f),_=c.texData.get(T.dataId);return _.values=S,T}let m=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,g;return m?g=new pp(t,u.shape,d.shape,a):g=new au(e,u.shape,d.shape),c.runWebGLProgram(g,[u,d],f)}}function am(e,t=!1){if(e==="linear")return t?ale:Zoe;if(e==="relu")return t?rle:Joe;if(e==="elu")return t?nle:Qoe;if(e==="relu6")return t?sle:ele;if(e==="prelu")return t?g3:m3;if(e==="leakyrelu")return t?f3:p3;if(e==="sigmoid")return t?ile:tle;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var y3=class{constructor(e,t,a,n=!1,r=!1,s=!1,i=null,o=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a,this.enableShapeUniforms=xn(this.outputShape.length);let d=n?e[1]:e[2],c=Math.ceil(d/2),f=n?"i * 2, rc.y":"rc.y, i * 2",m=r?"rc.z, i * 2":"i * 2, rc.z",g=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],b=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],v="",x="";i&&(o?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:u?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:v=`vec4 activation(vec4 x) {
          ${i}
        }`,x="result = activation(result);");let k=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let S="rc.x",N="rc.x";e[0]<t[0]?S=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(N=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${S};
        int batchB = ${N};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${m});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${g[0]} * ${b[0]});
          result += (${g[1]} * ${b[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${k}

        ${x}

        setOutput(result);
      }
    `}},LE={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},BE=class{constructor(e,t,a){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=D.assertAndGetBroadcastShape(t,a),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},UE="return a * b;";function vI(e){let{inputs:t,backend:a}=e,{a:n,b:r}=t,s=D.upcastType(n.dtype,r.dtype);if(n.dtype==="complex64"){let o=a.texData.get(n.dataId),u=a.texData.get(r.dataId),d=new BE(LE.REAL,n.shape,r.shape),c=new BE(LE.IMAG,n.shape,r.shape),f=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:n.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],m=a.runWebGLProgram(d,f,"float32"),g=a.runWebGLProgram(c,f,"float32"),b=qo({inputs:{real:m,imag:g},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),b}if(a.shouldExecuteOnCPU([n,r])){let o=a.texData.get(n.dataId),u=a.texData.get(r.dataId),[d,c]=xoe(n.shape,r.shape,o.values,u.values,s),f=a.makeTensorInfo(c,s),m=a.texData.get(f.dataId);return m.values=d,f}let i;return ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new pp(UE,n.shape,r.shape):i=new au(UE,n.shape,r.shape),a.runWebGLProgram(i,[n,r],s)}var Ile={kernelName:Zu,backendName:"webgl",kernelFunc:vI};function Nle(e,t,a){let n=[eu(e.shape),...tu(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[eu(t),...tu(t)],i=new c3(s,n),o=!0,u=[n],d=a.runWebGLProgram(i,[r],e.dtype,u,o);return{dataId:d.dataId,shape:t,dtype:d.dtype}}function Ee(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{shape:s}=n,i=a,o=C.sizeFromShape(r.shape),u=C.inferFromImplicitShape(s,o),d=C.sizeFromShape(u);C.assert(o===d,()=>`The new shape (${u}) has ${d} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(r.dataId);return c.isPacked&&!tm(r.shape,u)&&!(c.texture!==null&&tm(c.shape,u))?Nle(r,u,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}var Tle={kernelName:Rh,backendName:"webgl",kernelFunc:Ee},PE=class{constructor(e,t){this.variableNames=["x"];let{windowSize:a,batchSize:n,inSize:r,outSize:s}=e;this.outputShape=[n,s];let i=Math.floor(a/4)*4,o=a%4,u="sumValue += dot(values, ones);";if(t!=null){let c=1/t;u=`sumValue += dot(values * ${C.isInt(c)?c.toPrecision(2):c}, ones);`}let d="";r%a>0&&(d=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}},_le=class{constructor(e,t){this.variableNames=["x"];let{windowSize:a,batchSize:n,inSize:r,outSize:s}=e;this.outputShape=[n,s];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");let d=Math.floor(a/4)*4,c=a%4,f=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";t==="all"?(i="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):t==="any"&&(i="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let g="";r%a>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${d};
        if (${c===1}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${c===2}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${c===3}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${u});
      }
    `}};function Cle(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let a=t.length?t[t.length-1].outSize:e[1],n=D.computeOptimalWindowSize(a);t.push({inSize:a,windowSize:n,outSize:Math.ceil(a/n)})}return t}function Mc(e,t,a,n){let r=Cle(e.shape),s=e;for(let i=0;i<r.length;i++){let{inSize:o,windowSize:u,outSize:d}=r[i],c,f;a==="mean"?c=i===0?new PE({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:d},o):new PE({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:d}):c=new _le({windowSize:u,inSize:o,batchSize:e.shape[0],outSize:d},a),f=s,s=n.runWebGLProgram(c,[s],t),f.dataId!==e.dataId&&n.disposeIntermediateTensorInfo(f)}return s}var Ele=class{constructor(e,t){this.variableNames=["A"];let a=new Array(e.length);for(let s=0;s<a.length;s++)a[s]=e[t[s]];this.outputShape=a,this.rank=a.length;let n=qt(this.rank),r=Ale(t);this.userCode=`
    void main() {
      ${n} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}};function Ale(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let a=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let r=0;r<e.length;r++)n[e[r]]=a[r];return n.join()}var $le=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let a=new Array(e.length);for(let d=0;d<a.length;d++)a[d]=e[t[d]];if(this.outputShape=a,this.rank=a.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let n=qt(this.rank),r=u3("rc",this.rank),s=new Array(this.rank);for(let d=0;d<t.length;d++)s[t[d]]=r[d];let i=`vec2(${s.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${a[this.rank-1]}`,u=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`
    void main() {
      ${n} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${o}) {
        result[1] = ${u};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${a[this.rank-2]}) {
        result[2] = ${u};
        if(${o}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function qv(e,t,a){let n=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $le(e.shape,t):new Ele(e.shape,t);return a.runWebGLProgram(n,[e],e.dtype)}function Rle(e,t,a,n){let r=t,s=e.shape.length,i=C.parseAxisParam(r,e.shape),o=i,u=D.getAxesPermutation(o,s),d=u!=null,c=e;d&&(c=qv(e,u,n),o=D.getInnerMostAxes(o.length,s)),D.assertAxesAreInnerMostDims("sum",o,s);let[f,m]=D.computeOutAndReduceShapes(c.shape,o),g=f;a&&(g=D.expandShapeToKeepDim(f,i));let b=C.sizeFromShape(m),v=C.sizeFromShape(e.shape)/b,x=Ee({inputs:{x:c},attrs:{shape:[v,b]},backend:n}),k=Ub(e.dtype),S=Mc(x,k,"sum",n),N=Ee({inputs:{x:S},attrs:{shape:g},backend:n});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(S),d&&n.disposeIntermediateTensorInfo(c),N}function jv(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n;return Rle(r,s,i,a)}var Dle={kernelName:bc,backendName:"webgl",kernelFunc:jv};function En(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{perm:s}=n,i=a,o=r.shape.length,u=new Array(o);for(let c=0;c<u.length;c++)u[c]=r.shape[s[c]];let d;if(i.shouldExecuteOnCPU([r])){let c=i.texData.get(r.dataId).values,f=gI(c,r.shape,r.dtype,s,u);d=i.makeTensorInfo(u,r.dtype);let m=i.texData.get(d.dataId);m.values=f}else d=qv(r,s,i);return d}var Mle={kernelName:yi,backendName:"webgl",kernelFunc:En},b3=1e3;function gb({a:e,b:t,transposeA:a,transposeB:n,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){let d=e.shape.length,c=t.shape.length,f=a?e.shape[d-2]:e.shape[d-1],m=n?t.shape[c-1]:t.shape[c-2],g=a?e.shape[d-1]:e.shape[d-2],b=n?t.shape[c-2]:t.shape[c-1],v=e.shape.slice(0,-2),x=t.shape.slice(0,-2),k=C.sizeFromShape(v),S=C.sizeFromShape(x),N=Yh.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([g,b]);C.assert(f===m,()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${a} and transposeB=${n} must match.`);let T=a?[k,f,g]:[k,g,f],_=n?[S,b,m]:[S,m,b],R=Ee({inputs:{x:e},backend:r,attrs:{shape:T}}),M=Ee({inputs:{x:t},backend:r,attrs:{shape:_}}),F=[R,M],B=Math.max(k,S),V=a?R.shape[1]:R.shape[2],P=s!=null,A=i!=null,G=u==="leakyrelu",J=u!=null?am(u,!0):null,ee=P||A||G||J!=null,W;if((g===1||b===1)&&V>b3&&ee===!1){let Q=R,ce=M;a&&(Q=En({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),F.push(Q)),n&&(ce=En({inputs:{x:M},backend:r,attrs:{perm:[0,2,1]}}),F.push(ce));let L=b!==1,q=b===1,le=Q;L&&(le=Ee({inputs:{x:Q},backend:r,attrs:{shape:[B,V,1]}}),F.push(le));let se=b===1?2:1,pe=ce;q&&(pe=Ee({inputs:{x:ce},backend:r,attrs:{shape:[B,1,V]}}),F.push(pe));let ve=vI({inputs:{a:le,b:pe},backend:r});W=jv({inputs:{x:ve},backend:r,attrs:{axis:se,keepDims:!0}}),F.push(ve)}else{let Q=Nr(e.dtype,t.dtype),ce=new y3(T,_,[B,g,b],a,n,P,J,A,G),L=[R,M];if(s!=null&&L.push(s),A&&L.push(i),G){let q=r.makeTensorInfo([],"float32",C.createScalarValue(o,"float32"));L.push(q),F.push(q)}W=r.runWebGLProgram(ce,L,Q)}let X=Ee({inputs:{x:W},backend:r,attrs:{shape:N}});F.push(W);for(let Q of F)r.disposeIntermediateTensorInfo(Q);return X}function Fle(e){let{inputs:t,backend:a,attrs:n}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:d,activation:c,leakyreluAlpha:f}=n;return gb({a:r,b:s,transposeA:u,transposeB:d,backend:a,bias:i,preluActivationWeights:o,leakyreluAlpha:f,activation:c})}var Ole={kernelName:Bl,backendName:"webgl",kernelFunc:Fle},WE="return abs(x);";function zle(e){let{inputs:t,backend:a}=e,{x:n}=t;if(a.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=a.texData.get(n.dataId),i=o3(s.values);return a.makeTensorInfo(n.shape,n.dtype,i)}let r;return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new go(n.shape,WE):r=new Os(n.shape,WE),a.runWebGLProgram(r,[n],n.dtype)}var Lle={kernelName:Kd,backendName:"webgl",kernelFunc:zle},Ble=Kr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Ule=Tt({opSnippet:Ble}),Ple={kernelName:iu,backendName:"webgl",kernelFunc:Ule},Wle=Kr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Vle=Tt({opSnippet:Wle}),Gle={kernelName:ou,backendName:"webgl",kernelFunc:Vle},VE="return a + b;",Hle=hn({opSnippet:VE,packedOpSnippet:VE,supportsComplex:!0,cpuKernelImpl:Jie}),qle={kernelName:Oo,backendName:"webgl",kernelFunc:Hle},jle=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let a=[];this.variableNames.forEach(r=>{a.push(`float v${r} = get${r}AtOutCoords();`)});let n=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${a.join(`
        `)}

        float result = ${n};
        setOutput(result);
      }
    `}},Kle=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,s)=>`T${s}`);let a=[];this.variableNames.forEach(r=>{a.push(`vec4 v${r} = get${r}AtOutCoords();`)});let n=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${a.join(`
        `)}

        vec4 result = ${n};
        setOutput(result);
      }
    `}};function Hy(e){let{inputs:t,backend:a}=e,n=t;if(n.length===1)return cr({inputs:{x:n[0]},backend:a});if(n.length>ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(n.length/2),u=Hy({inputs:n.slice(0,o),backend:a}),d=Hy({inputs:n.slice(o),backend:a});return Hy({inputs:[u,d],backend:a})}let r=n.map(o=>o.dtype).reduce((o,u)=>Nr(o,u)),s=n.map(o=>o.shape),i=ie().getBool("WEBGL_PACK")?new Kle(n[0].shape,s):new jle(n[0].shape,s);return a.runWebGLProgram(i,n,r)}var Xle={kernelName:lu,backendName:"webgl",kernelFunc:Hy};function Yle(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n,o=r.shape.length,u=C.parseAxisParam(s,r.shape),d=u,c=D.getAxesPermutation(d,o),f=r;c!=null&&(f=En({inputs:{x:r},backend:a,attrs:{perm:c}}),d=D.getInnerMostAxes(d.length,o)),D.assertAxesAreInnerMostDims("all",d,o);let[m,g]=D.computeOutAndReduceShapes(f.shape,d),b=C.sizeFromShape(g),v=Ee({inputs:{x:f},backend:a,attrs:{shape:[-1,b]}}),x=Mc(v,v.dtype,"all",a),k;if(i){let S=D.expandShapeToKeepDim(m,u);k=Ee({inputs:{x},backend:a,attrs:{shape:S}})}else k=Ee({inputs:{x},backend:a,attrs:{shape:m}});return a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),c!=null&&a.disposeIntermediateTensorInfo(f),k}var Zle={kernelName:Xd,backendName:"webgl",kernelFunc:Yle};function Qle(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n,o=r.shape.length,u=C.parseAxisParam(s,r.shape),d=u,c=D.getAxesPermutation(d,o),f=r;c!=null&&(f=En({inputs:{x:r},backend:a,attrs:{perm:c}}),d=D.getInnerMostAxes(d.length,o)),D.assertAxesAreInnerMostDims("any",d,o);let[m,g]=D.computeOutAndReduceShapes(f.shape,d),b=C.sizeFromShape(g),v=Ee({inputs:{x:f},backend:a,attrs:{shape:[-1,b]}}),x=Mc(v,v.dtype,"any",a),k;if(i){let S=D.expandShapeToKeepDim(m,u);k=Ee({inputs:{x},backend:a,attrs:{shape:S}})}else k=Ee({inputs:{x},backend:a,attrs:{shape:m}});return a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),c!=null&&a.disposeIntermediateTensorInfo(f),k}var Jle={kernelName:Yd,backendName:"webgl",kernelFunc:Qle},eue=class{constructor(e,t,a){this.variableNames=["A"];let{windowSize:n,batchSize:r,outSize:s}=e;a||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];let i=t==="max"?">":"<",o=a?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${n}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},tue=class{constructor(e,t,a,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,C.assert(e.length>2,()=>`Packed arg${a.charAt(0).toUpperCase()+a.slice(1)} supports only inputs with rank above 2.`);let r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),n||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,u=qt(o),d=Tn("coords",o),c,f;if(s===1){f=o+1;let M=qt(f);c=`
        ${M} sourceLocR = ${M}(${d.join()}, 0);
        ++${d[o-1]};
        ${M} sourceLocG = ${M}(${d.join()}, 0);
        ++${d[o-2]};
        ${M} sourceLocA = ${M}(${d.join()}, 0);
        --${d[o-1]};
        ${M} sourceLocB = ${M}(${d.join()}, 0);
        --${d[o-2]};`}else f=o,c=`
        ${u} sourceLocR = coords;
        ++${d[o-1]};
        ${u} sourceLocG = coords;
        ++${d[o-2]};
        ${u} sourceLocA = coords;
        --${d[o-1]};
        ${u} sourceLocB = coords;
        --${d[o-2]};`;let m=["x","y","z","w","u","v"].slice(0,f),g="."+m[f-1],b=m.map(M=>"int "+M),v=Tn("sourceLocR",f-1).concat("inIdx.r"),x=Tn("sourceLocG",f-1).concat("inIdx.g"),k=Tn("sourceLocB",f-1).concat("inIdx.b"),S=Tn("sourceLocA",f-1).concat("inIdx.a"),N=a==="max"?"greaterThan":"lessThan",T=n?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${k.join()}),
                             getBestIndicesAChannel(${S.join()})));`,_=`vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${k.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,R=n?"":`
      float getBestIndicesAChannel(${b.join()}) {
        return getChannel(getBestIndicesA(${m.join()}),
                                          vec2(${m.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${b.join()}) {
        return getChannel(getA(${m.join()}),
                               vec2(${m.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${d[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${d[o-2]} < ${i[o-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${T}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${N}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function v3(e,t,a,n=null){let r=t.shape[0],s=t.shape[1];n!=null&&(r=n.shape[0],s=n.shape[1]);let i=D.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:r,outSize:Math.ceil(s/i)},u=new eue(o,a,n==null),d=[t];n!=null&&d.push(n);let c=e.runWebGLProgram(u,d,"int32");if(c.shape[1]===1)return c;let f=v3(e,t,a,c);return e.disposeIntermediateTensorInfo(c),f}function x3(e,t,a,n=null){let r=n!=null?n.shape:t.shape,s=r[r.length-1],i=D.computeOptimalWindowSize(s),o=new tue(r,i,a,n==null),u=n==null?[t]:[t,n],d=e.runWebGLProgram(o,u,"int32");if(d.shape.length===t.shape.length){let c=x3(e,t,a,d);return e.disposeIntermediateTensorInfo(d),c}return d}function w3(e,t,a,n){let r=[a];if(D.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),r,t.shape.length),!ie().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,u=t;o&&(u=e.unpackTensor(t),s.push(u));let[d,c]=D.computeOutAndReduceShapes(u.shape,r),f=C.sizeFromShape(c),m=Ee({inputs:{x:u},backend:e,attrs:{shape:[-1,f]}});s.push(m);let g=v3(e,m,n);s.push(g);let b=Ee({inputs:{x:g},backend:e,attrs:{shape:d}});return s.forEach(v=>e.disposeIntermediateTensorInfo(v)),b}return x3(e,t,n)}function aue(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s}=n,i=C.parseAxisParam(s,r.shape),o=D.getAxesPermutation(i,r.shape.length),u=r,d=[];o!=null&&(u=En({inputs:{x:r},backend:a,attrs:{perm:o}}),d.push(u),i=D.getInnerMostAxes(i.length,u.shape.length)),D.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let c=w3(a,u,i[0],"max");return d.forEach(f=>a.disposeIntermediateTensorInfo(f)),c}var nue={kernelName:Zd,backendName:"webgl",kernelFunc:aue};function rue(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s}=n,i=C.parseAxisParam(s,r.shape),o=D.getAxesPermutation(i,r.shape.length),u=r,d=[];o!=null&&(u=En({inputs:{x:r},backend:a,attrs:{perm:o}}),d.push(u),i=D.getInnerMostAxes(i.length,u.shape.length)),D.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let c=w3(a,u,i[0],"min");return d.forEach(f=>a.disposeIntermediateTensorInfo(f)),c}var sue={kernelName:Qd,backendName:"webgl",kernelFunc:rue},iue=Kr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,oue=Tt({opSnippet:iue}),lue={kernelName:uu,backendName:"webgl",kernelFunc:oue},uue=Kr+"return log(x + sqrt(x * x + 1.0));",cue=Tt({opSnippet:uue}),due={kernelName:cu,backendName:"webgl",kernelFunc:cue},hue=Kr+`
  return atan(x);
`,pue=Tt({opSnippet:hue}),fue={kernelName:du,backendName:"webgl",kernelFunc:pue},mue=bI+`
  return atan(a, b);
`,gue=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dc+`
  return result;
`,yue=hn({opSnippet:mue,packedOpSnippet:gue}),bue={kernelName:pu,backendName:"webgl",kernelFunc:yue},vue=Kr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,xue=Tt({opSnippet:vue}),wue={kernelName:hu,backendName:"webgl",kernelFunc:xue},nm=class{constructor(e,t,a,n=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&a)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,c=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;let b=t==="avg",v=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,k="0.0";if(b||(k="-1.0 / 1e-20"),a){let M=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${m}, ${g});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${d}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${M} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${n?r?v:x:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let S="max",N=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(N="avgValue / max(count, 1.0)");let T=Math.floor(s/4)*4,_=s%4,R=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${m}, ${g});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${T}; wC += 4) {
            int xC = xCCorner + wC * ${d};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              getValue(batch, xR, xC + 3 * ${d}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${T};
          if (${_===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${_===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${_===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${d}, d),
              getValue(batch, xR, xC + 2 * ${d}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${N});
      }
    `}},xI=class{constructor(e,t,a,n=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&a)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,u=e.strideWidth,d=e.dilationDepth,c=e.dilationHeight,f=e.dilationWidth,m=e.effectiveFilterDepth,g=e.effectiveFilterHeight,b=e.effectiveFilterWidth,v=e.padInfo.front,x=e.padInfo.top,k=e.padInfo.left;this.outputShape=e.outShape;let S=t==="avg",N="0.0";if(S||(N="-1.0 / 1e-20"),a){let B=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${u});
        const ivec3 pads = ivec3(${v}, ${x}, ${k});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${m};
              wD += ${d}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${g};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${b};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${B} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${n?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${g} * ${b} +
                      wR * ${b} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let T="max",_=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / max(count, 1.0)");let R=Math.floor(s/4)*4,M=s%4,F=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${u});
      const ivec3 pads = ivec3(${v}, ${x}, ${k});
      const float initializationValue = ${N};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${N});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${d}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${F}
            }

            int xC = xCCorner + ${R};
            if (${M===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${M===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${M===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${F}
            }
          }
        }
        setOutput(${_});
      }
    `}};function kue(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t;lp(r,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=n,d=1;C.assert(D.eitherStridesOrDilationsAreOne(i,d),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=D.computePool2DInfo(r.shape,s,i,d,o,u);if(c.filterWidth===1&&c.filterHeight===1&&C.arraysEqual(c.inShape,c.outShape))return cr({inputs:{x:r},backend:a});let f=new nm(c,"avg",!1);return a.runWebGLProgram(f,[r],"float32")}var Sue={kernelName:fu,backendName:"webgl",kernelFunc:kue};function Iue(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=n,c=[1,1,1],f=D.computePool3DInfo(r.shape,s,i,c,o,u,d),m=new xI(f,"avg",!1);return a.runWebGLProgram(m,[r],"float32")}var Nue={kernelName:Jd,backendName:"webgl",kernelFunc:Iue},Tue=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,a=e.filterWidth,n=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=o-1-e.padInfo.top,c=u-1-e.padInfo.left,f=1/(t*a);this.userCode=`
      const ivec2 pads = ivec2(${d}, ${c});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},_ue=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,a=e.filterHeight,n=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,c=e.effectiveFilterDepth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=c-1-e.padInfo.front,b=f-1-e.padInfo.top,v=m-1-e.padInfo.left,x=1/(t*a*n);this.userCode=`
      const ivec3 pads = ivec3(${g}, ${b}, ${v});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${m};
                wC += ${d}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Cue(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:u,pad:d,dimRoundingMode:c}=n,f=[1,1,1],m=D.computePool3DInfo(i.shape,o,u,f,d,c),g=new _ue(m);return a.runWebGLProgram(g,[r],i.dtype)}var Eue={kernelName:dm,backendName:"webgl",kernelFunc:Cue};function Aue(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,i=s;lp([r,s],"avgPoolGrad");let{filterSize:o,strides:u,pad:d}=n,c=D.computePool2DInfo(i.shape,o,u,1,d),f=new Tue(c);return a.runWebGLProgram(f,[r],i.dtype)}var $ue={kernelName:cm,backendName:"webgl",kernelFunc:Aue};function Rue(e){let{inputs:t,backend:a,attrs:n}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=n;return gb({a:r,b:s,transposeA:i,transposeB:o,backend:a})}var Due={kernelName:mu,backendName:"webgl",kernelFunc:Rue},Mue=class{constructor(e,t,a,n,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],D.assertAndGetBroadcastShape(e,t),D.assertAndGetBroadcastShape(e,a);let i="0.0";n!=null&&(D.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";r!=null&&(D.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${s}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},Fue=class{constructor(e,t,a,n,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],D.assertAndGetBroadcastShape(e,t),D.assertAndGetBroadcastShape(e,a);let i="vec4(0.0)";n!=null&&(D.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";r!=null&&(D.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${s}));

        setOutput((x - mean) * inv + offset);
      }
    `}},Oue=({inputs:e,backend:t,attrs:a})=>{let{x:n,mean:r,variance:s,offset:i,scale:o}=e;C.assert(r.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C.assert(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C.assert(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=a;u==null&&(u=.001);let d=[n,r,s],c=null;i!=null&&(c=i.shape,d.push(i));let f=null;o!=null&&(f=o.shape,d.push(o));let m=ie().getBool("WEBGL_PACK_NORMALIZATION")?new Fue(n.shape,r.shape,s.shape,c,f,u):new Mue(n.shape,r.shape,s.shape,c,f,u);return t.runWebGLProgram(m,d,d[0].dtype)},zue={kernelName:Du,backendName:"webgl",kernelFunc:Oue},Lue=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=qt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let a=Bue(this.rank),n,r=e.map((s,i)=>`sourceLoc.${y1[i]} = start[${i}] + coords.${y1[i]};`);n=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${n}
        setOutput(getSource(${a}));
      }
    `}},y1=["x","y","z","w","u","v"];function Bue(e){if(e===1)return"sourceLoc";if(e<=6)return y1.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var Uue=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=qt(this.rank),a=Tn("coords",this.rank),n=Tn("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${n.slice(-2).join()})`,s=`getChannel(getSource(${n.join()}), ${r})`,i=`
      result.x = ${s};
      if (++${a[this.rank-1]} < ${e[this.rank-1]}) {
        ++${n[this.rank-1]};
        result.y = ${s};
        --${n[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${a[this.rank-1]};
      if (++${a[this.rank-2]} < ${e[this.rank-2]}) {
        ++${n[this.rank-2]};
        result.z = ${s};
        if (++${a[this.rank-1]} < ${e[this.rank-1]}) {
          ++${n[this.rank-1]};
          result.w = ${s};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((d,c)=>`start[${c}]`).join()});`:e.map((d,c)=>`${n[c]} = ${a[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function Pue(e,t,a,n){let r=n.texData.get(e.dataId),s=n.makeTensorInfo(a,e.dtype),i=n.texData.get(s.dataId);Object.assign(i,r),i.refCount=1,i.shape=a,i.dtype=e.dtype;let o=Pa.computeFlatOffset(t,C.computeStrides(e.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};let u=n.dataRefCount.get(i.slice.origDataId)||1;return n.dataRefCount.set(i.slice.origDataId,u+1),s}function mp(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{begin:s,size:i}=n,[o,u]=Pa.parseSliceParams(r,s,i);if(Pa.assertParamsValid(r,o,u),C.sizeFromShape(u)===0)return a.makeTensorInfo(u,r.dtype,[]);if(a.shouldExecuteOnCPU([r])||r.dtype==="string"){let f=a.texData.get(r.dataId),m=$oe(f.values,o,u,r.shape,r.dtype);return a.makeTensorInfo(u,r.dtype,m)}let{isPacked:d}=a.texData.get(r.dataId),c=Pa.isSliceContinous(r.shape,o,u);if(d||!c){let f=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Uue(u):new Lue(u),m=[o];return a.runWebGLProgram(f,[r],r.dtype,m)}return a.uploadToGPU(r.dataId),Pue(r,o,u,a)}var Wue={kernelName:Bh,backendName:"webgl",kernelFunc:mp},Vue=e=>{let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{blockShape:s,crops:i}=n;C.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((S,N)=>S*N),u=D.getReshaped(r.shape,s,o),d=D.getPermuted(u.length,s.length),c=D.getReshapedPermuted(r.shape,s,o),f=D.getSliceBeginCoords(i,s.length),m=D.getSliceSize(c,i,s.length),g=[],b=Ee({inputs:{x:r},backend:a,attrs:{shape:u}}),v=En({inputs:{x:b},backend:a,attrs:{perm:d}}),x=Ee({inputs:{x:v},backend:a,attrs:{shape:c}}),k=mp({inputs:{x},backend:a,attrs:{begin:f,size:m}});return g.push(b),g.push(v),g.push(x),g.forEach(S=>a.disposeIntermediateTensorInfo(S)),k},Gue={kernelName:eh,backendName:"webgl",kernelFunc:Vue};function Hue(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,weights:s}=t,{size:i}=n,o=a.readSync(r.dataId),u=a.readSync(s.dataId),d=i3(o,u,s.dtype,s.shape,i);return a.makeTensorInfo([i],s.dtype,d)}var que={kernelName:th,backendName:"webgl",kernelFunc:Hue},jue=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Kue=`
  return float(int(a.r) & int(b.r));
`;function Xue(e){let{inputs:t,backend:a}=e,{a:n,b:r}=t,s=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ie().getNumber("WEBGL_VERSION");if(a.shouldExecuteOnCPU([n,r])||i===1){let u=a.texData.get(n.dataId).values,d=a.texData.get(r.dataId).values,[c,f]=toe(n.shape,r.shape,u,d,n.dtype),m=a.makeTensorInfo(f,n.dtype),g=a.texData.get(m.dataId);return g.values=c,m}let o;return s?o=new pp(jue,n.shape,r.shape,!1):o=new au(Kue,n.shape,r.shape),a.runWebGLProgram(o,[n,r],n.dtype)}var Yue={kernelName:ah,backendName:"webgl",kernelFunc:Xue};function Zue(e){let{inputs:t,backend:a}=e,{s0:n,s1:r}=t,s=a.readSync(n.dataId),i=a.readSync(r.dataId),o=D.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return a.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Que={kernelName:hm,backendName:"webgl",kernelFunc:Zue},Jue="return float(a != b);",k3=hn({opSnippet:Jue,cpuKernelImpl:koe,dtype:"bool"}),ece={kernelName:Th,backendName:"webgl",kernelFunc:k3};function lg(e){let{inputs:t,backend:a}=e,{input:n}=t,r=a.texData.get(n.dataId);return cr({inputs:{x:r.complexTensorInfos.real},backend:a})}var tce={kernelName:Lb,backendName:"webgl",kernelFunc:lg},ace="return float(int(x));";function nce(e,t){let a=new Os(e.shape,ace),n=t.runWebGLProgram(a,[e],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function b1(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{dtype:s}=n;if(s==="complex64"){if(r.dtype==="complex64")return cr({inputs:{x:r},backend:a});let i=da(r.shape),o=b1({inputs:{x:r},backend:a,attrs:{dtype:"float32"}}),u=qo({inputs:{real:o,imag:i},backend:a});return i.dispose(),a.disposeIntermediateTensorInfo(o),u}if(r.dtype==="complex64"){let i=lg({inputs:{input:r},backend:a}),o=b1({inputs:{x:i},backend:a,attrs:{dtype:s}});return a.disposeIntermediateTensorInfo(i),o}if(!C.hasEncodingLoss(r.dtype,s)){let i=cr({inputs:{x:r},backend:a});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(a.shouldExecuteOnCPU([r])){let i=a.texData.get(r.dataId).values,[o,u,d]=aoe(i,r.shape,r.dtype,s);return a.makeTensorInfo(o,u,d)}if(s==="int32")return nce(r,a);if(s==="bool"){let i=a.makeTensorInfo([],"bool",C.getTypedArrayFromDType("bool",1)),o=k3({inputs:{a:r,b:i},backend:a});return a.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${s}`)}var rce={kernelName:gu,backendName:"webgl",kernelFunc:b1},GE="return ceil(x);",sce=Tt({opSnippet:GE,packedOpSnippet:GE,cpuKernelImpl:noe}),ice={kernelName:yu,backendName:"webgl",kernelFunc:sce},oce=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},lce=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function uce(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=n,o;ie().getBool("WEBGL_PACK_CLIP")?o=new lce(r.shape):o=new oce(r.shape);let u=[[s],[i]];return a.runWebGLProgram(o,[r],r.dtype,u)}var cce={kernelName:zo,backendName:"webgl",kernelFunc:uce},dce=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function HE(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function hce(e){let{inputs:t,backend:a}=e,{x:n}=t,r=a.texData.get(n.dataId),s=new dce(n.shape),i=[HE(n,r.complexTensorInfos.real),HE(n,r.complexTensorInfos.imag)];return a.runWebGLProgram(s,i,i[0].dtype)}var pce={kernelName:pm,backendName:"webgl",kernelFunc:hce},fce=class{constructor(e){this.outputShape=[],this.outputShape=D.computeOutShape(e,1),this.variableNames=e.map((s,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let a=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let i=t[s-1];a.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${i}));`)}let n=t.length,r=t[t.length-1];a.push(`else setOutput(getT${n}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${a.join(`
        `)}
      }
    `}},mce=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=D.computeOutShape(e,t);let a=this.outputShape,n=a.length,r=qt(n),s=Tn("coords",n),i=["x","y","z","w","u","v"].slice(0,n);this.variableNames=e.map((b,v)=>`T${v}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let b=1;b<o.length;b++)o[b]=o[b-1]+e[b][t];let u=i[t],d=i.slice(-2),c=i.join(),f=`if (${u} < ${o[0]}) {
        return getChannel(
            getT0(${c}), vec2(${d.join()}));
        }`;for(let b=1;b<o.length;b++){let v=o[b-1];f+=`
        if (${u} < ${o[b]}  && ${u} >= ${o[b-1]}) {
          return getChannel(
            getT${b}(${Dy(i,u,v)}),
            vec2(${Dy(d,u,v)}));
        }`}let m=o.length,g=o[o.length-1];f+=`
        return getChannel(
          getT${m}(${Dy(i,u,g)}),
          vec2(${Dy(d,u,g)}));`,this.userCode=`
      float getValue(${i.map(b=>"int "+b)}) {
        ${f}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${s}), 0., 0., 0.);

        ${s[n-1]} = ${s[n-1]} + 1;
        if (${s[n-1]} < ${a[n-1]}) {
          result.g = getValue(${s});
        }

        ${s[n-2]} = ${s[n-2]} + 1;
        if (${s[n-2]} < ${a[n-2]}) {
          result.a = getValue(${s});
        }

        ${s[n-1]} = ${s[n-1]} - 1;
        if (${s[n-2]} < ${a[n-2]} &&
            ${s[n-1]} < ${a[n-1]}) {
          result.b = getValue(${s});
        }
        setOutput(result);
      }
    `}};function Dy(e,t,a){let n=e.indexOf(t);return e.map((r,s)=>s===n?`${r} - ${a}`:r).join()}function Kv(e){let{inputs:t,backend:a}=e,{input:n}=t,r=a.texData.get(n.dataId);return cr({inputs:{x:r.complexTensorInfos.imag},backend:a})}var gce={kernelName:Mb,backendName:"webgl",kernelFunc:Kv};function Ff(e,t,a){let n=e[0].dtype;if(n==="complex64"){let g=e.map(S=>lg({inputs:{input:S},backend:a})),b=e.map(S=>Kv({inputs:{input:S},backend:a})),v=Ff(g,t,a),x=Ff(b,t,a),k=qo({inputs:{real:v,imag:x},backend:a});return g.forEach(S=>a.disposeIntermediateTensorInfo(S)),b.forEach(S=>a.disposeIntermediateTensorInfo(S)),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),k}let r=a.shouldExecuteOnCPU(e);if(n==="string"&&(r=!0),r){let g=e.map(T=>{let _=[-1,C.sizeFromShape(T.shape.slice(t))];return Ee({inputs:{x:T},backend:a,attrs:{shape:_}})}),b=g.map(T=>({vals:a.readSync(T.dataId),shape:T.shape})),v=D.computeOutShape(g.map(T=>T.shape),1),x=g[0].shape[0]===1,k=roe(b,v,n,x),S=D.computeOutShape(e.map(T=>T.shape),t),N=a.makeTensorInfo(S,n,k);return g.forEach(T=>a.disposeIntermediateTensorInfo(T)),N}let s=e.filter(g=>C.sizeFromShape(g.shape)>0),i=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let g=i?new Os(e[0].shape,co):new go(e[0].shape,co);return a.runWebGLProgram(g,e,n)}let o=ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){let g=[];for(let v=0;v<s.length;v+=o){let x=s.slice(v,v+o);g.push(Ff(x,t,a))}let b=Ff(g,t,a);for(let v of g)a.disposeIntermediateTensorInfo(v);return b}if(i){let g=new mce(s.map(b=>b.shape),t);return a.runWebGLProgram(g,s,n)}let{tensors2D:u,outShape:d}=yce(s,t,a),c=new fce(u.map(g=>g.shape)),f=a.runWebGLProgram(c,u,n);u.forEach(g=>a.disposeIntermediateTensorInfo(g));let m=Ee({inputs:{x:f},attrs:{shape:d},backend:a});return a.disposeIntermediateTensorInfo(f),m}function yce(e,t,a){let n=D.computeOutShape(e.map(r=>r.shape),t);return{tensors2D:e.map(r=>Ee({inputs:{x:r},attrs:{shape:[-1,C.sizeFromShape(r.shape.slice(t))]},backend:a})),outShape:n}}function S3(e){let{inputs:t,backend:a,attrs:n}=e,{axis:r}=n,s=C.parseAxisParam(r,t[0].shape)[0],i=t.map(d=>d.shape);D.assertParamsConsistent(i,s);let o=D.computeOutShape(t.map(d=>d.shape),s);if(C.sizeFromShape(o)===0)return a.makeTensorInfo(o,t[0].dtype,[]);let u=t.filter(d=>C.sizeFromShape(d.shape)>0);return u.length===1?cr({inputs:{x:u[0]},backend:a}):Ff(u,s,a)}var bce={kernelName:nh,backendName:"webgl",kernelFunc:S3},I3=class{constructor(e,t=!1,a=null,n=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,u=e.strideWidth,d=e.dilationHeight,c=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,b=e.inChannels%4,v=e.dataFormat==="channelsLast",x=v?1:2,k=v?2:3,S=v?3:1,N="",T="";a&&(n?N=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:r?N=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:N=`
          float activation(float x) {
            ${a}
          }
        `,T="result = activation(result);");let _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${N}

      const ivec2 strides = ivec2(${o}, ${u});
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${S}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${k}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${g}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${b===1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${g}) *
                    getW(wR, wC, ${g}, d2);
              } else {
                dotProd +=
                    getX(batch, ${g}, xR, xC) *
                    getW(wR, wC, ${g}, d2);
              }

            } else if (${b===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${b===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2),
                getW(wR, wC, ${g} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1),
                  getX(batch, xR, xC, ${g} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC),
                  getX(batch, ${g} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${T}
        setOutput(result);
      }
    `}},vce=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,a=e.padInfo.top,n=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,u=e.dilationHeight,d=e.dilationWidth,c=e.filterDepth,f=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,b=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${s}, ${i});
      const ivec3 pads = ivec3(${t}, ${a}, ${n});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m}; wC++) {
              int xC = xCCorner + wC * ${d};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${g}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${b===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${g}) *
                  getW(wF, wR, wC, ${g}, d2);
              } else if (${b===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${b===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1),
                  getX(batch, xF, xR, xC, ${g} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2),
                  getW(wF, wR, wC, ${g} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},N3=class{constructor(e,t=!1,a=null,n=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xn(this.outputShape.length);let s=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,c=d,f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<d;v++)f+=`
           vec4 xTexelC${v*2};
           int xTexelC${v*2}Ready;
           vec4 xTexelC${v*2+1};
           int xTexelC${v*2+1}Ready;
           vec4 xC${v};`;f+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let v=0;v<d;v++)f+=`
           xTexelC${v*2} = vec4(0.0);
           xTexelC${v*2}Ready = 0;
           xTexelC${v*2+1} = vec4(0.0);
           xTexelC${v*2+1}Ready = 0;
           xC${v} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(c+1)/2;v++){let x=v*2;if(f+=`
           xC = xCCorner + ${x*o};
           `,i===1){if(x<d&&(s%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,o===1&&x>0?f+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<d)){let k=s%2===0?C.nearestLargerEven(o):o;o%2===0&&s%2===1||o%2!==0&&s%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${k};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,o>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:f+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):k===1?f+=`
                     xC${x+1} = xTexelC${x};
                     `:f+=`
                     xCOffset = xC + ${k};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<d&&(s%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<d&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<d&&(f+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<d&&(f+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<d&&(f+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let m="",g="";a&&(n?m=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${a}
         }`:r?m=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${a}
         }`:m=`vec4 activation(vec4 x) {
           ${a}
         }`,g="result = activation(result);");let b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${m}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${b}
         ${g}
         setOutput(result);
       }
     `}},xce=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=xn(this.outputShape.length);let{dataFormat:a}=t,n=Mn(),r=a==="channelsLast",s=r?1:2,i=r?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,u="";for(let d=0;d<=1;d++)for(let c=0;c<=1;c++)u+=`
          blockIndex = rc.z + ${c};
          pos = rc.y + ${d};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${s}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${d*2+c}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${d*2+c}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${n.output} = result;
      }
    `}};function yb(e,t){let a=e.length;return a>=3?t?[...e.slice(0,-3),e[a-3]*e[a-2],e[a-1]]:[...e.slice(0,-3),e[a-3],e[a-2]*e[a-1]]:!t&&a===1&&e[0]>1?[e[0],1]:null}function T3({x:e,filter:t,convInfo:a,backend:n,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let u=e.shape,d=n.texData.get(e.dataId),c=a.inChannels,f=u[0]*u[1]*u[2],m=a.outChannels,g=a.dataFormat==="channelsLast",b=!1,v=!1,x,k=[];if(s!=null){let S=yb(s.shape,g);S!=null&&(s=Ee({inputs:{x:s},backend:n,attrs:{shape:S}}),k.push(s))}if(r!=null){let S=yb(r.shape,g);S!=null&&(r=Ee({inputs:{x:r},backend:n,attrs:{shape:S}}),k.push(r))}if(!((f===1||m===1)&&c>b3)&&d.isPacked&&g&&d.texture!=null&&u[2]%2!==0&&C.arraysEqual(d.shape.slice(-3),u.slice(-3))){let S=u[0]*u[1]*(u[2]+1),N={dataId:e.dataId,shape:[1,S,a.inChannels],dtype:e.dtype},T=d.shape;d.shape=d.shape.slice(),d.shape[d.shape.length-2]++,C.assert(tm(d.shape,N.shape),()=>`packed reshape ${d.shape} to ${N.shape} isn't free`);let _=Ee({inputs:{x:t},backend:n,attrs:{shape:[1,a.inChannels,a.outChannels]}});k.push(_);let R=gb({a:N,b:_,backend:n,transposeA:b,transposeB:v,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),M=n.texData.get(R.dataId);C.assert(M.isPacked,()=>"batchMatMul result is expected to be packed"),d.shape=T,M.shape=a.outShape,x=cr({inputs:{x:R},backend:n}),x.shape=a.outShape,k.push(R)}else{let S=a.outHeight*a.outWidth,N=Ee({inputs:{x:e},backend:n,attrs:{shape:g?[a.batchSize,S,a.inChannels]:[a.batchSize,a.inChannels,S]}}),T=Ee({inputs:{x:t},backend:n,attrs:{shape:[1,a.inChannels,a.outChannels]}}),_=gb({a:g?N:T,b:g?T:N,transposeA:!g,transposeB:v,backend:n,bias:r,activation:o,preluActivationWeights:s,leakyreluAlpha:i});x=Ee({inputs:{x:_},backend:n,attrs:{shape:a.outShape}}),k.push(N),k.push(T),k.push(_)}for(let S of k)n.disposeIntermediateTensorInfo(S);return x}function _3({x:e,filter:t,convInfo:a,backend:n,bias:r=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:u,filterHeight:d,inChannels:c,outWidth:f,outHeight:m,dataFormat:g}=a,b=g==="channelsLast",v=u*d*c,x=m*f,k=[a.batchSize,v,x],S=!0,N=!1,T=[];if(s!=null){let Q=yb(s.shape,b);Q!=null&&(s=Ee({inputs:{x:s},backend:n,attrs:{shape:Q}}),T.push(s))}if(r!=null){let Q=yb(r.shape,b);Q!=null&&(r=Ee({inputs:{x:r},backend:n,attrs:{shape:Q}}),T.push(r))}let _=Ee({inputs:{x:t},backend:n,attrs:{shape:[1,v,C.sizeFromShape(t.shape)/v]}});T.push(_);let R=new xce(k,a),M=[e.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],F=n.runWebGLProgram(R,[e],"float32",M),B=Ee({inputs:{x:F},backend:n,attrs:{shape:k}});T.push(F),T.push(B);let V=r!=null,P=s!=null,A=o==="leakyrelu",G=o?am(o,!0):null,J=new y3(b?B.shape:_.shape,b?_.shape:B.shape,b?[a.batchSize,x,a.outChannels]:[a.batchSize,a.outChannels,x],S,N,V,G,P,A),ee=b?[B,_]:[_,B];if(r&&ee.push(r),P&&ee.push(s),A){let Q=n.makeTensorInfo([],"float32",C.createScalarValue(i,"float32"));ee.push(Q),T.push(Q)}let W=n.runWebGLProgram(J,ee,"float32"),X=Ee({inputs:{x:W},backend:n,attrs:{shape:a.outShape}});T.push(W);for(let Q of T)n.disposeIntermediateTensorInfo(Q);return X}function wce(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s}=t,{strides:i,pad:o,dataFormat:u,dilations:d,dimRoundingMode:c}=n,f=D.convertConv2DDataFormat(u),m=D.computeConv2DInfo(r.shape,s.shape,i,d,o,c,!1,f),g;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))g=T3({x:r,filter:s,convInfo:m,backend:a});else if(m.strideWidth<=2&&f==="channelsLast"&&ie().getBool("WEBGL_EXP_CONV")){let v=new N3(m),x=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];g=a.runWebGLProgram(v,[r,s],"float32",x)}else if(ie().getBool("WEBGL_CONV_IM2COL"))g=_3({x:r,filter:s,convInfo:m,backend:a});else{let v=new I3(m);g=a.runWebGLProgram(v,[r,s],"float32")}let b=Ee({inputs:{x:g},backend:a,attrs:{shape:m.outShape}});return a.disposeIntermediateTensorInfo(g),b}var kce={kernelName:bu,backendName:"webgl",kernelFunc:wce},Sce=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,a=e.strideWidth,n=e.padInfo.top,r=e.padInfo.left,s=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${n};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${a} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${s?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Ice=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,a=e.filterWidth,n=e.strideHeight,r=e.strideWidth,s=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=a-1-e.padInfo.left,u=s?1:2,d=s?2:3,c=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${d}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${a} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${s}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Nce=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,a=e.strideHeight,n=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${a} - ${s};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${n} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Tce=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,a=e.filterHeight,n=e.filterWidth,r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,u=a-1-e.padInfo.top,d=n-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${u}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${a}; wR++) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${a} - 1 - wR;

            for (int wC = 0; wC < ${n}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${n} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function _ce(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,dy:s}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:d,filterShape:c}=n,f=D.convertConv2DDataFormat(u),m=D.computeConv2DInfo(r.shape,c,i,1,o,d,!1,f),g=new Sce(m);return a.runWebGLProgram(g,[r,s],"float32")}var Cce={kernelName:_b,backendName:"webgl",kernelFunc:_ce},Ece=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=xn(this.outputShape.length);let t=e.filterHeight,a=e.filterWidth,n=t-1-e.padInfo.top,r=a-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${n}, ${r});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${a}; wC++) {
            int wCPerm = ${a} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function Ace(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,filter:s}=t,{inputShape:i,strides:o,pad:u,dataFormat:d,dimRoundingMode:c}=n,f=D.convertConv2DDataFormat(d),m=D.computeConv2DInfo(i,s.shape,o,1,u,c,!1,f);if(ie().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){let g=[[m.strideHeight,m.strideWidth]],b=new Ece(m);return a.runWebGLProgram(b,[r,s],"float32",g)}else{let g=new Ice(m);return a.runWebGLProgram(g,[r,s],"float32")}}var $ce={kernelName:vu,backendName:"webgl",kernelFunc:Ace};function Rce(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=n,d=D.computeConv3DInfo(r.shape,s.shape,i,u,o),c=new vce(d);return a.runWebGLProgram(c,[r,s],"float32")}var Dce={kernelName:xu,backendName:"webgl",kernelFunc:Rce};function Mce(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:u}=n,d=D.computeConv3DInfo(r.shape,u,i,1,o),c=new Nce(d);return a.runWebGLProgram(c,[r,s],"float32")}var Fce={kernelName:rh,backendName:"webgl",kernelFunc:Mce};function Oce(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:u}=n,d=D.computeConv3DInfo(u,s.shape,o,1,i),c=new Tce(d);return a.runWebGLProgram(c,[r,s],"float32")}var zce={kernelName:sh,backendName:"webgl",kernelFunc:Oce},Lce=fp+`
  return cos(x);
`,Bce=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Dc}
  return result;
`,Uce=Tt({opSnippet:Lce,packedOpSnippet:Bce}),Pce={kernelName:wu,backendName:"webgl",kernelFunc:Uce},Wce=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Vce=Tt({opSnippet:Wce}),Gce={kernelName:ku,backendName:"webgl",kernelFunc:Vce},Hce=class{constructor(e,t,a,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,u]=e,[d]=t,[c,f]=a;this.outputShape=[d,c,f,u];let m=n==="bilinear"?1:0,[g,b]=[`${i-1}.0`,`${o-1}.0`],[v,x,k]=c>1?[`${(i-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${g} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${g}`],[S,N,T]=f>1?[`${(o-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${b} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${b}`];this.userCode=`
      const float height_ratio = float(${v});
      const float width_ratio = float(${S});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${s}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${N};

        float in_y = ${k};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${T};
        if( in_x < 0.0 || in_x > ${b} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${m} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},qce=e=>{let{inputs:t,backend:a,attrs:n}=e,{image:r,boxes:s,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:d}=n,c=new Hce(r.shape,s.shape,o,u,d);return a.runWebGLProgram(c,[r,s,i],"float32")},jce={kernelName:oh,backendName:"webgl",kernelFunc:qce},rm;(function(e){e.Prod="*",e.Sum="+"})(rm||(rm={}));var qE=class{constructor(e,t,a,n){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let r=this.outputShape.length,s=this.op===rm.Prod?"1.0":"0.0",i=a?s:`getX(${jE(r,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],u="",d="";a?(u=n?`end != ${o-1}`:"end != 0",d=n?"end + 1":"end - 1"):(u=n?`end + pow2 < ${o}`:"end >= pow2",d=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${qt(r)} coords = getOutputCoords();
        int end = ${KE(r,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${d};
          ${KE(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${jE(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function jE(e,t,a){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${a} for rank ${e} is not yet supported`)}function KE(e,t,a){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${a} for rank ${e} is not yet supported`)}function C3(e,t,a,n,r,s){let i=t.shape.length,o=D.getAxesPermutation([n],i),u=t;o!=null&&(u=En({inputs:{x:t},backend:a,attrs:{perm:o}}));let d=D.getInnerMostAxes(1,i)[0];if(d!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let c=u.shape[d],f=cr({inputs:{x:u},backend:a});for(let m=0;m<=Math.ceil(Math.log2(c))-1;m++){let g=new qE(e,u.shape,!1,s),b=[[m]],v=f;f=a.runWebGLProgram(g,[f],f.dtype,b),a.disposeIntermediateTensorInfo(v)}if(r){let m=new qE(e,u.shape,r,s),g=f;f=a.runWebGLProgram(m,[f],f.dtype),a.disposeIntermediateTensorInfo(g)}if(o!=null){let m=D.getUndoAxesPermutation(o),g=En({inputs:{x:f},backend:a,attrs:{perm:m}});return a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(u),g}return f}function Kce(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=n;return C3(rm.Prod,r,a,s,i,o)}var Xce={kernelName:ih,backendName:"webgl",kernelFunc:Kce};function Yce(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=n;return C3(rm.Sum,r,a,s,i,o)}var Zce={kernelName:Su,backendName:"webgl",kernelFunc:Yce};function Qce(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,weights:s}=t,{size:i,binaryOutput:o}=n;if(r.shape.length===1){let u=a.readSync(r.dataId),d=a.readSync(s.dataId),c=i3(u,d,s.dtype,s.shape,i);return a.makeTensorInfo([i],s.dtype,c)}else if(r.shape.length===2){let u=a.bufferSync(r),d=a.bufferSync(s),c=eoe(u,d,i,o);return a.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}var Jce={kernelName:fm,backendName:"webgl",kernelFunc:Qce},ede=class{constructor(e,t,a){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=a,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function tde(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{blockSize:s,dataFormat:i}=n,o=r.shape[0],u=i==="NHWC"?r.shape[1]:r.shape[2],d=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],f=u*s,m=d*s,g=c/(s*s),b=i==="NHWC"?[o,f,m,g]:[o,g,f,m],v=new ede(b,s,i);return a.runWebGLProgram(v,[r],r.dtype)}var ade={kernelName:lh,backendName:"webgl",kernelFunc:tde},E3=class{constructor(e,t=!1,a=null,n=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xn(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,u="",d="";a&&(n?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:r?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:u=`
          float activation(float x) {
            ${a}
          }
        `,d="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${s}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${d}
        setOutput(result);
      }
    `}},A3=class{constructor(e,t=!1,a=null,n=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xn(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,u=e.dilationWidth,d=e.filterHeight,c=e.filterWidth,f=c,m=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<c;x++)m+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;m+=`
    for (int r = 0; r < ${d}; r++) {
      `;for(let x=0;x<c;x++)m+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;m+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(f+1)/2;x++){let k=x*2;if(m+=`
          xC = xCCorner + ${k*u};
          `,o===1){if(k<c&&(i%2===1?(m+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k}Ready == 0) {
                  xTexelC${k} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${k}.zw = vec2(0.0);
                  }
                  xTexelC${k}Ready = 1;
                }
              `,u===1&&k>0?m+=`
                xC${k} = vec4(xTexelC${k-2}.zw, xTexelC${k}.xy);
                `:m+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${k} = vec4(previous.zw, xTexelC${k}.xy);
                  } else {
                    xC${k} = vec4(0.0, 0.0, xTexelC${k}.xy);
                  }
                  `):m+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${k}Ready == 0) {
                  xTexelC${k} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${k}.zw = vec2(0.0);
                  }
                  xTexelC${k}Ready = 1;
                }

                xC${k} = xTexelC${k};
                `,k+1<c)){let S=i%2===0?C.nearestLargerEven(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(m+=`
                  xCOffset = xC + imod(pads[1], 2) + ${S};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k+1}Ready == 0) {
                    xTexelC${k+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${k+1}.zw = vec2(0.0);
                    }
                    xTexelC${k+1}Ready = 1;
                  }
                  `,u>1?m+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${k+1} = vec4(previous.zw, xTexelC${k+1}.xy);
                    } else {
                     xC${k+1} = vec4(0.0, 0.0, xTexelC${k+1}.xy);
                    }
                    `:m+=`
                    xC${k+1} = vec4(xTexelC${k}.zw, xTexelC${k+1}.xy);
                    `):S===1?m+=`
                    xC${k+1} = xTexelC${k};
                    `:m+=`
                    xCOffset = xC + ${S};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k+1}Ready == 0) {
                      xTexelC${k+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${k+1}.zw = vec2(0.0);
                      }
                      xTexelC${k+1}Ready = 1;
                    }

                    xC${k+1} = xTexelC${k+1};
                    `}}else k<c&&(i%2===1?(m+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k}Ready == 0) {
                  xTexelC${k} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${k}.zw = vec2(0.0);
                  }
                  xTexelC${k}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${k+1}Ready == 0) {
                  xTexelC${k+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${k+1}.zw = vec2(0.0);
                  }
                  xTexelC${k+1}Ready = 1;
                }

                xC${k} = vec4(xTexelC${k}.zw, xTexelC${k+1}.zw);
              `,k+1<c&&(m+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${k+1} = vec4(xTexelC${k+1}.xy, final.xy);
                `)):(m+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${k}Ready == 0) {
                  xTexelC${k} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${k}.zw = vec2(0.0);
                  }
                  xTexelC${k}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${k+1}Ready == 0) {
                  xTexelC${k+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${k+1}.zw = vec2(0.);
                  }
                  xTexelC${k+1}Ready = 1;
                }

                xC${k} = vec4(
                  xTexelC${k}.xy, xTexelC${k+1}.xy);
              `,k+1<c&&(m+=`
                  xC${k+1} = vec4(xTexelC${k}.zw, xTexelC${k+1}.zw);
                `)));k<c&&(m+=`
            wTexel = getW(r, ${k}, d1, q);
            dotProd += xC${k} * vec4(wTexel.xz, wTexel.xz);
          `,k+1<c&&(m+=`
              wTexel = getW(r, ${k+1}, d1, q);
              dotProd += xC${k+1} * vec4(wTexel.xz, wTexel.xz);
            `))}m+=`
    }
  `,m+=`
      }
    `;let g="",b="";a&&(n?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:r?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,b="result = activation(result);");let v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${m}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${b}
        setOutput(result);
      }
    `}};function nde(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:d}=n,c=u;c==null&&(c=[1,1]),C.assert(D.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let f=D.computeConv2DInfo(r.shape,s.shape,i,c,o,d,!0),m;ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?m=new A3(f):m=new E3(f);let g=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return a.runWebGLProgram(m,[r,s],"float32",g)}var rde={kernelName:Iu,backendName:"webgl",kernelFunc:nde},sde=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,a=e.strideWidth,n=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${s} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${n};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${a} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},ide=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,a=e.filterWidth,n=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,i=a-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${a} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function ode(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,dy:s}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:d,filterShape:c}=n,f=D.computeConv2DInfo(r.shape,c,i,o,u,d,!0),m=new sde(f);return a.runWebGLProgram(m,[r,s],"float32")}var lde={kernelName:Cb,backendName:"webgl",kernelFunc:ode};function ude(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,filter:s}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:d,inputShape:c}=n,f=D.computeConv2DInfo(c,s.shape,i,o,u,d,!0),m=new ide(f);return a.runWebGLProgram(m,[r,s],"float32")}var cde={kernelName:Eb,backendName:"webgl",kernelFunc:ude},dde=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function hde(e){let{inputs:t,backend:a}=e,{x:n}=t,r=[...n.shape,...n.shape],s=C.sizeFromShape(n.shape),i=Ee({inputs:{x:n},backend:a,attrs:{shape:[s]}}),o=new dde(s),u=a.runWebGLProgram(o,[i],i.dtype),d=Ee({inputs:{x:u},backend:a,attrs:{shape:r}});return a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(u),d}var pde={kernelName:mm,backendName:"webgl",kernelFunc:hde},fde=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:a,padInfo:n,strideHeight:r,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:u,dilationWidth:d}=e,{top:c,left:f}=n;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${s});
      const ivec2 pads = ivec2(${c}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${d};

              if (wIn >= 0 && wIn < ${a}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function mde(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=n,d=D.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",u),c,f=new fde(d);c=a.runWebGLProgram(f,[r,s],"float32");let m=Ee({inputs:{x:c},backend:a,attrs:{shape:d.outShape}});return a.disposeIntermediateTensorInfo(c),m}var gde={kernelName:Nu,backendName:"webgl",kernelFunc:mde};function yde(e){let{inputs:t,backend:a,attrs:n}=e,{equation:r}=n,s=t,{allDims:i,summedDims:o,idDims:u}=D.decodeEinsumEquation(r,s.length);D.checkEinsumDimSizes(i.length,u,s);let{path:d,steps:c}=D.getEinsumComputePath(o,u),f=c.length,m=null,g=i.length,b=[];for(let v=0;v<f;++v){for(let x of c[v]){let{permutationIndices:k,expandDims:S}=D.getEinsumPermutation(g,u[x]),N;D.isIdentityPermutation(k)?N=s[x]:(N=En({inputs:{x:s[x]},backend:a,attrs:{perm:k}}),b.push(N));let T=N.shape.slice();for(let _=0;_<S.length;++_)T.splice(S[_],0,1);C.arraysEqual(N.shape,T)||(N=Ee({inputs:{x:N},backend:a,attrs:{shape:T}}),b.push(N)),m===null?m=N:(m=vI({inputs:{a:N,b:m},backend:a}),b.push(m))}v<f-1&&(d[v]>=0&&(m=jv({inputs:{x:m},backend:a,attrs:{axis:d[v]-(i.length-g),keepDims:!1}}),b.push(m)),g--)}for(let v of b)v!==m&&a.disposeIntermediateTensorInfo(v);return m}var bde={kernelName:$b,backendName:"webgl",kernelFunc:yde},vde="return (x >= 0.0) ? x : (exp(x) - 1.0);",xde=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,wde=Tt({opSnippet:vde,packedOpSnippet:xde}),kde={kernelName:_u,backendName:"webgl",kernelFunc:wde},Sde="return (b >= 0.0) ? a : a * (b + 1.0);",Ide=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Nde=e=>{let{inputs:t,backend:a}=e,{dy:n,y:r}=t,s=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new pp(Ide,n.shape,r.shape):new au(Sde,n.shape,r.shape);return a.runWebGLProgram(s,[n,r],n.dtype)},Tde={kernelName:uh,backendName:"webgl",kernelFunc:Nde},_de=`
  return vec4(equal(a, b));
`,Cde="return float(a == b);",Ede=hn({opSnippet:Cde,packedOpSnippet:_de,dtype:"bool",cpuKernelImpl:soe}),Ade={kernelName:ch,backendName:"webgl",kernelFunc:Ede},$de=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${D.ERF_P};
  float a1 = ${D.ERF_A1};
  float a2 = ${D.ERF_A2};
  float a3 = ${D.ERF_A3};
  float a4 = ${D.ERF_A4};
  float a5 = ${D.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Rde=Tt({opSnippet:$de}),Dde={kernelName:Cu,backendName:"webgl",kernelFunc:Rde},Mde=fp+`
  return exp(x);
`,Fde=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$3=Tt({opSnippet:Mde,packedOpSnippet:Fde,cpuKernelImpl:ioe,dtype:"float32"}),Ode={kernelName:Eu,backendName:"webgl",kernelFunc:$3};function v1(e){let{inputs:t,attrs:a,backend:n}=e,{dim:r}=a,{input:s}=t,i=s.shape.length,o=s.shape.slice(),u=r;return r<0&&(C.assert(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+r+1),o.splice(u,0,1),Ee({inputs:{x:s},backend:n,attrs:{shape:o}})}var zde={kernelName:dh,backendName:"webgl",kernelFunc:v1},XE="return exp(x) - 1.0;",Lde=Tt({opSnippet:XE,packedOpSnippet:XE,cpuKernelImpl:ooe}),Bde={kernelName:Au,backendName:"webgl",kernelFunc:Lde},YE=class{constructor(e,t,a){this.variableNames=["real","imag"];let n=t[1];this.outputShape=t;let r=a?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,s=a?`${n}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${n});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${n}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${s};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function R3(e,t,a){let n=a.texData.get(e.dataId),r=C.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=r/s,o=Ee({inputs:{x:e},backend:a,attrs:{shape:[i,s]}}),u=o.shape,d=new YE("real",u,t),c=new YE("imag",u,t),f=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],m=a.runWebGLProgram(d,f,"float32"),g=a.runWebGLProgram(c,f,"float32"),b=qo({inputs:{real:m,imag:g},backend:a});a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g);let v=Ee({inputs:{x:b},backend:a,attrs:{shape:e.shape}});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(b),v}function Ude(e){let{inputs:t,backend:a}=e,{input:n}=t;return R3(n,!1,a)}var Pde={kernelName:Rb,backendName:"webgl",kernelFunc:Ude},Wde=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function ug(e){let{backend:t,attrs:a}=e,{shape:n,value:r}=a,{dtype:s}=a;if(s=s||C.inferDtype(r),s==="string"){let i=C.getArrayFromDType(s,C.sizeFromShape(n));return i.fill(r),t.makeTensorInfo(n,s,i)}else{let i=new Wde(n,r),o=[[r]];return t.runWebGLProgram(i,[],s,o)}}var Vde={kernelName:gm,backendName:"webgl",kernelFunc:ug},Gde=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Hde={kernelName:hh,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:a}=e,n=t,r=new Gde(a.shape);return n.runWebGLProgram(r,[a],a.dtype)}},ZE="return floor(x);",qde=Tt({opSnippet:ZE,packedOpSnippet:ZE,cpuKernelImpl:loe}),jde={kernelName:$u,backendName:"webgl",kernelFunc:qde},Kde=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Xde=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Yde=hn({opSnippet:Kde,packedOpSnippet:Xde,dtype:"int32"}),Zde={kernelName:Ru,backendName:"webgl",kernelFunc:Yde},Qde=class{constructor(e){this.variableNames=["A"];let t=Mn(),[a,n]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}.0, ${a}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},Jde=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=Mn(),[a,n]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${n}.0, ${a}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},ehe={kernelName:Xy,backendName:"webgl",kernelFunc:the},vd,bw=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function the(e){let{inputs:t,backend:a,attrs:n}=e,{pixels:r}=t,{numChannels:s}=n,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,d]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[d,u],f=[d,u,s];if(o||i){let v=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(vd==null||v!==bw)&&(bw=v,vd=document.createElement("canvas").getContext("2d",{willReadFrequently:bw})),vd.canvas.width=u,vd.canvas.height=d,vd.drawImage(r,0,0,u,d),r=vd.canvas}let m=a.makeTensorInfo(c,"int32");a.texData.get(m.dataId).usage=wr.PIXELS,a.gpgpu.uploadPixelDataToTexture(a.getTexture(m.dataId),r);let g=ie().getBool("WEBGL_PACK")?new Jde(f):new Qde(f),b=a.runWebGLProgram(g,[m],"int32");return a.disposeData(m.dataId),b}function ahe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dataFormat:c,dilations:f,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=n,v=D.convertConv2DDataFormat(c),x=D.computeConv2DInfo(r.shape,s.shape,u,f,d,m,!1,v),k,S=[],N=i!=null,T=o!=null,_=g==="leakyrelu",R=()=>{let F=[r,s],B=(V,P)=>{if(P==="NCHW"&&V.shape.length===1&&V.shape[0]!==1){let A=Ee({inputs:{x:V},backend:a,attrs:{shape:[V.shape[0],1,1]}});return S.push(A),A}return V};if(N&&F.push(B(i,c)),T&&F.push(B(o,c)),_){let V=a.makeTensorInfo([],"float32",C.createScalarValue(b,"float32"));F.push(V),S.push(V)}return F};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID"))k=T3({x:r,filter:s,convInfo:x,backend:a,bias:i,activation:g,preluActivationWeights:o,leakyreluAlpha:b});else if(x.strideWidth<=2&&v==="channelsLast"&&ie().getBool("WEBGL_EXP_CONV")){let F=g?am(g,!0):null,B=new N3(x,N,F,T,_),V=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],P=R();k=a.runWebGLProgram(B,P,"float32",V)}else if(ie().getBool("WEBGL_CONV_IM2COL"))k=_3({x:r,filter:s,convInfo:x,backend:a,bias:i,activation:g,preluActivationWeights:o,leakyreluAlpha:b});else{let F=g?am(g,!1):null,B=new I3(x,N,F,T,_),V=R();k=a.runWebGLProgram(B,V,"float32")}let M=Ee({inputs:{x:k},backend:a,attrs:{shape:x.outShape}});return S.push(k),S.forEach(F=>a.disposeIntermediateTensorInfo(F)),M}var nhe={kernelName:Ul,backendName:"webgl",kernelFunc:ahe};function rhe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dilations:c,dimRoundingMode:f,activation:m,leakyreluAlpha:g}=n,b=[],v=c;v==null&&(v=[1,1]),C.assert(D.eitherStridesOrDilationsAreOne(u,v),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${v}'`);let x=D.computeConv2DInfo(r.shape,s.shape,u,v,d,f,!0),k=ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels===1,S=m?am(m,k):null,N=[r,s],T=i!=null,_=o!=null,R=m==="leakyrelu";if(T&&N.push(i),_&&N.push(o),R){let V=a.makeTensorInfo([],"float32",C.createScalarValue(g,"float32"));N.push(V),b.push(V)}let M;k?M=new A3(x,T,S,_,R):M=new E3(x,T,S,_,R);let F=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],B=a.runWebGLProgram(M,N,"float32",F);return b.forEach(V=>a.disposeIntermediateTensorInfo(V)),B}var she={kernelName:Pl,backendName:"webgl",kernelFunc:rhe},ihe=class{constructor(e,t,a,n){this.sliceDim=e,this.strides=t,this.paramsShape=n,this.variableNames=["x","indices"],this.outputShape=a;let r=qt(a.length),s=`
    int index;`;for(let i=0;i<this.sliceDim;i++)s+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${s}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function ohe(e){let{inputs:t,backend:a}=e,{params:n,indices:r}=t,s=r.shape,i=s[s.length-1],o=C.sizeFromShape(n.shape),[u,d,c,f]=D.prepareAndValidate(n,r),m=Ee({inputs:{x:r},backend:a,attrs:{shape:[d,i]}}),g=Ee({inputs:{x:n},backend:a,attrs:{shape:[C.sizeFromShape(n.shape)/c,c]}});if(a.shouldExecuteOnCPU([n,r])||n.dtype==="string"){let k=a.readSync(r.dataId),S=a.bufferSync(n),N=uoe(k,S,n.dtype,d,i,c,f,n.shape,o);return a.makeTensorInfo(u,n.dtype,N.values)}let b=new ihe(i,f,[d,c],n.shape),v=a.runWebGLProgram(b,[g,m],g.dtype),x=Ee({inputs:{x:v},backend:a,attrs:{shape:u}});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(v),x}var lhe={kernelName:fh,backendName:"webgl",kernelFunc:ohe},uhe=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let a=qt(this.rank),n=che(e);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${n}));
      }
    `}};function che(e,t){let a=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)r===2?n.push("index"):n.push(`${a[r]}`);return n.join()}function D3(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,indices:s}=t,{axis:i,batchDims:o}=n,u=C.parseAxisParam(i,r.shape)[0];if(ie().get("DEBUG")){let S=a.readSync(s.dataId),N=r.shape[u];for(let T=0;T<S.length;++T){let _=S[T];C.assert(_<=N-1&&_>=0,()=>`GatherV2: the index value ${_} is not in [0, ${N-1}]`)}}let d=D.segment_util.collectGatherOpShapeInfo(r,s,u,o),c=C.sizeFromShape(s.shape),f=[],m=Ee({inputs:{x:r},backend:a,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),g=Ee({inputs:{x:s},backend:a,attrs:{shape:[d.batchSize,c/d.batchSize]}});f.push(m),f.push(g);let b=[d.batchSize,d.outerSize,c/d.batchSize,d.sliceSize];if(a.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let S=a.bufferSync(g),N=a.bufferSync(m),T=coe(N,S,b);return f.forEach(_=>a.disposeIntermediateTensorInfo(_)),a.makeTensorInfo(d.outputShape,T.dtype,T.values)}let v=new uhe(m.shape,b),x=a.runWebGLProgram(v,[m,g],m.dtype);f.push(x);let k=Ee({inputs:{x},backend:a,attrs:{shape:d.outputShape}});return f.forEach(S=>a.disposeIntermediateTensorInfo(S)),k}var dhe={kernelName:ph,backendName:"webgl",kernelFunc:D3},hhe="return float(a > b);",phe=`
  return vec4(greaterThan(a, b));
`,fhe=hn({opSnippet:hhe,packedOpSnippet:phe,cpuKernelImpl:doe,dtype:"bool"}),mhe={kernelName:mh,backendName:"webgl",kernelFunc:fhe},ghe="return float(a >= b);",yhe=`
  return vec4(greaterThanEqual(a, b));
`,bhe=hn({opSnippet:ghe,packedOpSnippet:yhe,dtype:"bool",cpuKernelImpl:hoe}),vhe={kernelName:Mu,backendName:"webgl",kernelFunc:bhe};function xhe(e){let{inputs:t,backend:a}=e,{input:n}=t;return R3(n,!0,a)}var whe={kernelName:Db,backendName:"webgl",kernelFunc:xhe},khe="return float(!isnan(x) && !isinf(x));",She=Tt({opSnippet:khe,dtype:"bool"}),Ihe={kernelName:Ou,backendName:"webgl",kernelFunc:She},Nhe="return float(isinf(x));",The=Tt({opSnippet:Nhe,dtype:"bool"}),_he={kernelName:zu,backendName:"webgl",kernelFunc:The},Che="return float(isnan(x));",Ehe=Tt({opSnippet:Che,dtype:"bool"}),Ahe={kernelName:Lu,backendName:"webgl",kernelFunc:Ehe},$he="return float(a < b);",Rhe=`
  return vec4(lessThan(a, b));
`,Dhe=hn({opSnippet:$he,packedOpSnippet:Rhe,cpuKernelImpl:poe,dtype:"bool"}),Mhe={kernelName:gh,backendName:"webgl",kernelFunc:Dhe},Fhe="return float(a <= b);",Ohe=`
  return vec4(lessThanEqual(a, b));
`,zhe=hn({opSnippet:Fhe,packedOpSnippet:Ohe,cpuKernelImpl:foe,dtype:"bool"}),Lhe={kernelName:yh,backendName:"webgl",kernelFunc:zhe};function Bhe(e){let{backend:t,attrs:a}=e,{start:n,stop:r,num:s}=a,i=moe(n,r,s);return t.makeTensorInfo([i.length],"float32",i)}var Uhe={kernelName:bh,backendName:"webgl",kernelFunc:Bhe},Phe=fp+`
  return x < 0.0 ? 0./0. : log(x);
`,Whe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,Vhe=Tt({opSnippet:Phe,packedOpSnippet:Whe,cpuKernelImpl:goe}),Ghe={kernelName:Uu,backendName:"webgl",kernelFunc:Vhe},Hhe=fp+`
  return log(1.0 + x);
`,qhe=Tt({opSnippet:Hhe}),jhe={kernelName:Pu,backendName:"webgl",kernelFunc:qhe},Khe="return float(a >= 1.0 && b >= 1.0);",Xhe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Yhe=hn({opSnippet:Khe,packedOpSnippet:Xhe,dtype:"bool"}),Zhe={kernelName:vh,backendName:"webgl",kernelFunc:Yhe},Qhe="return float(!(x >= 1.0));",Jhe=Tt({opSnippet:Qhe}),epe={kernelName:xh,backendName:"webgl",kernelFunc:Jhe},tpe="return float(a >= 1.0 || b >= 1.0);",ape=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,npe=hn({opSnippet:tpe,packedOpSnippet:ape,dtype:"bool"}),rpe={kernelName:wh,backendName:"webgl",kernelFunc:npe},spe=class{constructor(e,t,a,n,r){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,u=`float(${a}) + float(${n}) * sum`;r===.5?o=`inversesqrt(${u})`:r===1?o=`1.0/(${u})`:o=`exp(log(${u}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${s}; j <= ${s}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},ipe=class{constructor(e,t,a,n,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,u=`float(${a}) + float(${n}) * sum`;r===.5?o=`inversesqrt(${u})`:r===1?o=`1.0/(${u})`:o=`exp(log(${u}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${s};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${s}; j <= ${s}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},ope=e=>{let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:u}=n,d=ie().getBool("WEBGL_PACK_NORMALIZATION")?new ipe(r.shape,s,i,o,u):new spe(r.shape,s,i,o,u);return a.runWebGLProgram(d,[r],r.dtype)},lpe={kernelName:Wu,backendName:"webgl",kernelFunc:ope},upe=class{constructor(e,t,a,n,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=a,this.alpha=n,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${n}) * norm + float(${a});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${n})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},cpe=e=>{let{inputs:t,backend:a,attrs:n}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:u,alpha:d,beta:c}=n,f=new upe(r.shape,o,u,d,c);return a.runWebGLProgram(f,[r,s,i],r.dtype)},dpe={kernelName:kh,backendName:"webgl",kernelFunc:cpe};function hpe(e,t,a,n){let r=C.sizeFromShape(t),s=C.sizeFromShape(e.shape)/r,i=Ee({inputs:{x:e},attrs:{shape:[s,r]},backend:n}),o=Mc(i,e.dtype,"max",n),u=Ee({inputs:{x:o},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}function M3(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{reductionIndices:s,keepDims:i}=n,o=r.shape.length,u=C.parseAxisParam(s,r.shape),d=u,c=D.getAxesPermutation(d,o),f=c!=null,m=a.shouldExecuteOnCPU([r]),g=r;if(f){if(m){let S=a.texData.get(g.dataId).values,N=new Array(o);for(let R=0;R<N.length;R++)N[R]=r.shape[c[R]];let T=gI(S,r.shape,r.dtype,c,N);g=a.makeTensorInfo(N,r.dtype);let _=a.texData.get(g.dataId);_.values=T}else g=qv(r,c,a);d=D.getInnerMostAxes(d.length,o)}D.assertAxesAreInnerMostDims("max",d,o);let[b,v]=D.computeOutAndReduceShapes(g.shape,d),x=b;i&&(x=D.expandShapeToKeepDim(b,u));let k;if(m){let S=a.texData.get(g.dataId).values,N=yoe(S,C.sizeFromShape(v),x,r.dtype);k=a.makeTensorInfo(x,r.dtype);let T=a.texData.get(k.dataId);T.values=N}else k=hpe(g,v,x,a);return f&&a.disposeIntermediateTensorInfo(g),k}var ppe={kernelName:Vu,backendName:"webgl",kernelFunc:M3},fpe=bI+`
  return max(a, b);
`,mpe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dc+`
  return result;
`,gpe=hn({opSnippet:fpe,packedOpSnippet:mpe,cpuKernelImpl:boe}),ype={kernelName:Gu,backendName:"webgl",kernelFunc:gpe};function bpe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t;lp(r,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:u}=n,d=1;C.assert(D.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=D.computePool2DInfo(r.shape,s,i,d,o,u);if(c.filterWidth===1&&c.filterHeight===1&&C.arraysEqual(c.inShape,c.outShape))return cr({inputs:{x:r},backend:a});let f=new nm(c,"max",!1);return a.runWebGLProgram(f,[r],r.dtype)}var vpe={kernelName:Hu,backendName:"webgl",kernelFunc:bpe};function xpe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dataFormat:u,dimRoundingMode:d}=n,c=[1,1,1],f=D.computePool3DInfo(r.shape,s,i,c,o,d,u),m=new xI(f,"max",!1);return a.runWebGLProgram(m,[r],r.dtype)}var wpe={kernelName:Sh,backendName:"webgl",kernelFunc:xpe},kpe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,a=e.strideWidth,n=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=r-1-e.padInfo.top,o=s-1-e.padInfo.left,u=r*s-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${n}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${s} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},Spe=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,a=e.strideHeight,n=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=o-1-e.padInfo.front,f=u-1-e.padInfo.top,m=d-1-e.padInfo.left,g=o*u*d-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${f}, ${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${s}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${n}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${g} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${d} +
                  wR * ${d} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Ipe(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,i=s,{filterSize:o,strides:u,pad:d,dimRoundingMode:c}=n,f=[1,1,1],m=D.computePool3DInfo(i.shape,o,u,f,d,c),g=new xI(m,"max",!0),b=a.runWebGLProgram(g,[i],i.dtype),v=new Spe(m),x=a.runWebGLProgram(v,[r,b],i.dtype);return a.disposeIntermediateTensorInfo(b),x}var Npe={kernelName:bm,backendName:"webgl",kernelFunc:Ipe};function Tpe(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s,output:i}=t,o=s;lp([s,i],"maxPoolGrad");let{filterSize:u,strides:d,pad:c,dimRoundingMode:f}=n,m=D.computePool2DInfo(o.shape,u,d,1,c,f),g=!0,b=new nm(m,"max",g),v=a.runWebGLProgram(b,[o],o.dtype),x=new kpe(m),k=a.runWebGLProgram(x,[r,v],o.dtype);return a.disposeIntermediateTensorInfo(v),k}var _pe={kernelName:ym,backendName:"webgl",kernelFunc:Tpe};function Cpe(e,t,a,n){let r=new nm(a,"max",!1),s=n.runWebGLProgram(r,[e],"float32");r=new nm(a,"max",!0,!0,t);let i=n.runWebGLProgram(r,[e],"float32");return[s,i]}var Epe={kernelName:vm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:a})=>{let{x:n}=e,{filterSize:r,strides:s,pad:i,includeBatchInIndex:o}=t,u=a;C.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let d=[1,1];C.assert(D.eitherStridesOrDilationsAreOne(s,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${d}'`);let c=D.computePool2DInfo(n.shape,r,s,d,i),[f,m]=Cpe(n,o,c,u);return[f,m]}};function Ape(e,t,a,n){let r=C.sizeFromShape(t),s=C.sizeFromShape(e.shape)/r,i=Ee({inputs:{x:e},attrs:{shape:[s,r]},backend:n}),o=Mc(i,"float32","mean",n),u=Ee({inputs:{x:o},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),u}var $pe={kernelName:qu,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:a})=>{let{x:n}=e,{keepDims:r,axis:s}=t,i=a,o=n.shape.length,u=C.parseAxisParam(s,n.shape),d=u,c=D.getAxesPermutation(d,o),f=c!=null,m=i.shouldExecuteOnCPU([n]),g=[],b=n;if(f){if(m){let N=i.texData.get(b.dataId).values,T=new Array(o);for(let M=0;M<T.length;M++)T[M]=n.shape[c[M]];let _=gI(N,n.shape,n.dtype,c,T);b=i.makeTensorInfo(T,n.dtype);let R=i.texData.get(b.dataId);R.values=_}else b=qv(n,c,i);g.push(b),d=D.getInnerMostAxes(d.length,o)}D.assertAxesAreInnerMostDims("sum",d,o);let[v,x]=D.computeOutAndReduceShapes(b.shape,d),k=v;r&&(k=D.expandShapeToKeepDim(v,u));let S=Ape(b,x,k,i);for(let N of g)i.disposeIntermediateTensorInfo(N);return S}};function Rpe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n,o=r.shape.length,u=C.parseAxisParam(s,r.shape),d=u,c=D.getAxesPermutation(d,o),f=r;c!=null&&(f=En({inputs:{x:r},backend:a,attrs:{perm:c}}),d=D.getInnerMostAxes(d.length,r.shape.length)),D.assertAxesAreInnerMostDims("min",d,o);let[m,g]=D.computeOutAndReduceShapes(f.shape,d),b=C.sizeFromShape(g),v=Ee({inputs:{x:f},backend:a,attrs:{shape:[-1,b]}}),x=Mc(v,v.dtype,"min",a),k;if(i){let S=D.expandShapeToKeepDim(m,u);k=Ee({inputs:{x},backend:a,attrs:{shape:S}})}else k=Ee({inputs:{x},backend:a,attrs:{shape:m}});return a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(x),c!=null&&a.disposeIntermediateTensorInfo(f),k}var Dpe={kernelName:ju,backendName:"webgl",kernelFunc:Rpe},Mpe=bI+`
  return min(a, b);
`,Fpe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dc+`
  return result;
`,Ope=hn({opSnippet:Mpe,packedOpSnippet:Fpe,cpuKernelImpl:voe}),zpe={kernelName:Ku,backendName:"webgl",kernelFunc:Ope},Lpe=class{constructor(e,t,a){this.variableNames=["x"],this.outputShape=t.map((d,c)=>d[0]+e[c]+d[1]);let n=e.length,r=qt(n),s=t.map(d=>d[0]).join(","),i=t.map((d,c)=>d[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n),u=a==="reflect"?0:1;if(n===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${n}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},Bpe=class{constructor(e,t,a){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((g,b)=>g[0]+e[b]+g[1]);let n=e.length,r=qt(n),s=t.map(g=>g[0]).join(","),i=t.map((g,b)=>g[0]+e[b]).join(","),o=Tn("rc",n),u=Tn("source",n),d=`${o[n-1]} < ${this.outputShape[n-1]}`,c=n===1?"source":`vec2(${u.slice(-2).join()})`,f=a==="reflect"?0:1,m="";if(n===1){let g=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;m=`
        ${r} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${o[n-1]} += 1;
        if(${d}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
      `}else{let g=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;m=`
        ${r} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${o[n-1]} += 1;
        if(${d}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
        rc = outputLoc;
        ${o[n-2]} += 1;
        if(${o[n-2]} < ${this.outputShape[n-2]}) {
          ${g}
          result[2] = getChannel(getX(${u.join()}), ${c});
          ${o[n-1]} += 1;
          if(${d}) {
            ${g}
            result[3] = getChannel(getX(${u.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}},Upe=({inputs:e,backend:t,attrs:a})=>{let{x:n}=e,{paddings:r,mode:s}=a,i=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Bpe(n.shape,r,s):new Lpe(n.shape,r,s);return t.runWebGLProgram(i,[n],n.dtype)},Ppe={kernelName:Xu,backendName:"webgl",kernelFunc:Upe},Wpe=`if (b == 0.0) return NAN;
  return mod(a, b);`,Vpe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Dc+`
  return result;
`,Gpe=hn({opSnippet:Wpe,packedOpSnippet:Vpe}),Hpe={kernelName:Yu,backendName:"webgl",kernelFunc:Gpe},qpe=class{constructor(e,t,a){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,a],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},jpe=`
if (a == b) {
  return 1.0;
};
return a / b;`,Kpe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,F3=hn({opSnippet:jpe,packedOpSnippet:Kpe,checkOutOfBounds:!0}),Xpe={kernelName:Tu,backendName:"webgl",kernelFunc:F3},QE="return a - b;",O3=hn({opSnippet:QE,packedOpSnippet:QE,supportsComplex:!0,cpuKernelImpl:Uoe}),Ype={kernelName:wc,backendName:"webgl",kernelFunc:O3};function z3(e){let{inputs:t,backend:a,attrs:n}=e,{logits:r}=t,{dim:s}=n,i=C.parseAxisParam([s],r.shape),o=M3({inputs:{x:r},backend:a,attrs:{reductionIndices:i,keepDims:!1}}),u=D.expandShapeToKeepDim(o.shape,i),d=Ee({inputs:{x:o},backend:a,attrs:{shape:u}}),c=O3({inputs:{a:r,b:d},backend:a}),f=$3({inputs:{x:c},backend:a}),m=jv({inputs:{x:f},backend:a,attrs:{axis:i,keepDims:!1}}),g=Ee({inputs:{x:m},backend:a,attrs:{shape:u}}),b=F3({inputs:{a:f,b:g},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),b}var Zpe={kernelName:vc,backendName:"webgl",kernelFunc:z3};function Qpe(e){let{inputs:t,backend:a,attrs:n}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=n,u=o?r:z3({inputs:{logits:r},backend:a,attrs:{dim:r.shape.length-1}}),d=u.shape[0],c=u.shape[1],f=new qpe(d,c,s),m=[[i]],g=a.runWebGLProgram(f,[u],"int32",m);return o||a.disposeIntermediateTensorInfo(u),g}var Jpe={kernelName:Ih,backendName:"webgl",kernelFunc:Qpe},efe=Kr+`
  return -x;
`,tfe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function afe(e){let{inputs:t,backend:a}=e,{x:n}=t;if(a.shouldExecuteOnCPU([n])){let s=a.texData.get(n.dataId),[i,o]=woe(s.values,n.shape,n.dtype);return a.makeTensorInfo(o,n.dtype,i)}let r;return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new go(n.shape,tfe):r=new Os(n.shape,efe),a.runWebGLProgram(r,[n],n.dtype)}var nfe={kernelName:Nh,backendName:"webgl",kernelFunc:afe},rfe=qs.nonMaxSuppressionV3Impl;function sfe(e){D.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:a,attrs:n}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=n,d=a.readSync(r.dataId),c=a.readSync(s.dataId),{selectedIndices:f}=rfe(d,c,i,o,u);return a.makeTensorInfo([f.length],"int32",new Int32Array(f))}var ife={kernelName:_h,backendName:"webgl",kernelFunc:sfe},ofe=qs.nonMaxSuppressionV4Impl;function lfe(e){D.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:a,attrs:n}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:d}=n,c=a.readSync(r.dataId),f=a.readSync(s.dataId),{selectedIndices:m,validOutputs:g}=ofe(c,f,i,o,u,d);return[a.makeTensorInfo([m.length],"int32",new Int32Array(m)),a.makeTensorInfo([],"int32",new Int32Array([g]))]}var ufe={kernelName:Ch,backendName:"webgl",kernelFunc:lfe},cfe=qs.nonMaxSuppressionV5Impl;function dfe(e){D.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:a,attrs:n}=e,{boxes:r,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:d}=n,c=a.readSync(r.dataId),f=a.readSync(s.dataId),m=i,g=o,b=u,v=d,{selectedIndices:x,selectedScores:k}=cfe(c,f,m,g,b,v);return[a.makeTensorInfo([x.length],"int32",new Int32Array(x)),a.makeTensorInfo([k.length],"float32",new Float32Array(k))]}var hfe={kernelName:Eh,backendName:"webgl",kernelFunc:dfe},pfe=class{constructor(e,t,a,n){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${n}), float(${a}),
                      float(index == coords.y)));
      }
    `}},ffe=e=>{let{inputs:t,backend:a,attrs:n}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:u}=n,d=C.sizeFromShape(r.shape),c=new pfe(d,i,o,u),f=Ee({inputs:{x:r},backend:a,attrs:{shape:[d]}}),m=a.runWebGLProgram(c,[f],s);a.disposeIntermediateTensorInfo(f);let g=[...r.shape,i],b=Ee({inputs:{x:m},backend:a,attrs:{shape:g}});return a.disposeIntermediateTensorInfo(m),b},mfe={kernelName:Qu,backendName:"webgl",kernelFunc:ffe};function bb(e){let{inputs:t,backend:a}=e,{x:n}=t;if(n.dtype==="complex64"){let r=lg({inputs:{input:n},backend:a}),s=bb({inputs:{x:r},backend:a}),i=Kv({inputs:{input:n},backend:a}),o=bb({inputs:{x:i},backend:a}),u=qo({inputs:{real:s,imag:o},backend:a});return a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),u}else return ug({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:a})}var gfe={kernelName:Kh,backendName:"webgl",kernelFunc:bb};function L3(e){let{inputs:t,backend:a}=e,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let r=lg({inputs:{input:n},backend:a}),s=L3({inputs:{x:r},backend:a}),i=Kv({inputs:{input:n},backend:a}),o=bb({inputs:{x:i},backend:a}),u=qo({inputs:{real:s,imag:o},backend:a});return a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(o),u}else return ug({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:a})}var yfe={kernelName:Ah,backendName:"webgl",kernelFunc:L3};function bfe(e){let{inputs:t,backend:a,attrs:n}=e,{axis:r}=n;if(t.length===1)return v1({inputs:{input:t[0]},backend:a,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{C.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),C.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(c=>{let f=v1({inputs:{input:c},backend:a,attrs:{dim:r}});return o.push(f),f}),d=S3({inputs:u,backend:a,attrs:{axis:r}});return o.forEach(c=>a.disposeIntermediateTensorInfo(c)),d}var vfe={kernelName:$h,backendName:"webgl",kernelFunc:bfe},xfe=class{constructor(e,t,a){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,d)=>u[0]+e[d]+u[1]);let n=e.length,r=qt(n),s=t.map(u=>u[0]).join(","),i=t.map((u,d)=>u[0]+e[d]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n);if(n===1){this.userCode=`
        int start = ${s};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${s});
      ${r} end = ${r}(${i});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},wfe=class{constructor(e,t,a){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((b,v)=>b[0]+e[v]+b[1]);let n=e.length,r=qt(n),s=t.map(b=>b[0]).join(","),i=t.map((b,v)=>b[0]+e[v]).join(","),o=Tn("rc",n),u=Tn("source",n),d=`${o[n-1]} < ${this.outputShape[n-1]}`,c=n===1?"source":`vec2(${u.slice(-2).join()})`,f=[`${r} rc = outputLoc;`,`${o[n-1]} += 1;
       if(${d}) {
      `,n===1?"":`}
       rc = outputLoc;
       ${o[n-2]} += 1;
       if(${o[n-2]} < ${this.outputShape[n-2]}) {`,n===1?"":`  ${o[n-1]} += 1;
         if(${d}) {`],m=n===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",g="";for(let b=0,v=n===1?2:4;b<v;b++)g+=`
        ${f[b]}
        if (${m}) {
          result[${b}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${b}] = getChannel(getX(${u.join()}), ${c});
        }
      `;g+=n===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${s});
      const ${r} end = ${r}(${i});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}},B3=e=>{let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{paddings:s,constantValue:i}=n;if(C.sizeFromShape(r.shape)===0){let d=s.map((c,f)=>c[0]+r.shape[f]+c[1]);return ug({backend:a,attrs:{shape:d,value:i,dtype:r.dtype}})}let o=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new wfe(r.shape,s,i):new xfe(r.shape,s,i),u=[[i]];return a.runWebGLProgram(o,[r],r.dtype,u)},kfe={kernelName:Ju,backendName:"webgl",kernelFunc:B3},Sfe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Ife=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Dc+`
  return result;
`,Nfe=hn({opSnippet:Sfe,packedOpSnippet:Ife}),Tfe={kernelName:ec,backendName:"webgl",kernelFunc:Nfe};function _fe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,keepDims:i}=n,o=r.shape.length,u=[],d=C.parseAxisParam(s,r.shape),c=d,f=D.getAxesPermutation(c,o),m=r;f!=null&&(m=En({inputs:{x:r},backend:a,attrs:{perm:f}}),c=D.getInnerMostAxes(c.length,o),u.push(m)),D.assertAxesAreInnerMostDims("prod",c,o);let g;if(a.shouldExecuteOnCPU([m])){let b=a.texData.get(m.dataId).values,{outVals:v,outShape:x,outDtype:k}=Soe(m.shape,m.dtype,b,c);g=a.makeTensorInfo(x,k,v)}else{let[b,v]=D.computeOutAndReduceShapes(m.shape,c),x=C.sizeFromShape(v),k=Ee({inputs:{x:m},backend:a,attrs:{shape:[-1,x]}}),S=Ub(r.dtype),N=Mc(k,S,"prod",a);g=Ee({inputs:{x:N},backend:a,attrs:{shape:b}}),u.push(k),u.push(N)}if(i){u.push(g);let b=D.expandShapeToKeepDim(g.shape,d);g=Ee({inputs:{x:g},backend:a,attrs:{shape:b}})}return u.forEach(b=>a.disposeIntermediateTensorInfo(b)),g}var Cfe={kernelName:ac,backendName:"webgl",kernelFunc:_fe};function Efe(e){let{inputs:t,backend:a,attrs:n}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:i}=t,{outputRaggedRank:o}=n,u=r.map(k=>a.readSync(k.dataId)),d=r.map(k=>k.shape),c=a.readSync(s.dataId),f=a.readSync(i.dataId),[m,g,b]=Ioe(u,d,c,s.shape,s.dtype,f,i.shape,o),v=m.map(k=>a.makeTensorInfo([k.length],"int32",k)),x=a.makeTensorInfo(b,s.dtype,g);return v.concat([x])}var Afe={kernelName:Fb,backendName:"webgl",kernelFunc:Efe};function $fe(e){let{inputs:t,backend:a}=e,{starts:n,limits:r,deltas:s}=t,i=a.readSync(n.dataId),o=a.readSync(r.dataId),u=a.readSync(s.dataId),[d,c]=Noe(i,n.shape,n.dtype,o,r.shape,u,s.shape),f=a.makeTensorInfo([d.length],"int32",d),m=a.makeTensorInfo([c.length],n.dtype,c);return[f,m]}var Rfe={kernelName:Ob,backendName:"webgl",kernelFunc:$fe};function Dfe(e){let{inputs:t,backend:a,attrs:n}=e,{shape:r,values:s,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=n,d=a.readSync(r.dataId),c=a.readSync(s.dataId),f=a.readSync(i.dataId),m=o.map(x=>a.readSync(x.dataId)),g=o.map(x=>x.shape),[b,v]=Toe(d,r.shape,c,s.shape,s.dtype,f,i.shape,m,g,u);return a.makeTensorInfo(b,s.dtype,v)}var Mfe={kernelName:zb,backendName:"webgl",kernelFunc:Dfe},U3=e=>{let{backend:t,attrs:a}=e,{start:n,stop:r,step:s,dtype:i}=a,o=_oe(n,r,s,i);return t.makeTensorInfo([o.length],i,o)},Ffe={kernelName:xm,backendName:"webgl",kernelFunc:U3},Ofe="return 1.0 / x;",zfe=Tt({opSnippet:Ofe}),Lfe={kernelName:nc,backendName:"webgl",kernelFunc:zfe},Bfe=Kr+`
  return (x < 0.0) ? 0.0 : x;
`,Ufe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Pfe=Tt({opSnippet:Bfe,packedOpSnippet:Ufe}),Wfe={kernelName:rc,backendName:"webgl",kernelFunc:Pfe},Vfe=Kr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Gfe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Hfe=Tt({opSnippet:Vfe,packedOpSnippet:Gfe}),qfe={kernelName:oc,backendName:"webgl",kernelFunc:Hfe},jfe=class{constructor(e,t,a,n,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,u]=e;this.outputShape=[s,t,a,u];let d=[n&&t>1?i-1:i,n&&a>1?o-1:o],c=[n&&t>1?t-1:t,n&&a>1?a-1:a],f;r?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/c[0]},
          ${d[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},Kfe=class{constructor(e,t,a,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,u]=e;this.outputShape=[s,t,a,u];let d=[n&&t>1?i-1:i,n&&a>1?o-1:o],c=[n&&t>1?t-1:t,n&&a>1?a-1:a],f;r?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/c[0]},
          ${d[1]/c[1]},
          ${d[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${a-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Xfe(e){let{inputs:t,backend:a,attrs:n}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=n,[u,d]=o,c=ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Kfe(r.shape,u,d,s,i):new jfe(r.shape,u,d,s,i);return a.runWebGLProgram(c,[r],"float32")}var Yfe={kernelName:ic,backendName:"webgl",kernelFunc:Xfe},Zfe=class{constructor(e,t,a){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,n,r]=t,[,s,i]=e,o=[a&&s>1?n-1:n,a&&i>1?r-1:r],u=[a&&s>1?s-1:s,a&&i>1?i-1:i],d=o[0]/u[0],c=o[1]/u[1],f=1/d,m=1/c,g=Math.ceil(f)*2+2,b=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${c});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${n-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Qfe(e){let{inputs:t,backend:a,attrs:n}=e,{images:r,dy:s}=t,{alignCorners:i}=n,o=new Zfe(s.shape,r.shape,i);return a.runWebGLProgram(o,[s],s.dtype)}var Jfe={kernelName:Mh,backendName:"webgl",kernelFunc:Qfe},eme=class{constructor(e,t,a,n,r){this.variableNames=["A"],this.outputShape=[];let[s,i,o,u]=e;this.outputShape=[s,t,a,u];let d=[n&&t>1?i-1:i,n&&a>1?o-1:o],c=[n&&t>1?t-1:t,n&&a>1?a-1:a],f=n?"0.5":"0.0",m;r?m="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${d[0]/c[0]},
          ${d[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},tme=class{constructor(e,t,a,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,u]=e;this.outputShape=[s,t,a,u];let d=[n&&t>1?i-1:i,n&&a>1?o-1:o],c=[n&&t>1?t-1:t,n&&a>1?a-1:a],f=n?"0.5":"0.0",m;r?m="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${d[0]/c[0]},
          ${d[1]/c[1]},
          ${d[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${a-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function ame(e){let{inputs:t,backend:a,attrs:n}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:i,size:o}=n,[u,d]=o,c=ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new tme(r.shape,u,d,s,i):new eme(r.shape,u,d,s,i);return a.runWebGLProgram(c,[r],r.dtype)}var nme={kernelName:sc,backendName:"webgl",kernelFunc:ame},rme=class{constructor(e,t,a){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,n,r]=t,[,s,i]=e,o=[a&&s>1?n-1:n,a&&i>1?r-1:r],u=[a&&s>1?s-1:s,a&&i>1?i-1:i],d=o[0]/u[0],c=o[1]/u[1],f=1/d,m=1/c,g=Math.ceil(f)*2+2,b=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${d});
        const float widthScale = float(${c});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${m});

        const int winHeight = int(${g});
        const int winWidth = int(${b});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${s}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${n}) - 1),
                ${a} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${a} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function sme(e){let{inputs:t,backend:a,attrs:n}=e,{images:r,dy:s}=t,{alignCorners:i}=n,o=new rme(s.shape,r.shape,i);return a.runWebGLProgram(o,[s],s.dtype)}var ime={kernelName:Dh,backendName:"webgl",kernelFunc:sme},ome=class{constructor(e,t){this.variableNames=["x"];let a=e.length;if(a>4)throw new Error(`WebGL backend: Reverse of rank-${a} tensor is not yet supported`);if(this.outputShape=e,a===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let n=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,r=e.map((i,o)=>n(o)).join(","),s=qt(a);this.userCode=`
      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}},lme=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let a=e.length;if(a>4)throw new Error(`WebGL backend: Reverse of rank-${a} tensor is not yet supported`);this.outputShape=e;let n=Tn("rc",a),r=`${n[a-1]} + 1 < ${this.outputShape[a-1]}`,s=`${n[a-2]} + 1 < ${this.outputShape[a-2]}`,i=qt(a);a===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(n.slice())};
          if(${r}){
            result.g = ${u(n.slice())};
          }
          if(${s}) {
            result.b = ${d(n.slice())};
            if(${r}) {
              result.a = ${c(n.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(g){return f(g)}function u(g){return g[a-1]="("+g[a-1]+" + 1)",f(g)}function d(g){return g[a-2]="("+g[a-2]+" + 1)",f(g)}function c(g){return g[a-1]="("+g[a-1]+" + 1)",g[a-2]="("+g[a-2]+" + 1)",f(g)}function f(g){let b=e.map((k,S)=>m(S,g)),v=b.join(","),x=b.slice(-2).join(",");return`getChannel(getX(${v}), vec2(${x}))`}function m(g,b){return t.indexOf(g)!==-1&&e[g]!==1?`${e[g]} - ${b[g]} - 1`:`${b[g]}`}}};function ume(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{dims:s}=n,i=r.shape.length,o=C.parseAxisParam(s,r.shape);if(i===0)return cr({inputs:{x:r},backend:a});let u=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lme(r.shape,o):new ome(r.shape,o);return a.runWebGLProgram(u,[r],r.dtype)}var cme={kernelName:lc,backendName:"webgl",kernelFunc:ume},dme=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let a=e[1],n=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${n} && coordY >= 0 && coordY < ${a}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},hme={kernelName:Xh,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:a})=>{let{image:n}=e,{radians:r,fillValue:s,center:i}=t,o=a,u=new dme(n.shape,s),[d,c]=D.getImageCenter(i,n.shape[1],n.shape[2]),f=[[d,c,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(u,[n],n.dtype,f)}},pme=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,fme=Tt({opSnippet:pme}),mme={kernelName:uc,backendName:"webgl",kernelFunc:fme},gme="return inversesqrt(x);",yme=Tt({opSnippet:gme,cpuKernelImpl:Coe}),bme={kernelName:cc,backendName:"webgl",kernelFunc:yme},wI=class{constructor(e,t,a,n,r,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let u=qt(r.length),d=qt(s.length),c="";a===1?c="i":a===2&&(c="i, j");let f=`getIndices(${c})`,m="";n===1?m="i":n===2&&(m="i, coords[1]");let g=`getUpdates(${m})`,b="";o&&(b="coords[0], coords[1]");let v=`getDefaultValue(${b})`,x=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${r});

        void main() {
          ${d} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${x};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${g};
              found = true;
            }
          }
          setOutput(mix(${v}, sum, float(found)));
        }
      `}},vme=class{constructor(e,t,a,n,r,s,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;let u=qt(r.length),d=qt(s.length),c="";a===1?c="i":a===2&&(c="i, j");let f=`getIndices(${c})`,m="";n===1?m="i":n===2&&(m="i, coords[1]");let g=`getUpdates(${m})`,b="";o&&(b="coords[0], coords[1]");let v=`getDefaultValue(${b})`,x=t>1?"strides[j]":"strides",k=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${r});

        void main() {
          ${d} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${x};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${k};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${g};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${v}, sum, found));
        }
      `}};function xme(e){let{inputs:t,backend:a,attrs:n}=e,{indices:r,updates:s}=t,{shape:i}=n,{sliceRank:o,numUpdates:u,sliceSize:d,strides:c,outputSize:f}=D.calculateShapes(s,r,i),m=[f/d,d];if(f===0)return a.makeTensorInfo(i,r.dtype);let g=Ee({inputs:{x:r},backend:a,attrs:{shape:[u,o]}}),b=Ee({inputs:{x:s},backend:a,attrs:{shape:[u,d]}}),v=a.makeTensorInfo([],"float32",new Float32Array([0])),x;ie().getBool("WEBGL_PACK")?x=new vme(u,o,g.shape.length,b.shape.length,c,m):x=new wI(u,o,g.shape.length,b.shape.length,c,m);let k=a.runWebGLProgram(x,[b,g,v],b.dtype),S=Ee({inputs:{x:k},backend:a,attrs:{shape:i}});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(k),a.disposeIntermediateTensorInfo(v),S}var wme={kernelName:Fh,backendName:"webgl",kernelFunc:xme},kme=class{constructor(e,t,a,n){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,a];let r="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=ie().getNumber("WEBGL_VERSION")===2?r:s,o=n==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Sme(e){let{inputs:t,backend:a,attrs:n}=e,{sortedSequence:r,values:s}=t,{side:i}=n,o=new kme(r.shape[0],r.shape[1],s.shape[1],i),u=[[r.shape[1]]];return a.runWebGLProgram(o,[r,s],"int32",u)}var Ime={kernelName:zh,backendName:"webgl",kernelFunc:Sme},Nme=class{constructor(e,t,a){this.variableNames=["c","a","b"],this.outputShape=t;let n,r;if(a>4)throw Error(`Where for rank ${a} is not yet supported`);if(a===1)r="resRC",n="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],u=[];for(let d=0;d<t.length;d++)u.push(`${i[d]}`),d<e&&o.push(`${i[d]}`);n=o.join(),r=u.join()}let s=qt(a);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        float cVal = getC(${n});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}};function Tme(e){let{inputs:t,backend:a}=e,{condition:n,t:r,e:s}=t,i=new Nme(n.shape.length,r.shape,r.shape.length);return a.runWebGLProgram(i,[n,r,s],Nr(r.dtype,s.dtype))}var _me={kernelName:Lh,backendName:"webgl",kernelFunc:Tme},Cme=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${D.SELU_SCALEALPHA};
  float scale = ${D.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Eme=Tt({opSnippet:Cme}),Ame={kernelName:dc,backendName:"webgl",kernelFunc:Eme},$me=fp+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Rme=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dme=Tt({opSnippet:$me,packedOpSnippet:Rme,cpuKernelImpl:Aoe}),Mme={kernelName:mc,backendName:"webgl",kernelFunc:Dme},Fme=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Ome=Tt({opSnippet:Fme}),zme={kernelName:fc,backendName:"webgl",kernelFunc:Ome},Lme=fp+`
  return sin(x);
`,Bme=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Dc}
  return result;
`,Ume=Tt({opSnippet:Lme,packedOpSnippet:Bme}),Pme={kernelName:hc,backendName:"webgl",kernelFunc:Ume},Wme=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Vme=Tt({opSnippet:Wme}),Gme={kernelName:pc,backendName:"webgl",kernelFunc:Vme},Hme=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,qme=Tt({opSnippet:Hme}),jme={kernelName:gc,backendName:"webgl",kernelFunc:qme},Kme=e=>{let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{blockShape:s,paddings:i}=n;C.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=s.reduce((k,S)=>k*S),u=[[0,0]];u.push(...i);for(let k=1+s.length;k<r.shape.length;++k)u.push([0,0]);let d=[],c=B3({inputs:{x:r},backend:a,attrs:{paddings:u,constantValue:0}}),f=D.getReshaped(c.shape,s,o,!1),m=D.getPermuted(f.length,s.length,!1),g=D.getReshapedPermuted(c.shape,s,o,!1),b=Ee({inputs:{x:c},backend:a,attrs:{shape:f}}),v=En({inputs:{x:b},backend:a,attrs:{perm:m}}),x=Ee({inputs:{x:v},backend:a,attrs:{shape:g}});return d.push(c),d.push(b),d.push(v),d.forEach(k=>a.disposeIntermediateTensorInfo(k)),x},Xme={kernelName:Uh,backendName:"webgl",kernelFunc:Kme};function Yme(e){let{inputs:t,backend:a}=e,{indices:n,values:r,denseShape:s,defaultValue:i}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=a.readSync(n.dataId),u=a.readSync(r.dataId),d=a.readSync(s.dataId),c=a.readSync(i.dataId)[0],[f,m,g,b,v]=Roe(o,n.shape,n.dtype,u,r.dtype,d,c);return[a.makeTensorInfo(m,n.dtype,f),a.makeTensorInfo([m[0]],r.dtype,g),a.makeTensorInfo([b.length],"bool",new Uint8Array(b.map(x=>Number(x)))),a.makeTensorInfo([v.length],n.dtype,new Int32Array(v))]}var Zme={kernelName:wm,backendName:"webgl",kernelFunc:Yme};function Qme(e){let{inputs:t,backend:a}=e,{inputIndices:n,inputShape:r,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(a.readSync(r.dataId)),o=a.readSync(n.dataId),u=Array.from(a.readSync(s.dataId)),[d,c,f]=Doe(o,n.shape,n.dtype,i,u);return[a.makeTensorInfo(c,n.dtype,d),a.makeTensorInfo([f.length],s.dtype,new Int32Array(f))]}var Jme={kernelName:Wh,backendName:"webgl",kernelFunc:Qme};function ege(e){let{inputs:t,backend:a}=e,{data:n,indices:r,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=a.readSync(n.dataId),o=a.readSync(r.dataId),u=a.readSync(s.dataId),[d,c]=l3(i,n.shape,n.dtype,o,u,!0);return a.makeTensorInfo(c,n.dtype,d)}var tge={kernelName:km,backendName:"webgl",kernelFunc:ege};function age(e){let{inputs:t,backend:a}=e,{data:n,indices:r,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=a.readSync(n.dataId),o=a.readSync(r.dataId),u=a.readSync(s.dataId),[d,c]=l3(i,n.shape,n.dtype,o,u);return a.makeTensorInfo(c,n.dtype,d)}var nge={kernelName:Sm,backendName:"webgl",kernelFunc:age};function rge(e){let{inputs:t,backend:a,attrs:n}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=t,{outputShape:o}=n,{sliceRank:u,numUpdates:d,sliceSize:c,strides:f,outputSize:m}=D.calculateShapes(s,r,o),g=!1;if(s.dtype==="string"){let k=a.bufferSync(r),S=a.bufferSync(s),N=C.decodeString(a.readSync(i.dataId)[0]),T=Eoe(k,S,o,m,c,d,u,f,N,g);return a.makeTensorInfo(o,T.dtype,T.values)}let b=new wI(d,u,r.shape.length,s.shape.length,f,[m,1],g),v=a.runWebGLProgram(b,[s,r,i],s.dtype),x=Ee({inputs:{x:v},backend:a,attrs:{shape:o}});return a.disposeIntermediateTensorInfo(v),x}var sge={kernelName:Vh,backendName:"webgl",kernelFunc:rge};function ige(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=n,o=C.parseAxisParam(i,r.shape)[0],u=D.prepareSplitSize(r,s,o),d=r.shape.length,c=new Array(d).fill(0),f=r.shape.slice();return u.map(m=>{let g=[...f];g[o]=m;let b=mp({inputs:{x:r},backend:a,attrs:{begin:c,size:g}});return c[o]+=m,b})}var oge={kernelName:Ph,backendName:"webgl",kernelFunc:ige},JE="return sqrt(x);",lge=Tt({opSnippet:JE,packedOpSnippet:JE,cpuKernelImpl:Moe}),uge={kernelName:yc,backendName:"webgl",kernelFunc:lge},cge="return x * x;",dge=Tt({opSnippet:cge}),hge={kernelName:Im,backendName:"webgl",kernelFunc:dge},eA="return (a - b) * (a - b);",pge=hn({opSnippet:eA,packedOpSnippet:eA}),fge={kernelName:xc,backendName:"webgl",kernelFunc:pge};function mge(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t;if(r.dtype!=="string")throw new Error("Input must be of datatype string");let s=a.readSync(r.dataId),i=D.fromUint8ToStringArray(s),o=Foe(i,"string",n);return a.makeTensorInfo(r.shape,"string",o)}var gge={kernelName:Nm,backendName:"webgl",kernelFunc:mge};function yge({inputs:e,attrs:t,backend:a}){let{x:n}=e,r=Kr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Os(n.shape,r);return a.runWebGLProgram(s,[n],n.dtype)}var bge={kernelName:Bo,backendName:"webgl",kernelFunc:yge},vge=class{constructor(e,t,a){this.variableNames=["x"],this.outputShape=a;let n=a.length,r=qt(a.length),s=qt(a.length),i="";if(n===1)i="coords * strides + begin";else{let o=0;i=a.map((u,d)=>(o++,a.length===1?`coords * strides[${d}] + begin[${d}]`:`coords[${o-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${s} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function xge(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{begin:s,end:i,strides:o,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:f,shrinkAxisMask:m}=n,{finalShapeSparse:g,finalShape:b,isIdentity:v,sliceDim0:x,isSimpleSlice:k,begin:S,end:N,strides:T}=Pa.sliceInfo(r.shape,s,i,o,u,d,c,f,m),_;if(v)_=Ee({inputs:{x:r},backend:a,attrs:{shape:b}});else if(x||k){C.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let M=Pa.computeOutShape(S,N,T),F=mp({inputs:{x:r},backend:a,attrs:{begin:S,size:M}});_=Ee({inputs:{x:F},backend:a,attrs:{shape:b}}),a.disposeIntermediateTensorInfo(F)}else if(a.shouldExecuteOnCPU([r])){let M=a.readSync(r.dataId),F=ct(r.shape,r.dtype,M),B=Ooe(g,F,T,S);_=a.makeTensorInfo(b,r.dtype,B.values)}else{let M=new vge(S,T,g);_=a.runWebGLProgram(M,[r],r.dtype)}let R=Ee({inputs:{x:_},backend:a,attrs:{shape:b}});return a.disposeIntermediateTensorInfo(_),R}var wge={kernelName:Gh,backendName:"webgl",kernelFunc:xge};function kge(e){let{inputs:t,backend:a,attrs:n}=e,{separator:r,nGramWidths:s,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:d}=n,{data:c,dataSplits:f}=t,m=a.readSync(c.dataId),g=a.readSync(f.dataId),[b,v]=zoe(m,g,r,s,i,o,u,d);return[a.makeTensorInfo([b.length],"string",b),a.makeTensorInfo(f.shape,"int32",v)]}var Sge={kernelName:Tm,backendName:"webgl",kernelFunc:kge};function Ige(e){let{inputs:t,backend:a,attrs:n}=e,{skipEmpty:r}=n,{input:s,delimiter:i}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=a.readSync(s.dataId),u=a.readSync(i.dataId)[0],[d,c,f]=Loe(o,u,r),m=c.length;return[a.makeTensorInfo([m,2],"int32",d),a.makeTensorInfo([m],"string",c),a.makeTensorInfo([2],"int32",new Int32Array(f))]}var Nge={kernelName:_m,backendName:"webgl",kernelFunc:Ige};function Tge(e){let{inputs:t,backend:a,attrs:n}=e,{numBuckets:r}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");let i=a.readSync(s.dataId),o=Boe(i,r);return a.makeTensorInfo(s.shape,"int32",o)}var _ge={kernelName:Cm,backendName:"webgl",kernelFunc:Tge},Cge="return tan(x);",Ege=Tt({opSnippet:Cge}),Age={kernelName:kc,backendName:"webgl",kernelFunc:Ege},$ge=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Rge=Tt({opSnippet:$ge}),Dge={kernelName:Sc,backendName:"webgl",kernelFunc:Rge};function Mge(e){let{inputs:t,backend:a,attrs:n}=e,{tensor:r,indices:s,updates:i}=t,{sliceRank:o,numUpdates:u,sliceSize:d,strides:c,outputSize:f}=D.calculateShapes(i,s,r.shape),m=[f/d,d];if(f===0)return a.makeTensorInfo(r.shape,s.dtype);let g=Ee({inputs:{x:s},backend:a,attrs:{shape:[u,o]}}),b=Ee({inputs:{x:i},backend:a,attrs:{shape:[u,d]}}),v=Ee({inputs:{x:r},backend:a,attrs:{shape:m}}),x=new wI(u,o,g.shape.length,b.shape.length,c,m,!1,!0),k=a.runWebGLProgram(x,[b,g,v],v.dtype),S=Ee({inputs:{x:k},backend:a,attrs:{shape:r.shape}});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(v),a.disposeIntermediateTensorInfo(k),S}var Fge={kernelName:Oh,backendName:"webgl",kernelFunc:Mge},Oge=class{constructor(e,t){this.variableNames=["A"];let a=new Array(e.length);for(let s=0;s<a.length;s++)a[s]=e[s]*t[s];this.outputShape=a,this.rank=a.length;let n=qt(this.rank),r=zge(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}};function zge(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let a=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let r=0;r<e.length;r++)n.push(`imod(${a[r]}, ${e[r]})`);return n.join()}function P3(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{reps:s}=n;if(r.dtype==="string"||r.shape.length>5){let o=a.readSync(r.dataId),u=r.dtype==="string"?o.map(f=>C.decodeString(f)):o,d=ct(r.shape,r.dtype,u),c=Poe(d,s);return a.makeTensorInfo(c.shape,c.dtype,c.values)}let i=new Oge(r.shape,s);return a.runWebGLProgram(i,[r],r.dtype)}var Lge={kernelName:Lo,backendName:"webgl",kernelFunc:P3},Bge=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Uge=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Sl(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function tA(e){let t=1;for(;t<e;)t*=2;return t}function Pge(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{k:s,sorted:i}=n,o=ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=r.shape,c=d[d.length-1];if(a.shouldExecuteOnCPU([r])||c<o||s>u){let B=a.readSync(r.dataId),[V,P]=Woe(B,d,r.dtype,s,i);return[a.makeTensorInfo(V.shape,V.dtype,V.values),a.makeTensorInfo(P.shape,P.dtype,P.values)]}if(s===0)return d[d.length-1]=0,[a.makeTensorInfo(d,r.dtype,[]),a.makeTensorInfo(d,"int32",[])];if(c===1)return[r,ug({attrs:{shape:d,dtype:"int32",value:0},backend:a})];let f=a.texData.get(r.dataId),m=f!==null&&f.isPacked,g=m?a.unpackTensor(r):r,b=C.sizeFromShape(d)/c,v=Ee({inputs:{x:g},attrs:{shape:[b,c]},backend:a});m&&Sl(a,g);let x=tA(s),k=tA(c),S=null,N=()=>S===null?[v,v]:[v,S],T=(B,V,P)=>{let A=N(),G=new Bge(P),J=[[c],[S===null?1:0],[Number.NEGATIVE_INFINITY],[B],[V]],ee=S;S=a.runWebGLProgram(G,A,"int32",J),Sl(a,ee)};for(let B=1;B<x;B*=2){let V=B*2;for(let P=B;P>=1;P/=2)T(V,P,[b,k])}for(let B=k;B>x;B/=2){let V=N(),P=new Uge([b,B/2]),A=[[c],[S===null?1:0],[x]],G=S;S=a.runWebGLProgram(P,V,"int32",A),Sl(a,G);let J=x/2,ee=J*2;for(let W=J;W>=1;W/=2)T(ee,W,S.shape)}let _=S;S=mp({inputs:{x:S},backend:a,attrs:{begin:0,size:[b,s]}}),Sl(a,_);let R=D3({inputs:{x:v,indices:S},backend:a,attrs:{axis:1,batchDims:1}});Sl(a,v);let M=d.slice(0,-1);M.push(s),_=S,S=Ee({inputs:{x:S},attrs:{shape:M},backend:a}),Sl(a,_);let F=R;return R=Ee({inputs:{x:R},attrs:{shape:M},backend:a}),Sl(a,F),[R,S]}var Wge={kernelName:Hh,backendName:"webgl",kernelFunc:Pge},Vge=class{constructor(e,t,a,n,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i=a==="nearest"?1:2,o;switch(n){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function Gge(e){let{inputs:t,backend:a,attrs:n}=e,{image:r,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:d}=n,[c,f,m,g]=r.shape,[b,v]=d??[f,m],x=[c,b,v,g],k=new Vge(f,m,i,o,u,x);return a.runWebGLProgram(k,[r,s],"float32")}var Hge={kernelName:qh,backendName:"webgl",kernelFunc:Gge};function qge(e){let{inputs:t,attrs:a,backend:n}=e,{axis:r}=a,{x:s}=t;lp(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=n.readSync(s.dataId),{outputValues:o,outputShape:u,indices:d}=Voe(i,r,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,o),n.makeTensorInfo([d.length],"int32",d)]}var jge={kernelName:Em,backendName:"webgl",kernelFunc:qge};function Kge(e){let{inputs:t,backend:a,attrs:n}=e,{value:r}=t,{axis:s}=n;s<0&&(s+=r.shape.length);let i=r,o=i.shape.length,u=r.shape[s],d=new Array(o-1),c=0;for(let v=0;v<o;v++)v!==s&&(d[c++]=i.shape[v]);let f=[],m=new Array(o).fill(0),g=i.shape.slice();g[s]=1;let b=new Array(u);for(let v=0;v<b.length;v++){m[s]=v;let x=mp({inputs:{x:i},backend:a,attrs:{begin:m,size:g}}),k=Ee({inputs:{x},backend:a,attrs:{shape:d}});b[v]=k,f.push(x)}return f.forEach(v=>a.disposeIntermediateTensorInfo(v)),b}var Xge={kernelName:jh,backendName:"webgl",kernelFunc:Kge},Yge=class{constructor(e,t){this.variableNames=["x","segmentIds"];let a=e.windowSize,n=e.batchSize,r=e.inSize,s=e.numSegments,i=s*Math.ceil(r/a);this.outputShape=[n,i];let o="0.0",u="sumValue",d=Math.floor(a/4)*4,c=a%4,f=`
        sumValue += dot(values, segFilter);
    `,m="";r%a>0&&(m=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let g="";r%a>0&&(g=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${g}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${s})) * float(${a}));
        int currentSeg = int(mod(float(outIdx), float(${s})));

        float sumValue = 0.0;

        for (int i = 0; i < ${d}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${d};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${u});
      }
    `}};function Zge(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,segmentIds:s}=t,{numSegments:i}=n,o=r.shape.length,u=[],d=0,c=D.getAxesPermutation([d],o),f=r;c!=null&&(f=En({inputs:{x:r},backend:a,attrs:{perm:c}}),u.push(f),d=D.getInnerMostAxes(1,o)[0]);let m=D.segment_util.computeOutShape(f.shape,d,i),g=C.sizeFromShape([f.shape[d]]),b=Ee({inputs:{x:f},backend:a,attrs:{shape:[-1,g]}});u.push(b);let v=Ub(r.dtype),x=(T,_,R,M,F)=>{let B=T.shape[0],V=T.shape[1],P=D.segment_util.segOpComputeOptimalWindowSize(V,F),A={windowSize:P,inSize:V,batchSize:B,numSegments:F},G=new Yge(A,_),J=a.compileAndRun(G,[T,R],M);if(u.push(J),J.shape[1]===F)return J;let ee=U3({backend:a,attrs:{start:0,stop:F,step:1,dtype:"float32"}}),W=P3({inputs:{x:ee},backend:a,attrs:{reps:[V/P]}});return u.push(ee),u.push(W),x(J,_,W,M,F)},k=x(b,"unsortedSegmentSum",s,v,i),S=Ee({inputs:{x:k},backend:a,attrs:{shape:m}}),N=S;if(c!=null){u.push(S);let T=D.getUndoAxesPermutation(c);N=En({inputs:{x:N},backend:a,attrs:{perm:T}})}return u.forEach(T=>a.disposeIntermediateTensorInfo(T)),N}var Qge={kernelName:Am,backendName:"webgl",kernelFunc:Zge},Jge=[Ole,Lle,Ple,Gle,qle,Xle,Zle,Jle,nue,sue,lue,due,fue,bue,wue,Sue,Nue,Eue,$ue,Due,zue,Gue,que,Yue,Que,rce,ice,cce,vle,pce,bce,kce,Cce,$ce,Dce,Fce,zce,Pce,Gce,jce,Xce,Zce,Jce,ade,rde,lde,cde,pde,gde,bde,kde,Tde,Ade,Dde,Ode,zde,Bde,Pde,Vde,Hde,jde,Zde,ehe,nhe,she,lhe,dhe,mhe,vhe,ble,whe,gce,Ihe,_he,Ahe,wle,Mhe,Lhe,Uhe,Ghe,jhe,Zhe,epe,rpe,lpe,dpe,ppe,ype,vpe,wpe,Npe,_pe,Epe,$pe,Dpe,zpe,Ppe,Hpe,Jpe,Ile,nfe,ife,ufe,hfe,ece,mfe,yfe,vfe,kfe,Tfe,Sle,Cfe,Afe,Rfe,Mfe,Ffe,tce,Xpe,Lfe,Wfe,qfe,Tle,Yfe,Jfe,nme,ime,cme,hme,mme,bme,wme,Ime,_me,Ame,Mme,zme,Pme,Gme,Wue,Zpe,jme,Xme,Zme,Jme,tge,nge,sge,oge,uge,hge,fge,gge,bge,wge,Sge,Nge,_ge,Ype,Dle,Age,Dge,Fge,Lge,Wge,Hge,Mle,jge,Xge,Qge,gfe];for(let e of Jge)$m(e);var Et;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(Et||(Et={}));var sm;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(sm||(sm={}));var W3;function eye(e){W3=e.wasm.cwrap(Bl,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function tye(e){let{inputs:t,backend:a,attrs:n}=e,{a:r,b:s,bias:i,preluActivationWeights:o}=t;if(r.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:d,activation:c,leakyreluAlpha:f}=n,m=a.dataIdMap.get(r.dataId).id,g=a.dataIdMap.get(s.dataId).id,b=0;if(i!=null){let F=a.dataIdMap.get(i.dataId);if(F.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${F.shape.length}.`);b=F.id}let v=o==null?0:a.dataIdMap.get(o.dataId).id,x=sm[c];if(x==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let k=u?r.shape[2]:r.shape[1],S=d?s.shape[1]:s.shape[2],N=Yh.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)),T=a.makeOutput([...N,k,S],r.dtype),_=a.dataIdMap.get(T.dataId).id,R=new Uint8Array(new Int32Array(r.shape).buffer),M=new Uint8Array(new Int32Array(s.shape).buffer);return W3(m,R,r.shape.length,g,M,s.shape.length,u,d,x,b,v,f||0,_),T}var aye={kernelName:Bl,backendName:"wasm",setupFunc:eye,kernelFunc:tye};function Nt(e,t){let a;function n(s){a=s.wasm.cwrap(e,null,["number","number","number"])}function r(s){let{backend:i,inputs:{x:o}}=s,u=i.dataIdMap.get(o.dataId).id,d=i.makeOutput(o.shape,t||o.dtype),c=i.dataIdMap.get(d.dataId).id;return C.sizeFromShape(d.shape)===0||a(u,Et[o.dtype],c),d}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var nye=Nt(Kd),rye=Nt(iu),sye=Nt(ou);function Ma(e,t,a){let n;function r(i){n=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:o,inputs:u}=i,{a:d,b:c}=u,f=o.dataIdMap.get(d.dataId).id,m=o.dataIdMap.get(c.dataId).id,g=a??d.dtype,b=D.assertAndGetBroadcastShape(d.shape,c.shape),v=o.makeOutput(b,g);if(C.sizeFromShape(b)===0)return v;let x=new Uint8Array(new Int32Array(d.shape).buffer),k=new Uint8Array(new Int32Array(c.shape).buffer),S=o.dataIdMap.get(v.dataId).id;return n(f,x,d.shape.length,m,k,c.shape.length,Et[d.dtype],S),v}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var iye=Ma(Oo),V3;function oye(e){V3=e.wasm.cwrap(lu,null,["array","number","number","number"])}function lye(e){let{inputs:t,backend:a}=e,n=a.makeOutput(t[0].shape,t[0].dtype);if(C.sizeFromShape(n.shape)===0)return n;let r=t.map(o=>a.dataIdMap.get(o.dataId).id),s=new Uint8Array(new Int32Array(r).buffer),i=a.dataIdMap.get(n.dataId).id;return V3(s,r.length,Et[n.dtype],i),n}var uye={kernelName:lu,backendName:"wasm",setupFunc:oye,kernelFunc:lye};function Xv(e){let{inputs:{x:t},backend:a}=e;if(t.dtype==="string")return _n(a.readSync(t.dataId),t.shape,t.dtype);let n=a.makeOutput(t.shape,t.dtype),r=a.typedArrayFromHeap(t);return a.typedArrayFromHeap(n).set(r),n}var cye={kernelName:Fu,backendName:"wasm",kernelFunc:Xv},G3;function dye(e){G3=e.wasm.cwrap(yi,null,["number","array","number","number","number","array","number"])}function Do(e){let{inputs:t,backend:a,attrs:n}=e,[r,s]=pye(t.x.shape,n.perm),i=!0;for(let b=0;b<s.length;b++)s[b]!==b&&(i=!1);let o=hye(t.x.shape,n.perm),u={dataId:t.x.dataId,shape:r,dtype:t.x.dtype};if(i){let b=Xv({inputs:t,backend:a});return b.shape=o,b}let d=a.makeOutput(o,u.dtype),c=a.dataIdMap.get(u.dataId).id,f=a.dataIdMap.get(d.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),g=new Uint8Array(new Int32Array(u.shape).buffer);return G3(c,g,u.shape.length,Et[u.dtype],f,m,s.length),d}function hye(e,t){let a=new Array(e.length);for(let n=0;n<a.length;n++)a[n]=e[t[n]];return a}function pye(e,t){let a=[],n=[];for(let r=0;r<e.length;++r)e[r]!==1&&a.push(e[r]),e[t[r]]!==1&&n.push(t[r]);for(let r=0;r<n.length;++r){let s=-1;for(let i=0;i<n.length;++i)n[i]>=r&&(s===-1||n[s]>n[i])&&(s=i);n[s]=r}return[a,n]}var fye={kernelName:yi,backendName:"wasm",kernelFunc:Do,setupFunc:dye};function jo(e,t,a){let n=e.shape,r=e.shape.length,s=C.parseAxisParam(t,n),i=s,o=D.getAxesPermutation(i,r),u=null,d=!1;if(o!=null){let c=new Array(r);for(let m=0;m<c.length;m++)c[m]=n[o[m]];i=D.getInnerMostAxes(i.length,r),u=Do({inputs:{x:e},attrs:{perm:o},backend:a});let f=a.dataIdMap.get(e.dataId).id;a.dataIdMap.get(u.dataId).id!==f&&(d=!0)}return{transposed:u,originalAxes:s,axes:i,inputWasTransposed:d}}var H3;function mye(e){H3=e.wasm.cwrap(Xd,null,["number, number, number"])}function gye(e){let{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:s}=n,{x:i}=a,o=t.dataIdMap.get(i.dataId).id,u=i,{transposed:d,axes:c,originalAxes:f,inputWasTransposed:m}=jo(i,r,t);if(m){let S=t.dataIdMap.get(d.dataId).id;u=d,o=S}let g=u.shape.length;D.assertAxesAreInnerMostDims("all",c,g);let[b,v]=D.computeOutAndReduceShapes(u.shape,c),x=C.sizeFromShape(v),k=t.makeOutput(b,i.dtype);if(C.sizeFromShape(u.shape)!==0){let S=t.dataIdMap.get(k.dataId).id;H3(o,x,S)}if(m&&t.disposeData(d.dataId),s){let S=D.expandShapeToKeepDim(k.shape,f);k.shape=S}return k}var yye={kernelName:Xd,backendName:"wasm",setupFunc:mye,kernelFunc:gye},q3;function bye(e){q3=e.wasm.cwrap(Yd,null,["number, number, number"])}function vye(e){let{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:s}=n,{x:i}=a,o=t.dataIdMap.get(i.dataId).id,u=i,{transposed:d,axes:c,originalAxes:f,inputWasTransposed:m}=jo(i,r,t);if(m){let S=t.dataIdMap.get(d.dataId).id;u=d,o=S}let g=u.shape.length;D.assertAxesAreInnerMostDims("any",c,g);let[b,v]=D.computeOutAndReduceShapes(u.shape,c),x=C.sizeFromShape(v),k=t.makeOutput(b,i.dtype);if(C.sizeFromShape(u.shape)!==0){let S=t.dataIdMap.get(k.dataId).id;q3(o,x,S)}if(m&&t.disposeData(d.dataId),s){let S=D.expandShapeToKeepDim(k.shape,f);k.shape=S}return k}var xye={kernelName:Yd,backendName:"wasm",setupFunc:bye,kernelFunc:vye};function j3(e){let t;function a(r){t=r.wasm.cwrap(e,null,["number","number","number","number","number"])}function n(r){let{backend:s,inputs:i,attrs:o}=r,{axis:u}=o,{x:d}=i,c=s.dataIdMap.get(d.dataId).id,f=c,m=d,{transposed:g,axes:b,inputWasTransposed:v}=jo(d,u,s);if(v){let _=s.dataIdMap.get(g.dataId).id;_!==c&&(m=g,f=_)}let x=m.shape.slice(0,-1),k=s.makeOutput(x,"int32"),S=s.dataIdMap.get(k.dataId).id,N=C.sizeFromShape(k.shape),T=m.shape[b[0]];return t(f,Et[m.dtype],N,T,S),v&&s.disposeData(g.dataId),k}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:n}}var wye=j3(Zd),kye=j3(Qd),Sye=Nt(uu),Iye=Nt(cu),Nye=Nt(du),Tye=Ma(pu),_ye=Nt(hu),K3;function Cye(e){K3=e.wasm.cwrap(fu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Eye(e){let{inputs:t,attrs:a,backend:n}=e,r=t.x,s=n.dataIdMap.get(r.dataId).id,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=a,c=D.computePool2DInfo(r.shape,i,o,1,u,d),f=c.filterHeight,m=c.filterWidth,g=c.padInfo.top,b=c.padInfo.right,v=c.padInfo.bottom,x=c.padInfo.left,k=c.strideHeight,S=c.strideWidth,N=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let T=n.makeOutput(c.outShape,"float32"),_=n.dataIdMap.get(T.dataId).id;return K3(s,r.shape[0],r.shape[1],r.shape[2],f,m,g,b,v,x,k,S,N,_),T}var Aye={kernelName:fu,backendName:"wasm",setupFunc:Cye,kernelFunc:Eye},X3;function $ye(e){X3=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Rye(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=n,c=D.computePool3DInfo(r.shape,s,i,1,o,u,d),f=a.makeOutput(c.outShape,r.dtype);return X3(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(f.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),f}var Dye={kernelName:Jd,backendName:"wasm",setupFunc:$ye,kernelFunc:Rye},Y3;function Mye(e){Y3=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Fye(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=n,c=D.computePool3DInfo(s.shape,i,o,1,u,d),f=a.makeOutput(s.shape,s.dtype);return Y3(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(f.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),f}var Oye={kernelName:dm,backendName:"wasm",setupFunc:Mye,kernelFunc:Fye},Z3;function zye(e){Z3=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Lye(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u}=n,d=D.computePool2DInfo(s.shape,i,o,1,u),c=a.makeOutput(s.shape,s.dtype);return Z3(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(c.dataId).id,d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.effectiveFilterHeight,d.effectiveFilterWidth,d.padInfo.top,d.padInfo.left,d.filterHeight,d.filterWidth),c}var Bye={kernelName:cm,backendName:"wasm",setupFunc:zye,kernelFunc:Lye};function Vn(e){let{inputs:t,attrs:a}=e,{x:n}=t,{shape:r}=a,s=C.sizeFromShape(n.shape),i=C.inferFromImplicitShape(r,s);return C.assert(s===C.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype}}var Uye={kernelName:Rh,backendName:"wasm",kernelFunc:Vn},Q3;function Pye(e){Q3=e.wasm.cwrap(mu,null,["number","array","number","number","array","number","number","number","number"])}function Wye(e){let{inputs:t,backend:a,attrs:n}=e,{a:r,b:s}=t,{transposeA:i,transposeB:o}=n;if(r.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=r.shape.length,d=s.shape.length,c=i?r.shape[u-2]:r.shape[u-1],f=o?s.shape[d-1]:s.shape[d-2],m=i?r.shape[u-1]:r.shape[u-2],g=o?s.shape[d-2]:s.shape[d-1],b=r.shape.slice(0,-2),v=s.shape.slice(0,-2),x=C.sizeFromShape(b),k=C.sizeFromShape(v),S=Yh.assertAndGetBroadcastShape(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,g]);C.assert(c===f,()=>`Error in matMul: inner shapes (${c}) and (${f}) of Tensors with shapes ${r.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`);let N=i?[x,c,m]:[x,m,c],T=o?[k,g,f]:[k,f,g],_=Vn({inputs:{x:r},backend:a,attrs:{shape:N}}),R=Vn({inputs:{x:s},backend:a,attrs:{shape:T}}),M=a.dataIdMap.get(_.dataId).id,F=a.dataIdMap.get(R.dataId).id,B=i?_.shape[2]:_.shape[1],V=o?R.shape[1]:R.shape[2],P=Math.max(x,k),A=a.makeOutput([P,B,V],_.dtype),G=a.dataIdMap.get(A.dataId).id,J=new Uint8Array(new Int32Array(_.shape).buffer),ee=new Uint8Array(new Int32Array(R.shape).buffer);return Q3(M,J,_.shape.length,F,ee,R.shape.length,i,o,G),a.disposeData(_.dataId),a.disposeData(R.dataId),A.shape=S,A}var Vye={kernelName:mu,backendName:"wasm",setupFunc:Pye,kernelFunc:Wye};function nu(e){let{inputs:{x:t},attrs:{begin:a,size:n},backend:r}=e,[s,i]=Pa.parseSliceParams(t,a,n),o=Pa.isSliceContinous(t.shape,s,i),u=r.readSync(t.dataId),d=r.makeOutput(i,t.dtype),c=C.computeStrides(t.shape),f=r.dataIdMap.get(d.dataId);if(o){let b=Pa.computeFlatOffset(s,c);return t.dtype==="string"?f.stringBytes=u.slice(b,b+C.sizeFromShape(i)):r.typedArrayFromHeap(d).set(u.subarray(b,b+C.sizeFromShape(i))),d}if(t.dtype==="string"){let b=hb(u,s,i,t.shape,t.dtype);return f.stringBytes=b,d}let m=r.typedArrayFromHeap(d),g=t.shape.length;if(g===2)Gye(u,c[0],m,s,i);else if(g===3)Hye(u,c[0],c[1],m,s,i);else if(g===4)qye(u,c[0],c[1],c[2],m,s,i);else{let b=hb(u,s,i,t.shape,t.dtype);m.set(b)}return d}function Gye(e,t,a,n,r){let s=0,i=n[0],o=n[1],u=i+r[0];for(let d=i;d<u;d++){let c=d*t+o;a.set(e.subarray(c,c+r[1]),s),s+=r[1]}}function Hye(e,t,a,n,r,s){let i=0,o=r[0],u=r[1],d=r[2],c=o+s[0],f=u+s[1];for(let m=o;m<c;m++)for(let g=u;g<f;g++){let b=m*t+g*a+d;n.set(e.subarray(b,b+s[2]),i),i+=s[2]}}function qye(e,t,a,n,r,s,i){let o=0,u=s[0],d=s[1],c=s[2],f=u+i[0],m=d+i[1],g=c+i[2],b=s[3];for(let v=u;v<f;v++)for(let x=d;x<m;x++)for(let k=c;k<g;k++){let S=v*t+x*a+k*n+b;r.set(e.subarray(S,S+i[3]),o),o+=i[3]}}var jye={kernelName:Bh,backendName:"wasm",kernelFunc:nu};function Kye(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{blockShape:s,crops:i}=n,o=s.reduce((k,S)=>k*S),u=D.getReshaped(r.shape,s,o),d=D.getPermuted(u.length,s.length),c=D.getReshapedPermuted(r.shape,s,o),f=D.getSliceBeginCoords(i,s.length),m=D.getSliceSize(c,i,s.length),g=Vn({inputs:{x:r},backend:a,attrs:{shape:u}}),b=Do({inputs:{x:g},backend:a,attrs:{perm:d}}),v=Vn({inputs:{x:b},backend:a,attrs:{shape:c}}),x=nu({inputs:{x:v},backend:a,attrs:{begin:f,size:m}});return a.disposeData(g.dataId),a.disposeData(b.dataId),a.disposeData(v.dataId),x}var Xye={kernelName:eh,backendName:"wasm",kernelFunc:Kye},J3;function Yye(e){J3=e.wasm.cwrap(th,null,["number","number","boolean","number","number","number"])}function Zye(e){let{backend:t,inputs:a,attrs:n}=e,{x:r,weights:s}=a,{size:i}=n,o=s.shape.reduce((f,m)=>f*m,1)!==0,u=r.shape.length===1?[i]:[r.shape[0],i],d=t.makeOutput(u,s.dtype);function c(f){return t.dataIdMap.get(f.dataId).id}return J3(c(r),i,o,c(s),Et[s.dtype],c(d)),d}var Qye={kernelName:th,backendName:"wasm",setupFunc:Yye,kernelFunc:Zye},Jye=Ma(ah);function ebe(e){let{inputs:t,backend:a}=e,{s0:n,s1:r}=t,s=a.typedArrayFromHeap(n),i=a.typedArrayFromHeap(r),o=D.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return a.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var tbe={kernelName:hm,backendName:"wasm",kernelFunc:ebe};function Ko(e){let{inputs:{x:t},attrs:{dtype:a},backend:n}=e,r=n.makeOutput(t.shape,a),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}var abe={kernelName:gu,backendName:"wasm",kernelFunc:Ko},nbe=Nt(yu),ez;function rbe(e){ez=e.wasm.cwrap(zo,null,["number","number","number","number"])}function sbe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{clipValueMin:s,clipValueMax:i}=n,o=a.dataIdMap.get(r.dataId).id,u=a.makeOutput(r.shape,r.dtype),d=a.dataIdMap.get(u.dataId).id;return ez(o,s,i,d),u}var ibe={kernelName:zo,backendName:"wasm",setupFunc:rbe,kernelFunc:sbe};function tz(e){let{inputs:t,backend:a}=e,n=C.parseAxisParam(e.attrs.axis,t[0].shape)[0],r=t.map(g=>g.shape);D.assertParamsConsistent(r,n);let s=D.computeOutShape(t.map(g=>g.shape),n),i=t.filter(g=>C.sizeFromShape(g.shape)>0);if(i.length===1)return Xv({inputs:{x:i[0]},backend:a});let o=a.makeOutput(s,t[0].dtype);if(C.sizeFromShape(s)===0)return o;if(i[0].dtype==="string"){let g=i.map(N=>{let T=[-1,C.sizeFromShape(N.shape.slice(n))];return Vn({inputs:{x:N},backend:a,attrs:{shape:T}})}),b=g.map(N=>({vals:a.readSync(N.dataId),shape:N.shape}));s=D.computeOutShape(g.map(N=>N.shape),1);let v=g[0].shape[0]===1,x=j2(b,s,t[0].dtype,v),k=D.computeOutShape(i.map(N=>N.shape),n);o.shape=k;let S=a.dataIdMap.get(o.dataId);return S.stringBytes=D.fromStringArrayToUint8(x),g.forEach(N=>a.disposeData(N.dataId)),o}let u=C.sizeFromShape(i[0].shape.slice(0,n)),d=0,c=i.map(g=>{let b=C.sizeFromShape(g.shape.slice(n));return d+=b,b}),f=i.map(g=>a.typedArrayFromHeap(g)),m=a.typedArrayFromHeap(o);for(let g=0;g<u;g++){let b=g*d;for(let v=0;v<f.length;v++){let x=c[v],k=g*x,S=f[v].subarray(k,k+x);m.set(S,b),b+=x}}return o}var obe={kernelName:nh,backendName:"wasm",kernelFunc:tz},az;function lbe(e){az=e.wasm.cwrap(bu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ube(e){let{inputs:t,attrs:a,backend:n}=e,{x:r,filter:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:d,pad:c,dimRoundingMode:f,dataFormat:m}=a,g=D.convertConv2DDataFormat(m),b=D.computeConv2DInfo(r.shape,s.shape,u,d,c,f,!1,g),v=b.filterHeight,x=b.filterWidth,k=b.padInfo.top,S=b.padInfo.right,N=b.padInfo.bottom,T=b.padInfo.left,_=b.dilationHeight,R=b.dilationWidth,M=b.strideHeight,F=b.strideWidth,B=b.inChannels,V=b.outChannels,P=b.padInfo.type==="SAME"?1:0;if(b.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${b.dataFormat}'. Please use 'channelsLast'.`);let A=n.makeOutput(b.outShape,"float32"),G=n.dataIdMap.get(A.dataId).id;return az(i,r.shape[0],r.shape[1],r.shape[2],o,v,x,k,S,N,T,P,_,R,M,F,B,V,G),A}var cbe={kernelName:bu,backendName:"wasm",setupFunc:lbe,kernelFunc:ube},nz;function dbe(e){nz=e.wasm.cwrap(vu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function hbe(e){let{backend:t,inputs:a,attrs:n}=e,{dy:r,filter:s}=a,{strides:i,pad:o,dataFormat:u,dimRoundingMode:d,inputShape:c}=n,f=1,m=D.convertConv2DDataFormat(u),g=D.computeConv2DInfo(c,s.shape,i,f,o,d,!1,m),{batchSize:b,filterHeight:v,filterWidth:x,inChannels:k,inHeight:S,inWidth:N,outChannels:T,outHeight:_,outWidth:R,strideHeight:M,strideWidth:F}=g,B=v-1-g.padInfo.top,V=x-1-g.padInfo.left,P=g.dataFormat==="channelsLast",A=C.computeStrides(g.inShape),G=C.computeStrides(r.shape),[J,ee,W]=C.computeStrides(s.shape),X=A[0],Q=P?A[1]:A[2],ce=P?A[2]:1,L=P?1:A[1],q=G[0],le=P?G[1]:G[2],se=P?G[2]:1,pe=P?1:G[1],ve=t.makeOutput(g.inShape,"float32"),Ie=t.dataIdMap.get(ve.dataId).id,Re=t.dataIdMap.get(r.dataId).id,Ne=t.dataIdMap.get(s.dataId).id;return nz(Re,Ne,b,v,x,S,N,k,_,R,T,M,F,B,V,J,ee,W,X,Q,ce,L,q,le,se,pe,Ie),ve}var pbe={kernelName:vu,backendName:"wasm",setupFunc:dbe,kernelFunc:hbe},rz;function fbe(e){rz=e.wasm.cwrap(xu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function mbe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=n;if(r.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let d=D.computeConv3DInfo(r.shape,s.shape,i,u,o),c=a.makeOutput(d.outShape,r.dtype);return rz(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(c.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}var gbe={kernelName:xu,backendName:"wasm",setupFunc:fbe,kernelFunc:mbe},sz;function ybe(e){sz=e.wasm.cwrap(rh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bbe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,dy:s}=t,{strides:i,pad:o,filterShape:u}=n;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let d=D.computeConv3DInfo(r.shape,u,i,1,o),c=a.makeOutput(d.filterShape,s.dtype);return sz(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(c.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}var vbe={kernelName:rh,backendName:"wasm",setupFunc:ybe,kernelFunc:bbe},iz;function xbe(e){iz=e.wasm.cwrap(sh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wbe(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,filter:s}=t,{pad:i,strides:o,inputShape:u}=n;if(r.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${r.dtype}`);if(s.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${s.dtype}`);let d=D.computeConv3DInfo(u,s.shape,o,1,i),c=a.makeOutput(d.inShape,r.dtype);return iz(a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(c.dataId).id,d.batchSize,d.inDepth,d.inHeight,d.inWidth,d.inChannels,d.outDepth,d.outHeight,d.outWidth,d.outChannels,d.strideDepth,d.strideHeight,d.strideWidth,d.dilationDepth,d.dilationHeight,d.dilationWidth,d.filterDepth,d.filterHeight,d.filterWidth,d.padInfo.front,d.padInfo.top,d.padInfo.left),c}var kbe={kernelName:sh,backendName:"wasm",setupFunc:xbe,kernelFunc:wbe},Sbe=Nt(wu),Ibe=Nt(ku),x1;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(x1||(x1={}));var oz;function Nbe(e){oz=e.wasm.cwrap(oh,null,["number","number","number","number","array","number","number","number","number","number"])}function Tbe(e){let{backend:t,inputs:a,attrs:n}=e,{method:r,extrapolationValue:s,cropSize:i}=n,{image:o,boxes:u,boxInd:d}=a,c=u.shape[0],[f,m]=i,g=[c,f,m,o.shape[3]],b=t.dataIdMap.get(o.dataId),v;o.dtype!=="float32"&&(v=Ko({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),b=t.dataIdMap.get(v.dataId));let x=b.id,k=t.dataIdMap.get(u.dataId).id,S=t.dataIdMap.get(d.dataId).id,N=t.makeOutput(g,"float32"),T=t.dataIdMap.get(N.dataId).id,_=new Uint8Array(new Int32Array(o.shape).buffer);return oz(x,k,S,c,_,f,m,x1[r],s,T),v!=null&&t.disposeData(v.dataId),N}var _be={kernelName:oh,backendName:"wasm",setupFunc:Nbe,kernelFunc:Tbe},lz;function Cbe(e){lz=e.wasm.cwrap(ih,null,["number","number","number","number","number","number"])}function Ebe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=n,u=r.shape.length;C.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumprod does not support ${r.dtype} tensors in the WASM backend`);let d=D.getAxesPermutation([s],u),c=r;d!==null&&(c=Do({inputs:{x:r},attrs:{perm:d},backend:a}));let f=D.getInnerMostAxes(1,u)[0];D.assertAxesAreInnerMostDims("cumprod",[f],u);let m=a.makeOutput(c.shape,c.dtype),g=c.shape[f],b=a.dataIdMap.get(c.dataId).id,v=a.dataIdMap.get(m.dataId).id;lz(b,i?1:0,o?1:0,g,v,Et[r.dtype]);let x=m;if(d!==null){let k=D.getUndoAxesPermutation(d);x=Do({inputs:{x:m},attrs:{perm:k},backend:a}),a.disposeData(c.dataId),a.disposeData(m.dataId)}return x}var Abe={kernelName:ih,backendName:"wasm",setupFunc:Cbe,kernelFunc:Ebe},uz;function $be(e){uz=e.wasm.cwrap(Su,null,["number","number","number","number","number","number"])}function Rbe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{axis:s,exclusive:i,reverse:o}=n,u=r.shape.length;C.assert(r.dtype==="float32"||r.dtype==="int32",()=>`cumsum does not support ${r.dtype} tensors in the WASM backend`);let d=D.getAxesPermutation([s],u),c=r;d!==null&&(c=Do({inputs:{x:r},attrs:{perm:d},backend:a}));let f=D.getInnerMostAxes(1,u)[0];D.assertAxesAreInnerMostDims("cumsum",[f],u);let m=a.makeOutput(c.shape,c.dtype),g=c.shape[f],b=a.dataIdMap.get(c.dataId).id,v=a.dataIdMap.get(m.dataId).id;uz(b,i?1:0,o?1:0,g,v,Et[r.dtype]);let x=m;if(d!==null){let k=D.getUndoAxesPermutation(d);x=Do({inputs:{x:m},attrs:{perm:k},backend:a}),a.disposeData(c.dataId),a.disposeData(m.dataId)}return x}var Dbe={kernelName:Su,backendName:"wasm",setupFunc:$be,kernelFunc:Rbe},cz;function Mbe(e){cz=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function Fbe(e){let{backend:t,inputs:a,attrs:n}=e,{x:r,weights:s}=a,{size:i,binaryOutput:o}=n,u=s.shape.reduce((m,g)=>m*g,1)!==0,d=r.shape.length===1?[i]:[r.shape[0],i],c=t.makeOutput(d,s.dtype);function f(m){return t.dataIdMap.get(m.dataId).id}return cz(f(r),new Uint8Array(new Int32Array(r.shape).buffer),r.shape.length,i,u,f(s),Et[s.dtype],o,f(c)),c}var Obe={kernelName:fm,backendName:"wasm",setupFunc:Mbe,kernelFunc:Fbe},dz;function zbe(e){dz=e.wasm.cwrap(lh,null,["number","number","number","array","number","array","array","number","number"])}function Lbe(e){let{backend:t,inputs:a,attrs:n}=e,{x:r}=a,{blockSize:s,dataFormat:i}=n,o=r.shape[0],u=i==="NHWC"?r.shape[1]:r.shape[2],d=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],f=u*s,m=d*s,g=c/(s*s),b=i==="NHWC"?[o,f,m,g]:[o,g,f,m],v=t.makeOutput(b,"float32"),x=t.dataIdMap.get(r.dataId).id,k=new Uint8Array(new Int32Array(C.computeStrides(r.shape)).buffer),S=new Uint8Array(new Int32Array(b).buffer),N=new Uint8Array(new Int32Array(C.computeStrides(b)).buffer),T=t.dataIdMap.get(v.dataId).id;return dz(x,s,i==="NHWC"?1:0,k,r.shape.length-1,S,N,b.length,T),v}var Bbe={kernelName:lh,backendName:"wasm",setupFunc:zbe,kernelFunc:Lbe},hz;function Ube(e){hz=e.wasm.cwrap(Iu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Pbe(e){let{inputs:t,attrs:a,backend:n}=e,{x:r,filter:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:d,pad:c,dimRoundingMode:f}=a,m=d??[1,1],g=D.computeConv2DInfo(r.shape,s.shape,u,m,c,f,!0),b=g.filterHeight,v=g.filterWidth,x=g.padInfo.top,k=g.padInfo.right,S=g.padInfo.bottom,N=g.padInfo.left,T=g.dilationHeight,_=g.dilationWidth,R=g.strideHeight,M=g.strideWidth,F=g.inChannels,B=g.outChannels,V=g.padInfo.type==="SAME"?1:0;if(g.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${g.dataFormat}'. Please use 'channelsLast'.`);let P=n.makeOutput(g.outShape,"float32"),A=n.dataIdMap.get(P.dataId).id;return hz(i,r.shape[0],r.shape[1],r.shape[2],o,b,v,x,k,S,N,V,T,_,R,M,F,B,A),P}var Wbe={kernelName:Iu,backendName:"wasm",setupFunc:Ube,kernelFunc:Pbe},pz;function Vbe(e){pz=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function Gbe(e){let{inputs:t,backend:a}=e,{x:n}=t,r=C.sizeFromShape(n.shape),s=a.makeOutput([...n.shape,...n.shape],n.dtype);return pz(a.dataIdMap.get(n.dataId).id,Et[n.dtype],r,a.dataIdMap.get(s.dataId).id),s}var Hbe={kernelName:mm,backendName:"wasm",setupFunc:Vbe,kernelFunc:Gbe},fz;function qbe(e){fz=e.wasm.cwrap(Nu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function jbe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s}=t,{strides:i,pad:o,dilations:u}=n;if(r.dtype!==s.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${r.dtype} and ${s.dtype}`);let d=D.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",u),c=a.makeOutput(d.outShape,r.dtype);return fz(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(c.dataId).id,Et[r.dtype],d.batchSize,d.inChannels,d.inHeight,d.inWidth,d.outHeight,d.outWidth,d.strideHeight,d.strideWidth,d.dilationHeight,d.dilationWidth,d.filterHeight,d.filterWidth,d.padInfo.top,d.padInfo.left),c}var Kbe={kernelName:Nu,backendName:"wasm",setupFunc:qbe,kernelFunc:jbe},mz;function Xbe(e){mz=e.wasm.cwrap($d,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ybe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:u,dilations:d}=n;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let c=D.computeDilation2DInfo(r.shape,s.shape,o,u,"NHWC",d),f=a.makeOutput(s.shape,s.dtype);return mz(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(f.dataId).id,Et[r.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),f}var Zbe={kernelName:$d,backendName:"wasm",setupFunc:Xbe,kernelFunc:Ybe},gz;function Qbe(e){gz=e.wasm.cwrap(Ad,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Jbe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,filter:s,dy:i}=t,{strides:o,pad:u,dilations:d}=n;if(r.dtype!==s.dtype||r.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${r.dtype}, ${s.dtype}, and ${i.dtype}`);let c=D.computeDilation2DInfo(r.shape,s.shape,o,u,"NHWC",d),f=a.makeOutput(r.shape,r.dtype);return gz(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(f.dataId).id,Et[r.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),f}var eve={kernelName:Ad,backendName:"wasm",setupFunc:Qbe,kernelFunc:Jbe},tve=Nt(_u),yz;function ave(e){yz=e.wasm.cwrap(uh,null,["number","number","number"])}function nve(e){let{inputs:t,backend:a}=e,{dy:n,y:r}=t,s=a.makeOutput(r.shape,"float32"),i=o=>a.dataIdMap.get(o.dataId).id;return yz(i(r),i(n),i(s)),s}var rve={kernelName:uh,backendName:"wasm",setupFunc:ave,kernelFunc:nve},sve=!1,ive=Ma(ch,sve,"bool"),ove=Nt(Cu),lve=Nt(Eu,"float32");function w1(e){let{inputs:t,attrs:a,backend:n}=e,{input:r}=t,{dim:s}=a,i=r.shape.length,o=r.shape.slice(),u=s;return s<0&&(C.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),o.splice(u,0,1),Vn({inputs:{x:r},backend:n,attrs:{shape:o}})}var uve={kernelName:dh,backendName:"wasm",kernelFunc:w1},cve=Nt(Au,"float32");function bz(e){let{attrs:{shape:t,value:a},backend:n}=e,{attrs:{dtype:r}}=e;r=r||C.inferDtype(a);let s=n.makeOutput(t,r);return n.typedArrayFromHeap(s).fill(a),s}var dve={kernelName:gm,backendName:"wasm",kernelFunc:bz},vz;function hve(e){vz=e.wasm.cwrap(hh,null,["number","number","number","number","number","number"])}function pve(e){let{inputs:t,backend:a}=e,{image:n}=t,r=a.makeOutput(n.shape,n.dtype),s=a.dataIdMap.get(n.dataId).id,i=a.dataIdMap.get(r.dataId).id,[o,u,d,c]=n.shape;return vz(s,o,u,d,c,i),r}var fve={kernelName:hh,backendName:"wasm",kernelFunc:pve,setupFunc:hve},mve=Nt($u),gve=Ma(Ru),xz;function yve(e){xz=e.wasm.cwrap(Du,null,["number","number","number","number","number","number","number"])}function bve(e){let{backend:t,inputs:a,attrs:n}=e,{varianceEpsilon:r}=n,{x:s,mean:i,variance:o,offset:u,scale:d}=a,c=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(o.dataId).id,g=u!=null?t.dataIdMap.get(u.dataId).id:0,b=d!=null?t.dataIdMap.get(d.dataId).id:0,v=t.makeOutput(s.shape,s.dtype);if(C.sizeFromShape(s.shape)===0)return v;let x=t.dataIdMap.get(v.dataId).id;return xz(c,f,m,g,b,r,x),v}var vve={kernelName:Du,backendName:"wasm",setupFunc:yve,kernelFunc:bve},wz;function xve(e){wz=e.wasm.cwrap(Ul,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wve(e){let{inputs:t,attrs:a,backend:n}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dilations:c,dataFormat:f,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=a,v=D.computeConv2DInfo(r.shape,s.shape,u,c,d,m),x=sm[g];if(x==null)throw new Error(`${g} activation not yet supported for FusedConv2D in the wasm backend.`);let k=n.dataIdMap.get(r.dataId).id,S=n.dataIdMap.get(s.dataId).id,N=v.outChannels,T=0;if(i!=null){let se=n.dataIdMap.get(i.dataId);if(se.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${se.shape.length}.`);if(se.shape[0]!==N)throw new Error(`FusedConv2D bias shape (${se.shape}) does not match the number of output channels (${N})`);T=se.id}let _=v.filterHeight,R=v.filterWidth,M=v.padInfo.top,F=v.padInfo.right,B=v.padInfo.bottom,V=v.padInfo.left,P=v.dilationHeight,A=v.dilationWidth,G=v.strideHeight,J=v.strideWidth,ee=v.inChannels,W=v.padInfo.type==="SAME"?1:0,X=v.batchSize,Q=v.inHeight,ce=v.inWidth;if(f!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${f}'. Please use 'NHWC'.`);let L=n.makeOutput(v.outShape,"float32"),q=n.dataIdMap.get(L.dataId).id,le=o==null?0:n.dataIdMap.get(o.dataId).id;return wz(k,X,Q,ce,S,_,R,T,M,F,B,V,W,P,A,G,J,ee,N,x,le,b||0,q),L}var kve={kernelName:Ul,backendName:"wasm",setupFunc:xve,kernelFunc:wve},kz;function Sve(e){kz=e.wasm.cwrap(Pl,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ive(e){let{inputs:t,attrs:a,backend:n}=e,{x:r,filter:s,bias:i,preluActivationWeights:o}=t,{strides:u,pad:d,dilations:c,dataFormat:f,dimRoundingMode:m,activation:g,leakyreluAlpha:b}=a,v=D.computeConv2DInfo(r.shape,s.shape,u,c,d,m,!0),x=sm[g];if(x==null)throw new Error(`${g} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let k=n.dataIdMap.get(r.dataId).id,S=n.dataIdMap.get(s.dataId).id,N=v.outChannels,T=0;if(i!=null){let se=n.dataIdMap.get(i.dataId);if(se.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${se.shape.length}.`);if(se.shape[0]!==N)throw new Error(`FusedDepthwiseConv2D bias shape (${se.shape}) does not match the number of output channels (${N})`);T=se.id}let _=v.filterHeight,R=v.filterWidth,M=v.padInfo.top,F=v.padInfo.right,B=v.padInfo.bottom,V=v.padInfo.left,P=v.dilationHeight,A=v.dilationWidth,G=v.strideHeight,J=v.strideWidth,ee=v.inChannels,W=v.padInfo.type==="SAME"?1:0,X=v.batchSize,Q=v.inHeight,ce=v.inWidth;if(f!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${f}'. Please use 'NHWC'.`);let L=n.makeOutput(v.outShape,"float32"),q=n.dataIdMap.get(L.dataId).id,le=o==null?0:n.dataIdMap.get(o.dataId).id;return kz(k,X,Q,ce,S,_,R,T,M,F,B,V,W,P,A,G,J,ee,N,x,le,b||0,q),L}var Nve={kernelName:Pl,backendName:"wasm",setupFunc:Sve,kernelFunc:Ive},Sz;function Tve(e){Sz=e.wasm.cwrap(fh,null,["number","number","number","number","number","number","array","number"])}function _ve(e){let{backend:t,inputs:a}=e,{params:n,indices:r}=a,[s,i,o,u]=sS.prepareAndValidate(n,r),d=t.makeOutput(s,n.dtype);if(i===0)return d;let c=r.shape,f=c[c.length-1],m=t.dataIdMap.get(n.dataId).id,g=t.dataIdMap.get(r.dataId).id,b=new Uint8Array(new Int32Array(u).buffer),v=t.dataIdMap.get(d.dataId).id;return Sz(m,Et[n.dtype],g,i,f,o,b,v),d}var Cve={kernelName:fh,backendName:"wasm",setupFunc:Tve,kernelFunc:_ve},Iz;function Eve(e){Iz=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Ave(e){let{backend:t,inputs:a,attrs:n}=e,{x:r,indices:s}=a,{axis:i,batchDims:o}=n,u=C.parseAxisParam(i,r.shape)[0],d=t.readSync(s.dataId),c=r.shape[u];for(let M=0;M<d.length;++M){let F=d[M];C.assert(F<=c-1&&F>=0,()=>`GatherV2: the index value ${F} is not in [0, ${c-1}]`)}let f=D.segment_util.collectGatherOpShapeInfo(r,s,u,o),m=Vn({inputs:{x:r},attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]},backend:t}),g=C.sizeFromShape(s.shape),b=Vn({inputs:{x:s},attrs:{shape:[f.batchSize,g/f.batchSize]},backend:t}),v=[f.batchSize,f.outerSize,g/f.batchSize,f.sliceSize],x=t.makeOutput(v,r.dtype);if(C.sizeFromShape(r.shape)===0)return x;let k=m.shape.length-1,S=t.dataIdMap.get(m.dataId).id,N=t.dataIdMap.get(b.dataId).id,T=t.dataIdMap.get(x.dataId).id,_=new Uint8Array(new Int32Array(C.computeStrides(m.shape)).buffer),R=new Uint8Array(new Int32Array(C.computeStrides(v)).buffer);return Iz(S,Et[r.dtype],_,k,N,f.batchSize,R,T),t.disposeData(m.dataId),t.disposeData(b.dataId),x.shape=f.outputShape,x}var $ve={kernelName:ph,backendName:"wasm",setupFunc:Eve,kernelFunc:Ave},Rve=!1,Dve=Ma(mh,Rve,"bool"),Mve=!1,Fve=Ma(Mu,Mve,"bool"),Ove=Nt(Ou,"bool"),zve=Nt(zu,"bool"),Lve=Nt(Lu,"bool"),Nz;function Bve(e){Nz=e.wasm.cwrap(Bu,null,["number","number","number","number"])}function Uve(e){let{inputs:{x:t},attrs:{alpha:a},backend:n}=e,r=n.dataIdMap.get(t.dataId).id,s=n.makeOutput(t.shape,"float32");if(C.sizeFromShape(t.shape)!==0){let i=n.dataIdMap.get(s.dataId).id;Nz(r,Et[t.dtype],a,i)}return s}var Pve={kernelName:Bu,backendName:"wasm",setupFunc:Bve,kernelFunc:Uve},Wve=!1,Vve=Ma(gh,Wve,"bool"),Gve=!1,Hve=Ma(yh,Gve,"bool"),Tz;function qve(e){Tz=e.wasm.cwrap(bh,null,["number","number","number","number"])}function jve(e){let{attrs:t,backend:a}=e,{start:n,stop:r,num:s}=t,i=Math.floor(s),o=a.makeOutput([i],"float32");return Tz(a.dataIdMap.get(o.dataId).id,n,r,i),o}var Kve={kernelName:bh,backendName:"wasm",setupFunc:qve,kernelFunc:jve},Xve=Nt(Uu),Yve=Nt(Pu),Zve=!1,Qve=Ma(vh,Zve,"bool"),Jve=Nt(xh),exe=!1,txe=Ma(wh,exe,"bool"),axe=!1,nxe=Ma(NA,axe,"bool"),_z;function rxe(e){_z=e.wasm.cwrap(Wu,null,["number","number","number","number","number","number","number"])}function sxe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{depthRadius:s,bias:i,alpha:o,beta:u}=n;if(r.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let d=a.makeOutput(r.shape,r.dtype);return _z(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(d.dataId).id,r.shape[3],s,i,o,u),d}var ixe={kernelName:Wu,backendName:"wasm",setupFunc:rxe,kernelFunc:sxe},Cz;function oxe(e){Cz=e.wasm.cwrap(kh,null,["number","number","number","number","number","number","number","number","number"])}function lxe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r,y:s,dy:i}=t,{depthRadius:o,bias:u,alpha:d,beta:c}=n;if(r.dtype!=="float32"||s.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let f=a.makeOutput(r.shape,r.dtype);return Cz(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(i.dataId).id,a.dataIdMap.get(f.dataId).id,i.shape[3],o,u,d,c),f}var uxe={kernelName:kh,backendName:"wasm",setupFunc:oxe,kernelFunc:lxe},Ez;function cxe(e){Ez=e.wasm.cwrap(Vu,null,["number","number","number","number"])}function dxe(e){let{backend:t,inputs:a,attrs:n}=e,{reductionIndices:r,keepDims:s}=n,{x:i}=a,o=t.dataIdMap.get(i.dataId).id,u=i,{transposed:d,axes:c,originalAxes:f,inputWasTransposed:m}=jo(i,r,t);if(m){let S=t.dataIdMap.get(d.dataId).id;u=d,o=S}let g=u.shape.length;D.assertAxesAreInnerMostDims("max",c,g);let[b,v]=D.computeOutAndReduceShapes(u.shape,c),x=C.sizeFromShape(v),k=t.makeOutput(b,i.dtype);if(C.sizeFromShape(u.shape)!==0){let S=t.dataIdMap.get(k.dataId).id;Ez(o,Et[i.dtype],x,S)}if(m&&t.disposeData(d.dataId),s){let S=D.expandShapeToKeepDim(k.shape,f);k.shape=S}return k}var hxe={kernelName:Vu,backendName:"wasm",setupFunc:cxe,kernelFunc:dxe},pxe=Ma(Gu),Az;function fxe(e){Az=e.wasm.cwrap(Hu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function mxe(e){let{inputs:t,attrs:a,backend:n}=e,r=t.x,s=n.dataIdMap.get(r.dataId).id;C.assert(r.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${r.dtype}.`);let{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=a,c=D.computePool2DInfo(r.shape,i,o,1,u,d),f=c.filterHeight,m=c.filterWidth,g=c.padInfo.top,b=c.padInfo.right,v=c.padInfo.bottom,x=c.padInfo.left,k=c.dilationHeight,S=c.dilationWidth,N=c.strideHeight,T=c.strideWidth,_=c.inChannels,R=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let M=n.makeOutput(c.outShape,"float32"),F=n.dataIdMap.get(M.dataId).id;return Az(s,r.shape[0],r.shape[1],r.shape[2],f,m,g,b,v,x,k,S,N,T,_,R,F),M}var gxe={kernelName:Hu,backendName:"wasm",setupFunc:fxe,kernelFunc:mxe},$z;function yxe(e){$z=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function bxe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:u,dataFormat:d}=n,c=D.computePool3DInfo(r.shape,s,i,1,o,u,d),f=a.makeOutput(c.outShape,r.dtype);return $z(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(f.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),f}var vxe={kernelName:Sh,backendName:"wasm",setupFunc:yxe,kernelFunc:bxe},Rz;function xxe(e){Rz=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wxe(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=n,c=D.computePool3DInfo(s.shape,i,o,1,u,d),f=a.makeOutput(s.shape,s.dtype);return Rz(a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(f.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),f}var kxe={kernelName:bm,backendName:"wasm",setupFunc:xxe,kernelFunc:wxe},Dz;function Sxe(e){Dz=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ixe(e){let{inputs:t,backend:a,attrs:n}=e,{dy:r,input:s}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:d}=n,c=D.computePool2DInfo(s.shape,i,o,1,u,d),f=a.makeOutput(s.shape,s.dtype);return Dz(a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(f.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),f}var Nxe={kernelName:ym,backendName:"wasm",setupFunc:Sxe,kernelFunc:Ixe},Mz;function Txe(e){Mz=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function _xe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{filterSize:s,strides:i,pad:o,includeBatchInIndex:u}=n;C.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let d=[1,1];C.assert(D.eitherStridesOrDilationsAreOne(i,d),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);let c=D.computePool2DInfo(r.shape,s,i,[1,1],o),f=a.makeOutput(c.outShape,r.dtype),m=a.makeOutput(c.outShape,"int32");return Mz(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(f.dataId).id,a.dataIdMap.get(m.dataId).id,Et[r.dtype],u,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[f,m]}var Cxe={kernelName:vm,backendName:"wasm",setupFunc:Txe,kernelFunc:_xe},Fz;function Exe(e){Fz=e.wasm.cwrap(qu,null,["number, number, number"])}function Axe(e){let{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:s}=n,{x:i}=a,o=t.dataIdMap.get(i.dataId).id,u=o,d=i,{transposed:c,axes:f,originalAxes:m,inputWasTransposed:g}=jo(i,r,t),b=f;if(g){let T=t.dataIdMap.get(c.dataId).id;T!==o&&(d=c,u=T,b=D.getInnerMostAxes(b.length,d.shape.length))}D.assertAxesAreInnerMostDims("mean",b,d.shape.length);let[v,x]=D.computeOutAndReduceShapes(d.shape,b),k=C.sizeFromShape(x),S=d;d.dtype!=="float32"&&(S=Ko({backend:t,inputs:{x:d},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(S.dataId).id);let N=t.makeOutput(v,"float32");if(C.sizeFromShape(d.shape)!==0){let T=t.dataIdMap.get(N.dataId).id;Fz(u,k,T)}if(g&&t.disposeData(c.dataId),s){let T=D.expandShapeToKeepDim(N.shape,m);N.shape=T}return d.dtype!=="float32"&&t.disposeData(S.dataId),N}var $xe={kernelName:qu,backendName:"wasm",setupFunc:Exe,kernelFunc:Axe},Oz;function Rxe(e){Oz=e.wasm.cwrap(ju,null,["number","number","number","number"])}function Dxe(e){let{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:s}=n,{x:i}=a,o=t.dataIdMap.get(i.dataId).id,u=o,d=i,{transposed:c,axes:f,originalAxes:m,inputWasTransposed:g}=jo(i,r,t);if(g){let N=t.dataIdMap.get(c.dataId).id;N!==o&&(d=c,u=N)}let b=d.shape.length;D.assertAxesAreInnerMostDims("min",f,b);let[v,x]=D.computeOutAndReduceShapes(d.shape,f),k=C.sizeFromShape(x),S=t.makeOutput(v,d.dtype);if(C.sizeFromShape(d.shape)!==0){let N=t.dataIdMap.get(S.dataId).id;Oz(u,Et[i.dtype],k,N)}if(g&&t.disposeData(c.dataId),s){let N=D.expandShapeToKeepDim(S.shape,m);S.shape=N}return S}var Mxe={kernelName:ju,backendName:"wasm",setupFunc:Rxe,kernelFunc:Dxe},Fxe=Ma(Ku),k1;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(k1||(k1={}));var zz;function Oxe(e){zz=e.wasm.cwrap(Xu,null,["number","array","number","number","array","array","number","number"])}function zxe(e){let{inputs:{x:t},backend:a,attrs:{paddings:n,mode:r}}=e,s=n.map((b,v)=>b[0]+t.shape[v]+b[1]),i=a.dataIdMap.get(t.dataId).id,o=a.makeOutput(s,t.dtype),u=a.dataIdMap.get(o.dataId).id,d=new Uint8Array(new Int32Array(t.shape).buffer),c=n.map(b=>b[0]),f=n.map(b=>b[1]),m=new Uint8Array(new Int32Array(c).buffer),g=new Uint8Array(new Int32Array(f).buffer);return zz(i,d,t.shape.length,Et[t.dtype],m,g,k1[r],u),o}var Lxe={kernelName:Xu,backendName:"wasm",kernelFunc:zxe,setupFunc:Oxe},Lz;function Bxe(e){Lz=e.wasm.cwrap(vc,null,["number","number","number","number"])}function Bz(e){let{backend:t,inputs:{logits:a},attrs:{dim:n}}=e,r=t.dataIdMap.get(a.dataId).id,s=t.makeOutput(a.shape,a.dtype),i=t.dataIdMap.get(s.dataId).id,o=a.shape[n],u=C.sizeFromShape(a.shape)/o;return C.sizeFromShape(s.shape)===0||Lz(r,i,o,u),s}var Uxe={kernelName:vc,backendName:"wasm",setupFunc:Bxe,kernelFunc:Bz},Uz;function Pxe(e){Uz=e.wasm.cwrap(Ih,null,["number","number","number","number","number","number"])}function Wxe(e){let{inputs:t,backend:a,attrs:n}=e,{logits:r}=t,{numSamples:s,seed:i,normalized:o}=n;if(r.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${r.dtype}`);let u=o?r:Bz({inputs:{logits:r},backend:a,attrs:{dim:r.shape.length-1}}),[d,c]=u.shape,f=a.makeOutput([d,s],"int32");return Uz(a.dataIdMap.get(u.dataId).id,d,c,s,i,a.dataIdMap.get(f.dataId).id),o||a.disposeData(u.dataId),f}var Vxe={kernelName:Ih,backendName:"wasm",setupFunc:Pxe,kernelFunc:Wxe},Gxe=Ma(Yu),Hxe=Ma(Zu),qxe=Nt(Nh);function kI(e,t){let a=new Int32Array(e.wasm.HEAPU8.buffer,t,4),n=a[0],r=a[1],s=a[2],i=a[3];return e.wasm._free(t),{pSelectedIndices:n,selectedSize:r,pSelectedScores:s,pValidOutputs:i}}var Pz;function jxe(e){Pz=e.wasm.cwrap(_h,"number",["number","number","number","number","number"])}function Kxe(e){let{backend:t,inputs:a,attrs:n}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i}=n,{boxes:o,scores:u}=a,d=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(u.dataId).id,f=Pz(d,c,s,r,i),{pSelectedIndices:m,selectedSize:g,pSelectedScores:b,pValidOutputs:v}=kI(t,f);return t.wasm._free(b),t.wasm._free(v),t.makeOutput([g],"int32",m)}var Xxe={kernelName:_h,backendName:"wasm",setupFunc:jxe,kernelFunc:Kxe},Wz;function Yxe(e){Wz=e.wasm.cwrap(Ch,"number",["number","number","number","number","number","bool"])}function Zxe(e){let{backend:t,inputs:a,attrs:n}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=n,{boxes:u,scores:d}=a,c=t.dataIdMap.get(u.dataId).id,f=t.dataIdMap.get(d.dataId).id,m=Wz(c,f,s,r,i,o),{pSelectedIndices:g,selectedSize:b,pSelectedScores:v,pValidOutputs:x}=kI(t,m);t.wasm._free(v);let k=t.makeOutput([b],"int32",g),S=t.makeOutput([],"int32",x);return[k,S]}var Qxe={kernelName:Ch,backendName:"wasm",setupFunc:Yxe,kernelFunc:Zxe},Vz;function Jxe(e){Vz=e.wasm.cwrap(Eh,"number",["number","number","number","number","number","number"])}function e0e(e){let{backend:t,inputs:a,attrs:n}=e,{iouThreshold:r,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=n,{boxes:u,scores:d}=a,c=t.dataIdMap.get(u.dataId).id,f=t.dataIdMap.get(d.dataId).id,m=Vz(c,f,s,r,i,o),{pSelectedIndices:g,selectedSize:b,pSelectedScores:v,pValidOutputs:x}=kI(t,m);t.wasm._free(x);let k=t.makeOutput([b],"int32",g),S=t.makeOutput([b],"float32",v);return[k,S]}var t0e={kernelName:Eh,backendName:"wasm",setupFunc:Jxe,kernelFunc:e0e},a0e=!1,n0e=Ma(Th,a0e,"bool"),Gz;function r0e(e){Gz=e.wasm.cwrap(Qu,null,["number","number","number","number","number"])}function s0e(e){let{inputs:t,backend:a,attrs:n}=e,{indices:r}=t,{dtype:s,depth:i,onValue:o,offValue:u}=n,d=a.makeOutput([...r.shape,i],s),c=a.dataIdMap.get(d.dataId).id,f=a.dataIdMap.get(r.dataId).id;return Gz(f,i,o,u,c),d}var i0e={kernelName:Qu,backendName:"wasm",setupFunc:r0e,kernelFunc:s0e};function o0e(e){let{inputs:{x:t},backend:a}=e,n=a.makeOutput(t.shape,t.dtype);return a.typedArrayFromHeap(n).fill(1),n}var l0e={kernelName:Ah,backendName:"wasm",kernelFunc:o0e};function u0e(e){let{inputs:t,backend:a,attrs:n}=e,{axis:r}=n;if(t.length===1)return w1({inputs:{input:t[0]},backend:a,attrs:{dim:r}});let s=t[0].shape,i=t[0].dtype;t.forEach(c=>{C.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),C.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],u=t.map(c=>{let f=w1({inputs:{input:c},backend:a,attrs:{dim:r}});return o.push(f),f}),d=tz({inputs:u,backend:a,attrs:{axis:r}});return o.forEach(c=>a.disposeData(c.dataId)),d}var c0e={kernelName:$h,backendName:"wasm",kernelFunc:u0e},Hz;function d0e(e){Hz=e.wasm.cwrap(Ju,null,["number","array","number","number","array","array","number","number"])}function h0e(e){let{inputs:{x:t},backend:a,attrs:{paddings:n,constantValue:r}}=e,s=n.map((b,v)=>b[0]+t.shape[v]+b[1]);if(C.sizeFromShape(t.shape)===0)return bz({backend:a,attrs:{shape:s,value:r,dtype:t.dtype}});let i=a.dataIdMap.get(t.dataId).id,o=a.makeOutput(s,t.dtype),u=a.dataIdMap.get(o.dataId).id,d=new Uint8Array(new Int32Array(t.shape).buffer),c=n.map(b=>b[0]),f=n.map(b=>b[1]),m=new Uint8Array(new Int32Array(c).buffer),g=new Uint8Array(new Int32Array(f).buffer);return Hz(i,d,t.shape.length,Et[t.dtype],m,g,r,u),o}var qz={kernelName:Ju,backendName:"wasm",kernelFunc:h0e,setupFunc:d0e},p0e=Ma(ec),jz;function f0e(e){jz=e.wasm.cwrap(tc,null,["number","number","number"])}function m0e(e){let{inputs:t,backend:a}=e,{x:n,alpha:r}=t,s=a.dataIdMap.get(n.dataId).id,i=a.dataIdMap.get(r.dataId).id,o=s,u=n,d=u;u.dtype!=="float32"&&(d=Ko({backend:a,inputs:{x:n},attrs:{dtype:"float32"}}),o=a.dataIdMap.get(d.dataId).id);let c=a.makeOutput(n.shape,"float32"),f=a.dataIdMap.get(c.dataId).id;return jz(o,i,f),u.dtype!=="float32"&&a.disposeData(d.dataId),c}var g0e={kernelName:tc,backendName:"wasm",setupFunc:f0e,kernelFunc:m0e},Kz;function y0e(e){Kz=e.wasm.cwrap(ac,null,["number","number","number","number"])}function b0e(e){let{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:s}=n,{x:i}=a,o=t.dataIdMap.get(i.dataId).id,u=o,d=i,{transposed:c,axes:f,originalAxes:m,inputWasTransposed:g}=jo(i,r,t),b=f;if(g){let N=t.dataIdMap.get(c.dataId).id;N!==o&&(d=c,u=N,b=D.getInnerMostAxes(b.length,d.shape.length))}D.assertAxesAreInnerMostDims("prod",b,d.shape.length);let[v,x]=D.computeOutAndReduceShapes(d.shape,b),k=C.sizeFromShape(x),S=t.makeOutput(v,d.dtype);if(C.sizeFromShape(d.shape)!==0){let N=t.dataIdMap.get(S.dataId).id;Kz(u,k,Et[S.dtype],N)}if(g&&t.disposeData(c.dataId),s){let N=D.expandShapeToKeepDim(S.shape,m);S.shape=N}return S}var v0e={kernelName:ac,backendName:"wasm",setupFunc:y0e,kernelFunc:b0e},x0e=e=>{let{backend:t,attrs:a}=e,{start:n,stop:r,step:s,dtype:i}=a,o=Y2(n,r,s,i),u=t.makeOutput([o.length],i);return t.typedArrayFromHeap(u).set(o),u},w0e={kernelName:xm,backendName:"wasm",kernelFunc:x0e},k0e=Ma(Tu),S0e=Nt(nc),I0e=Nt(rc),N0e=Nt(oc),Xz;function T0e(e){Xz=e.wasm.cwrap(ic,null,["number","number","number","number","number","number","number","number","number","number"])}function _0e(e){let{backend:t,inputs:a,attrs:n}=e,{images:r}=a,{alignCorners:s,halfPixelCenters:i,size:o}=n,[u,d]=o,[c,f,m,g]=r.shape,b=[c,u,d,g],v=t.dataIdMap.get(r.dataId),x;v.dtype!=="float32"&&(x=Ko({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),v=t.dataIdMap.get(x.dataId));let k=v.id,S=t.makeOutput(b,"float32");if(C.sizeFromShape(r.shape)===0)return S;let N=t.dataIdMap.get(S.dataId).id;return Xz(k,c,f,m,g,u,d,s?1:0,i?1:0,N),x!=null&&t.disposeData(x.dataId),S}var C0e={kernelName:ic,backendName:"wasm",setupFunc:T0e,kernelFunc:_0e},Yz;function E0e(e){Yz=e.wasm.cwrap(Mh,null,["number","number","number","array","array","boolean"])}function A0e(e){let{inputs:t,backend:a,attrs:n}=e,{images:r,dy:s}=t,{alignCorners:i}=n,o=a.makeOutput(r.shape,"float32"),u=a.dataIdMap.get(r.dataId),d;return u.dtype!=="float32"&&(d=Ko({backend:a,inputs:{x:r},attrs:{dtype:"float32"}}),u=a.dataIdMap.get(d.dataId)),Yz(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),d!=null&&a.disposeData(d.dataId),o}var $0e={kernelName:Mh,backendName:"wasm",setupFunc:E0e,kernelFunc:A0e},Zz;function R0e(e){Zz=e.wasm.cwrap(sc,null,["number","number","number","number","number","number","number","number","number","number"])}function D0e(e){let{backend:t,inputs:a,attrs:n}=e,{images:r}=a,{alignCorners:s,halfPixelCenters:i,size:o}=n,[u,d]=o,[c,f,m,g]=r.shape,b=[c,u,d,g],v=t.makeOutput(b,"float32");if(C.sizeFromShape(r.shape)===0)return v;let x=t.dataIdMap.get(r.dataId),k;x.dtype!=="float32"&&(k=Ko({backend:t,inputs:{x:r},attrs:{dtype:"float32"}}),x=t.dataIdMap.get(k.dataId));let S=x.id,N=t.dataIdMap.get(v.dataId).id;return Zz(S,c,f,m,g,u,d,s?1:0,i?1:0,N),k!=null&&t.disposeData(k.dataId),v}var M0e={kernelName:sc,backendName:"wasm",setupFunc:R0e,kernelFunc:D0e},Qz;function F0e(e){Qz=e.wasm.cwrap(Dh,null,["number","number","number","array","array","boolean"])}function O0e(e){let{inputs:t,backend:a,attrs:n}=e,{images:r,dy:s}=t,{alignCorners:i}=n,o=a.makeOutput(r.shape,"float32"),u=a.dataIdMap.get(r.dataId),d;return u.dtype!=="float32"&&(d=Ko({backend:a,inputs:{x:r},attrs:{dtype:"float32"}}),u=a.dataIdMap.get(d.dataId)),Qz(a.dataIdMap.get(r.dataId).id,a.dataIdMap.get(s.dataId).id,a.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(r.shape).buffer),new Uint8Array(new Int32Array(s.shape).buffer),i),d!=null&&a.disposeData(d.dataId),o}var z0e={kernelName:Dh,backendName:"wasm",setupFunc:F0e,kernelFunc:O0e},Jz;function L0e(e){Jz=e.wasm.cwrap(lc,null,["number","array","number","array","number","number"])}function B0e(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{dims:s}=n,i=C.parseAxisParam(s,r.shape);if(r.shape.length===0)return Xv({inputs:{x:r},backend:a});let o=a.makeOutput(r.shape,r.dtype),u=a.dataIdMap.get(r.dataId).id,d=a.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),f=new Uint8Array(new Int32Array(r.shape).buffer);Jz(u,c,i.length,f,r.shape.length,d);let m=Vn({inputs:{x:o},attrs:{shape:r.shape},backend:a});return a.disposeData(o.dataId),m}var U0e={kernelName:lc,backendName:"wasm",kernelFunc:B0e,setupFunc:L0e},eL;function P0e(e){eL=e.wasm.cwrap(Xh,null,["number","number","number","number","number","number","number","number","array","number","number"])}function W0e(e){let{inputs:t,backend:a,attrs:n}=e,{image:r}=t,{radians:s,fillValue:i,center:o}=n,u=a.makeOutput(r.shape,r.dtype),d=a.dataIdMap.get(r.dataId).id,c=a.dataIdMap.get(u.dataId).id,[f,m,g,b]=r.shape,[v,x]=D.getImageCenter(o,m,g),k=i===0,S=255,N=typeof i=="number"?[i,i,i,k?0:S]:[...i,S],T=new Uint8Array(new Int32Array(N).buffer);return eL(d,f,m,g,b,s,v,x,T,N.length,c),u}var V0e={kernelName:Xh,backendName:"wasm",kernelFunc:W0e,setupFunc:P0e},G0e=Nt(uc),H0e=Nt(cc),tL;function q0e(e){tL=e.wasm.cwrap(Fh,null,["number","number","number","number","number","number","array","number","number"])}function j0e(e){let{backend:t,inputs:a,attrs:n}=e,{indices:r,updates:s}=a,{shape:i}=n,o=t.makeOutput(i,s.dtype);if(C.sizeFromShape(i)===0)return o;let{sliceRank:u,numUpdates:d,sliceSize:c,strides:f,outputSize:m}=dv.calculateShapes(s,r,i),g=t.dataIdMap.get(r.dataId).id,b=t.dataIdMap.get(s.dataId).id,v=new Uint8Array(new Int32Array(f).buffer),x=t.dataIdMap.get(o.dataId).id;return tL(g,b,Et[s.dtype],u,d,c,v,m,x),o}var K0e={kernelName:Fh,backendName:"wasm",setupFunc:q0e,kernelFunc:j0e},aL;function X0e(e){aL=e.wasm.cwrap(zh,null,["number","number","number","number","number","number","bool","number"])}function Y0e(e){let{inputs:t,backend:a,attrs:n}=e,{sortedSequence:r,values:s}=t,{side:i}=n;if(r.dtype!==s.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${r.dtype} and ${s.dtype}`);let o=a.makeOutput(s.shape,"int32");function u(d){return a.dataIdMap.get(d.dataId).id}return aL(u(r),u(s),r.shape[0],r.shape[1],s.shape[1],Et[r.dtype],i==="left",u(o)),o}var Z0e={kernelName:zh,backendName:"wasm",setupFunc:X0e,kernelFunc:Y0e},nL;function Q0e(e){nL=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function J0e(e){let{inputs:t,backend:a}=e,{condition:n,t:r,e:s}=t,i=a.dataIdMap.get(n.dataId).id,o=a.dataIdMap.get(r.dataId).id,u=a.dataIdMap.get(s.dataId).id,d=a.makeOutput(r.shape,r.dtype),c=a.dataIdMap.get(d.dataId).id,f=n.shape.length,m=r.shape.length,g=f===0||f>1||m===1?1:C.sizeFromShape(r.shape.slice(1));return nL(i,o,u,g,c),d}var ewe={kernelName:Lh,backendName:"wasm",kernelFunc:J0e,setupFunc:Q0e},twe=Nt(dc),rL;function awe(e){rL=e.wasm.cwrap(mc,null,["number","number"])}function nwe(e){let{backend:t,inputs:{x:a}}=e,n=t.dataIdMap.get(a.dataId).id,r=t.makeOutput(a.shape,a.dtype),s=t.dataIdMap.get(r.dataId).id;return C.sizeFromShape(r.shape)===0||rL(n,s),r}var rwe={kernelName:"Sigmoid",backendName:"wasm",setupFunc:awe,kernelFunc:nwe},swe=Nt(fc),iwe=Nt(hc),owe=Nt(pc),lwe=Nt(gc);function uwe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,{blockShape:s,paddings:i}=n,o=C.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let x=1+s.length;x<r.shape.length;++x)u.push([0,0]);let d=qz.kernelFunc({inputs:{x:r},backend:a,attrs:{paddings:u,constantValue:0}}),c=D.getReshaped(d.shape,s,o,!1),f=D.getPermuted(c.length,s.length,!1),m=D.getReshapedPermuted(d.shape,s,o,!1),g=Vn({inputs:{x:d},backend:a,attrs:{shape:c}}),b=Do({inputs:{x:g},backend:a,attrs:{perm:f}}),v=Vn({inputs:{x:b},backend:a,attrs:{shape:m}});return a.disposeData(d.dataId),a.disposeData(g.dataId),a.disposeData(b.dataId),v}var cwe={kernelName:Uh,backendName:"wasm",kernelFunc:uwe},sL;function dwe(e){sL=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function hwe(e){let{backend:t,inputs:a}=e,{indices:n,values:r,denseShape:s,defaultValue:i}=a,o=n.shape[0],u=n.shape[1],d=t.readSync(s.dataId)[0],c=[o+d,u],f=t.dataIdMap.get(n.dataId).id,m=t.dataIdMap.get(r.dataId).id,g=t.dataIdMap.get(i.dataId).id,b=t.makeOutput(c,n.dtype),v=t.dataIdMap.get(b.dataId).id,x=t.makeOutput(c.slice(0,1),r.dtype),k=t.dataIdMap.get(x.dataId).id,S=t.makeOutput([d],"bool"),N=t.dataIdMap.get(S.dataId).id,T=t.makeOutput([o],n.dtype),_=t.dataIdMap.get(T.dataId).id,R=t.makeOutput([4],"int32"),M=t.dataIdMap.get(R.dataId).id,F=sL(f,m,Et[r.dtype],o,d,u,g,v,k,N,_,M),B=t.readSync(R.dataId),V;switch(B[0]){case 1:{V=D.getSparseFillEmptyRowsIndicesDenseShapeMismatch(B[1]);break}case 2:{V=D.getSparseFillEmptyRowsNegativeIndexErrorMessage(B[1],B[2]);break}case 3:V=D.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(B[1],B[2],B[3]);break;default:V=""}if(t.disposeData(R.dataId),V)throw t.disposeData(b.dataId),t.disposeData(x.dataId),t.disposeData(S.dataId),t.disposeData(T.dataId),new Error(V);let P=b,A=x;return F!==c[0]&&(P=nu({inputs:{x:b},attrs:{begin:0,size:[F,u]},backend:t}),A=nu({inputs:{x},attrs:{begin:0,size:F},backend:t}),t.disposeData(b.dataId),t.disposeData(x.dataId)),[P,A,S,T]}var pwe={kernelName:wm,backendName:"wasm",setupFunc:dwe,kernelFunc:hwe},iL;function fwe(e){iL=e.wasm.cwrap(Wh,null,["number","number","number","number","number","number","number"])}function mwe(e){let{backend:t,inputs:a}=e,{inputIndices:n,inputShape:r,newShape:s}=a;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(n.dataId).id,o=t.dataIdMap.get(r.dataId).id,u=t.dataIdMap.get(s.dataId).id,d=n.shape[0],c=C.sizeFromShape(s.shape),f=t.makeOutput([d,c],n.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput([c],s.dtype),b=t.dataIdMap.get(g.dataId).id,v=t.makeOutput([3],"int32"),x=t.dataIdMap.get(v.dataId).id;iL(i,o,u,d,m,b,x);let k=t.readSync(v.dataId),S;switch(k[0]){case 0:{S=D.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(k[1],k[2]);break}case 1:{S=D.getSparseReshapeNegativeOutputDimErrorMessage(k[1],k[2]);break}case 2:S=D.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let N=Array.from(t.readSync(r.dataId)),T=Array.from(t.readSync(g.dataId));S=D.getSparseReshapeInputOutputMultipleErrorMessage(N,T);break}case 4:{let N=Array.from(t.readSync(r.dataId)),T=Array.from(t.readSync(g.dataId));S=D.getSparseReshapeInputOutputMismatchErrorMessage(N,T);break}default:S=""}if(t.disposeData(v.dataId),S)throw t.disposeData(f.dataId),t.disposeData(g.dataId),new Error(S);return[f,g]}var gwe={kernelName:Wh,backendName:"wasm",setupFunc:fwe,kernelFunc:mwe},oL;function lL(e){oL=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function uL(e,t){let{backend:a,inputs:n}=e,{data:r,indices:s,segmentIds:i}=n,o=s.shape[0],u=a.readSync(i.dataId,o-1,o)[0],d=o>0?u+1:0;if(d<0)throw new Error(D.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=r.shape.slice();c[0]=d;let f=a.dataIdMap.get(r.dataId).id,m=a.dataIdMap.get(s.dataId).id,g=a.dataIdMap.get(i.dataId).id,b=a.makeOutput(c,r.dtype),v=a.dataIdMap.get(b.dataId).id,x=a.makeOutput([4],"int32"),k=a.dataIdMap.get(x.dataId).id;oL(f,Et[r.dtype],r.shape[0],m,g,v,k,t,0);let S=a.readSync(x.dataId),N;switch(S[0]){case 0:{N=D.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{N=D.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:N=D.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(S[1],S[2]);break;case 3:N=D.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(S[1],S[2],S[3]);break;default:N=""}if(a.disposeData(x.dataId),N)throw a.disposeData(b.dataId),new Error(N);return b}function ywe(e){return uL(e,!0)}var bwe={kernelName:km,backendName:"wasm",setupFunc:lL,kernelFunc:ywe};function vwe(e){return uL(e,!1)}var xwe={kernelName:Sm,backendName:"wasm",setupFunc:lL,kernelFunc:vwe},cL;function wwe(e){cL=e.wasm.cwrap(Vh,null,["number","number","number","number","number","number","number","number","array","number","number"])}function kwe(e){let{backend:t,inputs:a,attrs:n}=e,{sparseIndices:r,sparseValues:s,defaultValue:i}=a,{outputShape:o}=n,u=t.makeOutput(o,i.dtype);if(C.sizeFromShape(o)===0)return u;let{sliceRank:d,numUpdates:c,sliceSize:f,strides:m,outputSize:g}=D.calculateShapes(s,r,o),b=t.dataIdMap.get(r.dataId).id,v=t.dataIdMap.get(s.dataId).id,x=t.dataIdMap.get(i.dataId).id,k=new Uint8Array(new Int32Array(m).buffer),S=t.dataIdMap.get(u.dataId).id;return cL(b,v,s.shape.length,x,Et[i.dtype],d,c,f,k,g,S),u}var Swe={kernelName:Vh,backendName:"wasm",setupFunc:wwe,kernelFunc:kwe};function Iwe(e){let{inputs:t,attrs:a,backend:n}=e,{x:r}=t,{numOrSizeSplits:s,axis:i}=a,o=C.parseAxisParam(i,r.shape)[0],u=D.prepareSplitSize(r,s,o),d=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(f=>{let m=[...c];m[o]=f;let g=nu({inputs:{x:r},attrs:{begin:d,size:m},backend:n});return d[o]+=f,g})}var Nwe={kernelName:Ph,backendName:"wasm",kernelFunc:Iwe},Twe=Nt(yc),_we=Nt(Im),Cwe=Ma(xc),dL;function Ewe(e){dL=e.wasm.cwrap(Bo,null,["number","number","number","number"])}function Awe(e){let{backend:t,inputs:a,attrs:n}=e,{alpha:r}=n,{x:s}=a,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(o.dataId).id;return dL(i,r,Et[s.dtype],u),o}var $we={kernelName:Bo,backendName:"wasm",setupFunc:Ewe,kernelFunc:Awe},hL;function Rwe(e){hL=e.wasm.cwrap(Gh,null,["number","array","number","array","array","array","array","array","number","number"])}function Dwe(e){let{backend:t,inputs:a,attrs:n}=e,{x:r}=a,{begin:s,end:i,strides:o,beginMask:u,endMask:d,ellipsisMask:c,newAxisMask:f,shrinkAxisMask:m}=n,{finalShapeSparse:g,finalShape:b,isIdentity:v,sliceDim0:x,isSimpleSlice:k,begin:S,end:N,strides:T}=Pa.sliceInfo(r.shape,s,i,o,u,d,c,f,m),_;if(v)_=Vn({inputs:{x:r},backend:t,attrs:{shape:b}});else if(x||k){C.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);let R=Pa.computeOutShape(S,N,T),M=nu({inputs:{x:r},backend:t,attrs:{begin:S,size:R}});_=Vn({inputs:{x:M},backend:t,attrs:{shape:b}}),t.disposeData(M.dataId)}else{let R=t.makeOutput(g,"float32"),M=t.dataIdMap.get(r.dataId).id,F=new Uint8Array(new Int32Array(C.computeStrides(r.shape)).buffer),B=new Uint8Array(new Int32Array(S).buffer),V=new Uint8Array(new Int32Array(N).buffer),P=new Uint8Array(new Int32Array(T).buffer),A=new Uint8Array(new Int32Array(g).buffer),G=new Uint8Array(new Int32Array(C.computeStrides(g)).buffer),J=t.dataIdMap.get(R.dataId).id;hL(M,F,r.shape.length,B,V,P,A,G,g.length,J),_=Vn({inputs:{x:R},backend:t,attrs:{shape:b}}),t.disposeData(R.dataId)}return _}var Mwe={kernelName:Gh,backendName:"wasm",setupFunc:Rwe,kernelFunc:Dwe};function Fwe(e){let{backend:t,inputs:a,attrs:n}=e,{data:r,dataSplits:s}=a,{separator:i,nGramWidths:o,leftPad:u,rightPad:d,padWidth:c,preserveShortSequences:f}=n,m=t.readSync(r.dataId),g=t.readSync(s.dataId),[b,v]=Q2(m,g,i,o,u,d,c,f),x=t.makeOutput([b.length],"string"),k=t.dataIdMap.get(x.dataId);k.stringBytes=b;let S=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(S).set(v),[x,S]}var Owe={kernelName:Tm,backendName:"wasm",kernelFunc:Fwe};function zwe(e){let{backend:t,inputs:a,attrs:n}=e,{input:r,delimiter:s}=a,{skipEmpty:i}=n,o=t.readSync(r.dataId),u=t.readSync(s.dataId),[d,c,f]=J2(o,u[0],i),m=c.length,g=t.makeOutput([m,2],"int32");t.typedArrayFromHeap(g).set(d);let b=t.makeOutput([m],"string"),v=t.dataIdMap.get(b.dataId);v.stringBytes=c;let x=t.makeOutput([2],"int32");return t.typedArrayFromHeap(x).set(f),[g,b,x]}var Lwe={kernelName:_m,backendName:"wasm",kernelFunc:zwe};function Bwe(e){let{backend:t,inputs:a,attrs:n}=e,{input:r}=a,{numBuckets:s}=n,i=t.readSync(r.dataId),o=eI(i,s),u=t.makeOutput(r.shape,"int32");return t.typedArrayFromHeap(u).set(o),u}var Uwe={kernelName:Cm,backendName:"wasm",kernelFunc:Bwe},Pwe=Ma(wc),pL;function Wwe(e){pL=e.wasm.cwrap(bc,null,["number","number","number","number"])}function Vwe(e){let{backend:t,inputs:a,attrs:n}=e,{axis:r,keepDims:s}=n,{x:i}=a,o=t.dataIdMap.get(i.dataId).id,u=o,d=i,{transposed:c,axes:f,originalAxes:m,inputWasTransposed:g}=jo(i,r,t),b=f;if(g){let N=t.dataIdMap.get(c.dataId).id;N!==o&&(d=c,u=N,b=D.getInnerMostAxes(b.length,d.shape.length))}D.assertAxesAreInnerMostDims("sum",b,d.shape.length);let[v,x]=D.computeOutAndReduceShapes(d.shape,b),k=C.sizeFromShape(x),S=t.makeOutput(v,d.dtype);if(C.sizeFromShape(d.shape)!==0){let N=t.dataIdMap.get(S.dataId).id;pL(u,k,Et[S.dtype],N)}if(g&&t.disposeData(c.dataId),s){let N=D.expandShapeToKeepDim(S.shape,m);S.shape=N}return S}var Gwe={kernelName:bc,backendName:"wasm",setupFunc:Wwe,kernelFunc:Vwe},Hwe=Nt(kc),qwe=Nt(Sc),fL;function jwe(e){fL=e.wasm.cwrap(Oh,null,["number","number","number","number","number","number","array","number","number","number"])}function Kwe(e){let{backend:t,inputs:a,attrs:n}=e,{tensor:r,indices:s,updates:i}=a,o=t.makeOutput(r.shape,r.dtype);if(C.sizeFromShape(r.shape)===0)return o;let{sliceRank:u,numUpdates:d,sliceSize:c,strides:f,outputSize:m}=dv.calculateShapes(i,s,r.shape),g=t.dataIdMap.get(s.dataId).id,b=t.dataIdMap.get(i.dataId).id,v=t.dataIdMap.get(r.dataId).id,x=new Uint8Array(new Int32Array(f).buffer),k=t.dataIdMap.get(o.dataId).id;return fL(g,b,Et[i.dtype],u,d,c,x,m,k,v),o}var Xwe={kernelName:Oh,backendName:"wasm",setupFunc:jwe,kernelFunc:Kwe},mL;function Ywe(e){mL=e.wasm.cwrap(Lo,null,["number","array","number","array","number","number"])}function Zwe(e){let{inputs:t,backend:a,attrs:n}=e,{x:r}=t,s=a.dataIdMap.get(r.dataId).id,{reps:i}=n,o=new Array(r.shape.length);for(let m=0;m<o.length;m++)o[m]=r.shape[m]*i[m];let u=new Uint8Array(new Int32Array(r.shape).buffer),d=new Uint8Array(new Int32Array(o).buffer),c=a.makeOutput(o,r.dtype),f=a.dataIdMap.get(c.dataId).id;return mL(s,u,r.shape.length,d,o.length,Et[c.dtype],f),c}var Qwe={kernelName:Lo,backendName:"wasm",setupFunc:Ywe,kernelFunc:Zwe},gL;function Jwe(e){gL=e.wasm.cwrap(Hh,null,["number","array","number","number","number","bool","number","number"])}var e1e=({inputs:e,backend:t,attrs:a})=>{let{x:n}=e,{k:r,sorted:s}=a,i=t.dataIdMap.get(n.dataId).id,o=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=r;let d=t.makeOutput(u,n.dtype),c=t.dataIdMap.get(d.dataId).id,f=t.makeOutput(u,"int32"),m=t.dataIdMap.get(f.dataId).id;return gL(i,o,n.shape.length,Et[n.dtype],r,s,c,m),[d,f]},t1e={kernelName:Hh,backendName:"wasm",setupFunc:Jwe,kernelFunc:e1e},yL;function a1e(e){yL=e.wasm.cwrap(qh,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function n1e(e){let{backend:t,inputs:a,attrs:n}=e,{image:r,transforms:s}=a,{interpolation:i,fillMode:o,fillValue:u,outputShape:d}=n,[c,f,m,g]=r.shape,[b,v]=d??[f,m],x=[c,b,v,g],k=new Uint8Array(new Int32Array(C.computeStrides(r.shape)).buffer),S=new Uint8Array(new Int32Array(C.computeStrides(x)).buffer),N=t.makeOutput(x,r.dtype),T=t.dataIdMap.get(N.dataId).id,_=t.dataIdMap.get(r.dataId).id,R=t.dataIdMap.get(s.dataId).id,M=i==="nearest"?1:2,F;switch(o){case"constant":F=1;break;case"reflect":F=2;break;case"wrap":F=3;break;case"nearest":F=4;break;default:F=1;break}return yL(_,R,s.shape[0]>1,c,b,v,g,m,f,k,r.shape.length-1,S,x.length-1,M,F,u,T),N}var r1e={kernelName:qh,backendName:"wasm",setupFunc:a1e,kernelFunc:n1e};function s1e(e){let{inputs:t,attrs:a,backend:n}=e,{axis:r}=a,{x:s}=t,{outputValues:i,outputShape:o,indices:u}=aI(n.readSync(s.dataId),r,s.shape,s.dtype);return[n.makeOutput(o,s.dtype,void 0,i),n.makeOutput([u.length],"int32",void 0,u)]}var i1e={kernelName:Em,backendName:"wasm",kernelFunc:s1e};function o1e(e){let{inputs:t,backend:a,attrs:n}=e,{value:r}=t,{axis:s}=n;s<0&&(s+=r.shape.length);let i=r.shape[s],o=r.shape.length,u=new Array(o-1),d=0;for(let g=0;g<o;g++)g!==s&&(u[d++]=r.shape[g]);let c=new Array(i),f=new Array(o).fill(0),m=r.shape.slice();m[s]=1;for(let g=0;g<c.length;g++)f[s]=g,c[g]=nu({inputs:{x:r},attrs:{begin:f,size:m},backend:a});return c.map(({dataId:g,dtype:b})=>({dataId:g,dtype:b,shape:u}))}var l1e={kernelName:jh,backendName:"wasm",kernelFunc:o1e};function u1e(e){let{inputs:{x:t},backend:a}=e,n=a.makeOutput(t.shape,t.dtype);return a.typedArrayFromHeap(n).fill(0),n}var c1e={kernelName:Kh,backendName:"wasm",kernelFunc:u1e},d1e=[aye,nye,rye,sye,iye,uye,yye,xye,wye,kye,Sye,Iye,Nye,Tye,_ye,Aye,Bye,Dye,Oye,Vye,Xye,Qye,Jye,tbe,abe,nbe,ibe,obe,cbe,pbe,gbe,vbe,kbe,Sbe,Ibe,_be,Abe,Dbe,Obe,Bbe,Wbe,Hbe,Kbe,Zbe,eve,tve,rve,ive,ove,lve,uve,cve,dve,fve,mve,gve,vve,kve,Nve,Cve,$ve,Dve,Fve,cye,Ove,zve,Lve,Pve,Vve,Hve,Kve,Yve,Xve,Qve,Jve,txe,nxe,ixe,uxe,hxe,pxe,gxe,vxe,kxe,Nxe,Cxe,$xe,Mxe,Fxe,Lxe,Vxe,Gxe,Hxe,qxe,Xxe,Qxe,t0e,n0e,i0e,l0e,c0e,qz,p0e,g0e,v0e,w0e,k0e,S0e,I0e,N0e,Uye,C0e,$0e,M0e,z0e,U0e,V0e,G0e,H0e,K0e,Z0e,ewe,twe,rwe,swe,iwe,owe,jye,Uxe,lwe,cwe,pwe,gwe,bwe,xwe,Swe,Nwe,Twe,_we,Cwe,$we,Mwe,Owe,Lwe,Uwe,Pwe,Gwe,Hwe,qwe,Xwe,Qwe,t1e,r1e,fye,i1e,l1e,c1e];for(let e of d1e)$m(e);var S1=ie();S1.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});S1.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(S1.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var aA=Fo(qU()),h1e=Fo(jU()),nA=Fo(KU()),rA=aA.default||aA,p1e=nA.default||nA,bL=class extends lm{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(vL),I1=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Sb(this,Pr())}write(e,t,a){let n={id:this.dataIdNextNumber++};return this.move(n,e,t,a,1),n}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=C.now();return e(),{kernelMs:C.now()-t}}move(e,t,a,n,r){let s=this.dataIdNextNumber++;if(n==="string"){let d=t;this.dataIdMap.set(e,{id:s,stringBytes:d,shape:a,dtype:n,memoryOffset:null,refCount:r});return}let i=C.sizeFromShape(a),o=i*C.bytesPerElement(n),u=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:s,memoryOffset:u,shape:a,dtype:n,refCount:r}),this.wasm.tfjs.registerTensor(s,i,u),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),u)}async read(e){return this.readSync(e)}readSync(e,t,a){let{memoryOffset:n,dtype:r,shape:s,stringBytes:i}=this.dataIdMap.get(e);if(r==="string")return(t==null||t===0)&&(a==null||a>=i.length)?i:i.slice(t,a);t=t||0,a=a||C.sizeFromShape(s);let o=C.bytesPerElement(r),u=this.wasm.HEAPU8.slice(n+t*o,n+a*o);return g1e(u.buffer,r)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let a=this.dataIdMap.get(e);if(a.refCount--,!t&&a.refCount>0)return!1;this.wasm._free(a.memoryOffset),this.wasm.tfjs.disposeData(a.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,a,n){let r;if(a==null)r=this.write(n??null,e,t);else{let s=this.dataIdNextNumber++;r={id:s},this.dataIdMap.set(r,{id:s,memoryOffset:a,shape:e,dtype:t,refCount:1});let i=C.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,a)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:a}){let n=this.wasm.HEAPU8.buffer,{memoryOffset:r}=this.dataIdMap.get(a),s=C.sizeFromShape(e);switch(t){case"float32":return new Float32Array(n,r,s);case"int32":return new Int32Array(n,r,s);case"bool":return new Uint8Array(n,r,s);default:throw new Error(`Unknown dtype ${t}`)}}};function f1e(e){return(t,a)=>(C.fetch(e,{credentials:"same-origin"}).then(n=>{n.ok||t.env.a(`failed to load wasm binary file at '${e}'`),n.arrayBuffer().then(r=>{WebAssembly.instantiate(r,t).then(s=>{a(s.instance,s.module)})})}),{})}function sA(e,t,a){if(vb!=null)return vb;let n="tfjs-backend-wasm.wasm";return e&&t?n="tfjs-backend-wasm-threaded-simd.wasm":e&&(n="tfjs-backend-wasm-simd.wasm"),Bf!=null&&Bf[n]!=null?Bf[n]:a+n}async function m1e(){let[e,t]=await Promise.all([ie().getAsync("WASM_HAS_SIMD_SUPPORT"),ie().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((a,n)=>{let r={};r.locateFile=(o,u)=>{if(o.endsWith(".worker.js")){let d=h1e.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([d],{type:"application/javascript"});return URL.createObjectURL(c)}return o.endsWith(".wasm")?sA(e,t,Of??u):u+o},SI&&(r.instantiateWasm=f1e(sA(e,t,Of??"")));let s=!1;r.onAbort=()=>{s||Uf||(Uf=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&vb==null?(r.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+rA.toString()],{type:"text/javascript"}),i=rA(r)):i=p1e(r),i.then(o=>{s=!0,Uf=!1;let u=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",u,["number"]),dispose:o.cwrap("dispose",u,[])},a({wasm:o})}).catch(n)})}function g1e(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var y1e=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],vb=null,Of=null,Bf={},Uf=!1,SI=!1;function b1e(e,t=!1){if(UA("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Uf)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");vb=e,SI=t}function v1e(e,t=!1){if(Uf)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")Of=e;else{Bf=e;let a=y1e.filter(n=>Bf[n]==null);if(a.length>0)throw new Error(`There were no entries found for the following binaries: ${a.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}SI=t}var vL=-1,I1=-1;function x1e(e){vL=e}function w1e(){if(I1===-1)throw new Error("WASM backend not initialized.");return I1}var k1e="4.22.0",S1e=2;Pb("wasm",async()=>{let{wasm:e}=await m1e();return new bL(e)},S1e);var iA="4.22.0",I1e="4.22.0",N1e="4.22.0",T1e="4.22.0",_1e="4.22.0",C1e={tfjs:iA,"tfjs-core":iA,"tfjs-converter":I1e,"tfjs-backend-cpu":N1e,"tfjs-backend-webgl":T1e,"tfjs-backend-wasm":_1e},xL={};$1(xL,{AnchorPosition:()=>FL,DrawBox:()=>LL,DrawBoxOptions:()=>zL,DrawFaceLandmarks:()=>tB,DrawFaceLandmarksOptions:()=>eB,DrawTextField:()=>AI,DrawTextFieldOptions:()=>EI,drawContour:()=>lo,drawDetections:()=>P1e,drawFaceExpressions:()=>tke,drawFaceLandmarks:()=>nke});function lo(e,t,a=!1){if(e.beginPath(),t.slice(1).forEach(({x:n,y:r},s)=>{let i=t[s];e.moveTo(i.x,i.y),e.lineTo(n,r)}),a){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}var E1e={};$1(E1e,{computeReshapedDimensions:()=>IL,getCenterPoint:()=>NI,isDimensions:()=>T1,isEven:()=>N1,isFloat:()=>SL,isTensor:()=>gp,isTensor1D:()=>A1e,isTensor2D:()=>kL,isTensor3D:()=>cg,isTensor4D:()=>vi,isValidNumber:()=>Ll,isValidProbablitiy:()=>$1e,range:()=>qd,round:()=>II});var zl=class wL{constructor(t,a){if(!Ll(t)||!Ll(a))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:a})}`);this._width=t,this._height=a}get width(){return this._width}get height(){return this._height}reverse(){return new wL(1/this.width,1/this.height)}};function gp(e,t){return e instanceof ht&&e.shape.length===t}function A1e(e){return gp(e,1)}function kL(e){return gp(e,2)}function cg(e){return gp(e,3)}function vi(e){return gp(e,4)}function SL(e){return e%1!==0}function N1(e){return e%2===0}function II(e,t=2){let a=10**t;return Math.floor(e*a)/a}function T1(e){return e&&e.width&&e.height}function IL({width:e,height:t},a){let n=a/Math.max(t,e);return new zl(Math.round(e*n),Math.round(t*n))}function NI(e){return e.reduce((t,a)=>t.add(a),new Wt(0,0)).div(new Wt(e.length,e.length))}function qd(e,t,a){return Array(e).fill(0).map((n,r)=>t+r*a)}function Ll(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function $1e(e){return Ll(e)&&e>=0&&e<=1}var Wt=class Tl{constructor(t,a){this._x=t,this._y=a}get x(){return this._x}get y(){return this._y}add(t){return new Tl(this.x+t.x,this.y+t.y)}sub(t){return new Tl(this.x-t.x,this.y-t.y)}mul(t){return new Tl(this.x*t.x,this.y*t.y)}div(t){return new Tl(this.x/t.x,this.y/t.y)}abs(){return new Tl(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Tl(Math.floor(this.x),Math.floor(this.y))}},ru=class is{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(Ll)}static assertIsValidBox(t,a,n=!1){if(!is.isRect(t))throw new Error(`${a} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!n&&(t.width<0||t.height<0))throw new Error(`${a} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,a=!0){let n=t||{},r=[n.left,n.top,n.right,n.bottom].every(Ll),s=[n.x,n.y,n.width,n.height].every(Ll);if(!s&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(n)}`);let[i,o,u,d]=s?[n.x,n.y,n.width,n.height]:[n.left,n.top,n.right-n.left,n.bottom-n.top];is.assertIsValidBox({x:i,y:o,width:u,height:d},"Box.constructor",a),this._x=i,this._y=o,this._width=u,this._height=d}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Wt(this.left,this.top)}get topRight(){return new Wt(this.right,this.top)}get bottomLeft(){return new Wt(this.left,this.bottom)}get bottomRight(){return new Wt(this.right,this.bottom)}round(){let[t,a,n,r]=[this.x,this.y,this.width,this.height].map(s=>Math.round(s));return new is({x:t,y:a,width:n,height:r})}floor(){let[t,a,n,r]=[this.x,this.y,this.width,this.height].map(s=>Math.floor(s));return new is({x:t,y:a,width:n,height:r})}toSquare(){let{x:t,y:a,width:n,height:r}=this,s=Math.abs(n-r);return n<r&&(t-=s/2,n+=s),r<n&&(a-=s/2,r+=s),new is({x:t,y:a,width:n,height:r})}rescale(t){let a=T1(t)?t.width:t,n=T1(t)?t.height:t;return new is({x:this.x*a,y:this.y*n,width:this.width*a,height:this.height*n})}pad(t,a){let[n,r,s,i]=[this.x-t/2,this.y-a/2,this.width+t,this.height+a];return new is({x:n,y:r,width:s,height:i})}clipAtImageBorders(t,a){let{x:n,y:r,right:s,bottom:i}=this,o=Math.max(n,0),u=Math.max(r,0),d=s-o,c=i-u,f=Math.min(d,t-o),m=Math.min(c,a-u);return new is({x:o,y:u,width:f,height:m}).floor()}shift(t,a){let{width:n,height:r}=this,s=this.x+t,i=this.y+a;return new is({x:s,y:i,width:n,height:r})}padAtBorders(t,a){let n=this.width+1,r=this.height+1,s=1,i=1,o=n,u=r,d=this.left,c=this.top,f=this.right,m=this.bottom;return f>a&&(o=-f+a+n,f=a),m>t&&(u=-m+t+r,m=t),d<1&&(u=2-d,d=1),c<1&&(u=2-c,c=1),{dy:i,edy:u,dx:s,edx:o,y:c,ey:m,x:d,ex:f,w:n,h:r}}calibrate(t){return new is({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},NL=class extends ru{constructor(e,t,a,n,r=!1){super({left:e,top:t,right:a,bottom:n},r)}},TL=class _L{constructor(t,a,n,r,s){this._imageDims=new zl(s.width,s.height),this._score=t,this._classScore=a,this._className=n,this._box=new ru(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new ru(this._box).rescale(this.imageDims.reverse())}forSize(t,a){return new _L(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:a})}},Hr=class CL extends TL{constructor(t,a,n){super(t,t,"",a,n)}forSize(t,a){let{score:n,relativeBox:r,imageDims:s}=super.forSize(t,a);return new CL(n,r,s)}};function R1e(e,t,a=!0){let n=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),r=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=n*r;return a?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function D1e(e){let t=e.map(o=>o.x),a=e.map(o=>o.y),n=t.reduce((o,u)=>u<o?u:o,1/0),r=a.reduce((o,u)=>u<o?u:o,1/0),s=t.reduce((o,u)=>o<u?u:o,0),i=a.reduce((o,u)=>o<u?u:o,0);return new NL(n,r,s,i)}function M1e(e,t,a,n=!0){let r=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),s=[];for(;r.length>0;){let i=r.pop();s.push(i);let o=r,u=[];for(let d=0;d<o.length;d++){let c=o[d],f=e[i],m=e[c];u.push(R1e(f,m,n))}r=r.filter((d,c)=>u[c]<=a)}return s}function dg(e,t){return ae(()=>{let[a,n,r]=t,s=ir([...e.shape.slice(0,3),1],a,"float32"),i=ir([...e.shape.slice(0,3),1],n,"float32"),o=ir([...e.shape.slice(0,3),1],r,"float32"),u=Gt([s,i,o],3);return $e(e,u)})}function F1e(e,t=!1){return ae(()=>{let[a,n]=e.shape.slice(1);if(a===n)return e;let r=Math.abs(a-n),s=Math.round(r*(t?.5:1)),i=a>n?2:1,o=f=>{let m=e.shape.slice();return m[i]=f,ir(m,0,"float32")},u=o(s),d=r-u.shape[i],c=[t&&d?o(d):null,e,u].filter(f=>!!f).map(f=>Te(f,"float32"));return Gt(c,i)})}function vw(e){return 1/(1+Math.exp(-e))}var EL=class extends ru{constructor(e,t,a,n,r=!1){super({x:e,y:t,width:a,height:n},r)}},O1e=.5,z1e=.43,L1e=.45,im=class{constructor(e,t,a=new Wt(0,0)){let{width:n,height:r}=t;this._imgDims=new zl(n,r),this._shift=a,this._positions=e.map(s=>s.mul(new Wt(n,r)).add(a))}get shift(){return new Wt(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new Wt(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Wt(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let r=e instanceof Hr?e.box.floor():new ru(e);return this.shiftBy(r.x,r.y).align(null,t)}let{useDlibAlignment:a,minBoxPadding:n}={useDlibAlignment:!1,minBoxPadding:.2,...t};return a?this.alignDlib():this.alignMinBbox(n)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,a,n]=e,r=c=>n.sub(c).magnitude(),s=(r(t)+r(a))/2,i=Math.floor(s/L1e),o=NI(e),u=Math.floor(Math.max(0,o.x-O1e*i)),d=Math.floor(Math.max(0,o.y-z1e*i));return new EL(u,d,Math.min(i,this.imageWidth+u),Math.min(i,this.imageHeight+d))}alignMinBbox(e){let t=D1e(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},AL=class extends im{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(NI)}};function om(e){return e.detection instanceof Hr}function _1(e,t){return{...e,detection:t}}function $L(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function TI(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function RL(e){let t="";if(!e&&TI())try{e=IU("fs")}catch(a){t=a.toString()}return{readFile:e?a=>new Promise((n,r)=>{e.readFile(a,(s,i)=>s?r(s):n(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function DL(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,a=global.Video||global.HTMLVideoElement,n=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},r=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},s=()=>{if(a)return new a;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=RL();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:n,createImageElement:r,createVideoElement:s,fetch:i,...o}}function ML(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var ja;function B1e(){if(!ja)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return ja}function C1(e){ja=e}function _I(){return ML()?C1($L()):TI()?C1(DL()):null}function U1e(e){if(ja||_I(),!ja)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=ja.Canvas,Image:a=ja.Image}=e;ja.Canvas=t,ja.Image=a,ja.createCanvasElement=e.createCanvasElement||(()=>new t),ja.createImageElement=e.createImageElement||(()=>new a),ja.ImageData=e.ImageData||ja.ImageData,ja.Video=e.Video||ja.Video,ja.fetch=e.fetch||ja.fetch,ja.readFile=e.readFile||ja.readFile}var jn={getEnv:B1e,setEnv:C1,initialize:_I,createBrowserEnv:$L,createFileSystem:RL,createNodejsEnv:DL,monkeyPatch:U1e,isBrowser:ML,isNodejs:TI};_I();function CI(e){return!jn.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Mo(e){let{Canvas:t,CanvasRenderingContext2D:a}=jn.getEnv();if(e instanceof a)return e;let n=CI(e);if(!(n instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let r=n.getContext("2d",{willReadFrequently:!0});if(!r)throw new Error("resolveContext2d - canvas 2d context is null");return r}var FL=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(FL||{}),EI=class{constructor(e={}){let{anchorPosition:t,backgroundColor:a,fontColor:n,fontSize:r,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=a||"rgba(0, 0, 0, 0.5)",this.fontColor=n||"rgba(255, 255, 255, 1)",this.fontSize=r||14,this.fontStyle=s||"Georgia",this.padding=i||4}},AI=class OL{constructor(t,a,n={}){this.text=typeof t=="string"?[t]:t instanceof OL?t.text:t,this.anchor=a,this.options=new EI(n)}measureWidth(t){let{padding:a}=this.options;return this.text.map(n=>t.measureText(n).width).reduce((n,r)=>n<r?r:n,0)+2*a}measureHeight(){let{fontSize:t,padding:a}=this.options;return this.text.length*t+2*a}getUpperLeft(t,a){let{anchorPosition:n}=this.options,r=n==="BOTTOM_RIGHT"||n==="TOP_RIGHT",s=n==="BOTTOM_LEFT"||n==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),u=r?this.anchor.x-i:this.anchor.x,d=s?this.anchor.y-o:this.anchor.y;if(a){let{width:c,height:f}=a,m=Math.max(Math.min(u,c-i),0),g=Math.max(Math.min(d,f-o),0);return{x:m,y:g}}return{x:u,y:d}}draw(t){let a=CI(t),n=Mo(a),{backgroundColor:r,fontColor:s,fontSize:i,fontStyle:o,padding:u}=this.options;n.font=`${i}px ${o}`;let d=this.measureWidth(n),c=this.measureHeight();n.fillStyle=r;let f=this.getUpperLeft(n,a);n.fillRect(f.x,f.y,d,c),n.fillStyle=s,this.text.forEach((m,g)=>{let b=u+f.x,v=u+f.y+(g+1)*i;n.fillText(m,b,v)})}},zL=class{constructor(e={}){let{boxColor:t,lineWidth:a,label:n,drawLabelOptions:r}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=a||2,this.label=n;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new EI({...s,...r})}},LL=class{constructor(e,t={}){this.box=new ru(e),this.options=new zL(t)}draw(e){let t=Mo(e),{boxColor:a,lineWidth:n}=this.options,{x:r,y:s,width:i,height:o}=this.box;t.strokeStyle=a,t.lineWidth=n,t.strokeRect(r,s,i,o);let{label:u}=this.options;u&&new AI([u],{x:r-n/2,y:s},this.options.drawLabelOptions).draw(e)}};function P1e(e,t){(Array.isArray(t)?t:[t]).forEach(a=>{let n=a instanceof Hr?a.score:om(a)?a.detection.score:void 0,r=a instanceof Hr?a.box:om(a)?a.detection.box:new ru(a),s=n?`${II(n)}`:void 0;new LL(r,{label:s}).draw(e)})}function BL(e){let{Image:t,Video:a}=jn.getEnv();return e instanceof t&&e.complete||e instanceof a&&e.readyState>=3}function W1e(e){return new Promise((t,a)=>{if(e instanceof jn.getEnv().Canvas||BL(e)){t(null);return}function n(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",n),a(s))}function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",n),t(s))}e.addEventListener("load",r),e.addEventListener("error",n)})}function UL(e){let{Image:t,Video:a}=jn.getEnv();return e instanceof t?new zl(e.naturalWidth,e.naturalHeight):e instanceof a?new zl(e.videoWidth,e.videoHeight):new zl(e.width,e.height)}function xb({width:e,height:t}){let{createCanvasElement:a}=jn.getEnv(),n=a();return n.width=e,n.height=t,n}function PL(e,t){let{ImageData:a}=jn.getEnv();if(!(e instanceof a)&&!BL(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:n,height:r}=UL(e),s=xb({width:n,height:r});return e instanceof a?Mo(s).putImageData(e,0,0):Mo(s).drawImage(e,0,0,n,r),s}async function V1e(e,t){let a=t||jn.getEnv().createCanvasElement(),[n,r,s]=e.shape.slice(vi(e)?1:0),i=ae(()=>e.as3D(n,r,s).toInt());return await Ym.toPixels(i,a),i.dispose(),a}function oA(e){let{Image:t,Canvas:a,Video:n}=jn.getEnv();return e instanceof t||e instanceof a||e instanceof n}function G1e(e,t,a=!1){let{Image:n,Canvas:r}=jn.getEnv();if(!(e instanceof n||e instanceof r))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return xb({width:1,height:1});let s=UL(e),i=t/Math.max(s.height,s.width),o=i*s.width,u=i*s.height,d=xb({width:t,height:t}),c=e instanceof r?e:PL(e),f=Math.abs(o-u)/2,m=a&&o<u?f:0,g=a&&u<o?f:0;return c.width>0&&c.height>0&&Mo(d).drawImage(c,m,g,o,u),d}var wb=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((a,n)=>{if(cg(a)){this._imageTensors[n]=a,this._inputDimensions[n]=a.shape;return}if(vi(a)){let s=a.shape[0];if(s!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${s} passed, but not supported in input array`);this._imageTensors[n]=a,this._inputDimensions[n]=a.shape.slice(1);return}let r=a instanceof jn.getEnv().Canvas?a:PL(a);this._canvases[n]=r,this._inputDimensions[n]=[r.height,r.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return qd(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),a=this.getInputHeight(e);return IL({width:t,height:a},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,ae(()=>{let a=qd(this.batchSize,0,1).map(n=>{let r=this.getInput(n);if(r instanceof ht){let s=vi(r)?r:Za(r);return s=F1e(s,t),(s.shape[1]!==e||s.shape[2]!==e)&&(s=xr.resizeBilinear(s,[e,e],!1,!1)),s.as3D(e,e,3)}if(r instanceof jn.getEnv().Canvas)return Ym.fromPixels(G1e(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)});return $a(a.map(n=>Te(n,"float32"))).as4D(this.batchSize,e,e,3)})}};async function An(e){if(e instanceof wb)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let a=r=>Array.isArray(e)?` at input index ${r}:`:"",n=t.map(CI);return n.forEach((r,s)=>{if(!oA(r)&&!cg(r)&&!vi(r))throw typeof t[s]=="string"?new Error(`toNetInput -${a(s)} string passed, but could not resolve HTMLElement for element id ${t[s]}`):new Error(`toNetInput -${a(s)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(vi(r)){let i=r.shape[0];if(i!==1)throw new Error(`toNetInput -${a(s)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(n.map(r=>oA(r)&&W1e(r))),new wb(n,Array.isArray(e))}async function WL(e,t){let{Canvas:a}=jn.getEnv(),n=e;if(!(e instanceof a)){let s=await An(e);if(s.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=s.getInput(0);n=i instanceof a?i:await V1e(i)}let r=Mo(n);return t.map(s=>s instanceof Hr?s.forSize(n.width,n.height).box.floor():s).map(s=>s.clipAtImageBorders(n.width,n.height)).map(({x:s,y:i,width:o,height:u})=>{let d=xb({width:o,height:u});return o>0&&u>0&&Mo(d).putImageData(r.getImageData(s,i,o,u),0,0),d})}async function VL(e,t){if(!cg(e)&&!vi(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(vi(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return ae(()=>{let[a,n,r]=e.shape.slice(vi(e)?1:0);return t.map(s=>s instanceof Hr?s.forSize(n,a).box:s).map(s=>s.clipAtImageBorders(n,a)).filter(s=>s.width>0&&s.height>0).map(({x:s,y:i,width:o,height:u})=>ap(e.as3D(a,n,r),[i,s,0],[u,o,r]))})}async function H1e(e,t){let{fetch:a}=jn.getEnv(),n=await a(e,t);if(!(n.status<400))throw new Error(`failed to fetch: (${n.status}) ${n.statusText}, from url: ${n.url}`);return n}async function q1e(e){return(await H1e(e)).json()}function GL(e,t){let a=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:a};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${a}`};let n=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(n,"");let r=e.split("/").filter(o=>o),s=e.endsWith(".json")?r[r.length-1]:a,i=n+(e.endsWith(".json")?r.slice(0,r.length-1):r).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${s}`:`${i}/${s}`}}async function j1e(e,t){let{manifestUri:a,modelBaseUri:n}=GL(e,t),r=await q1e(a);return dn.loadWeights(r,n)}var Xo=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:a}=this.traversePropertyPath(e);return t[a]}reassignParamFromPath(e,t){let{obj:a,objProp:n}=this.traversePropertyPath(e);a[n].dispose(),a[n]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Wl)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Wl))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let a=_n(t.dataSync());t.dispose(),this.reassignParamFromPath(e,a)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await j1e(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=jn.getEnv(),{manifestUri:a,modelBaseUri:n}=GL(e,this.getDefaultModelName()),r=u=>Promise.all(u.map(d=>t(d).then(c=>typeof c=="string"?Buffer.from(c):c.buffer))),s=dn.weightsLoaderFactory(r),i=JSON.parse((await t(a)).toString()),o=await s(i,n);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:a}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=a}extractWeights(e){let{paramMappings:t,params:a}=this.extractParams(e);this._paramMappings=t,this._params=a}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((r,s)=>{if(!r.nextObj.hasOwnProperty(s))throw new Error(`traversePropertyPath - object does not have property ${s}, for path ${e}`);return{obj:r.nextObj,objProp:s,nextObj:r.nextObj[s]}},{nextObj:this.params}),{obj:a,objProp:n}=t;if(!a||!n||!(a[n]instanceof ht))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:a,objProp:n}}};function Sr(e,t,a){return ae(()=>{let n=tp(e,t.depthwise_filter,t.pointwise_filter,a,"same");return n=ge(n,t.bias),n})}function xw(e,t,a=!1){return ae(()=>{let n=Ot(a?ge(Cn(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Sr(e,t.conv0,[2,2])),r=Sr(n,t.conv1,[1,1]),s=Ot(ge(n,r)),i=Sr(s,t.conv2,[1,1]);return Ot(ge(n,ge(r,i)))})}function My(e,t,a=!1,n=!0){return ae(()=>{let r=Ot(a?ge(Cn(e,t.conv0.filters,n?[2,2]:[1,1],"same"),t.conv0.bias):Sr(e,t.conv0,n?[2,2]:[1,1])),s=Sr(r,t.conv1,[1,1]),i=Ot(ge(r,s)),o=Sr(i,t.conv2,[1,1]),u=Ot(ge(r,ge(s,o))),d=Sr(u,t.conv3,[1,1]);return Ot(ge(r,ge(s,ge(o,d))))})}function Pf(e,t,a="same",n=!1){return ae(()=>{let r=ge(Cn(e,t.filters,[1,1],a),t.bias);return n?Ot(r):r})}function Yo(e,t){Object.keys(e).forEach(a=>{t.some(n=>n.originalPath===a)||e[a].dispose()})}function $I(e,t){return(a,n,r,s)=>{let i=_o(e(a*n*r*r),[r,r,a,n]),o=Mt(e(n));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function HL(e,t){return(a,n,r)=>{let s=Ls(e(a*n),[a,n]),i=Mt(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/bias`}),{weights:s,bias:i}}}var qL=class{constructor(e,t,a){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=a}};function RI(e,t){return(a,n,r)=>{let s=_o(e(9*a),[3,3,a,1]),i=_o(e(a*n),[1,1,a,n]),o=Mt(e(n));return t.push({paramPath:`${r}/depthwise_filter`},{paramPath:`${r}/pointwise_filter`},{paramPath:`${r}/bias`}),new qL(s,i,o)}}function DI(e){return t=>{let a=e(`${t}/depthwise_filter`,4),n=e(`${t}/pointwise_filter`,4),r=e(`${t}/bias`,1);return new qL(a,n,r)}}function Fc(e,t){return(a,n,r)=>{let s=e[a];if(!gp(s,n))throw new Error(`expected weightMap[${a}] to be a Tensor${n}D, instead have ${s}`);return t.push({originalPath:a,paramPath:r||a}),s}}function Zo(e){let t=e;function a(r){let s=t.slice(0,r);return t=t.slice(r),s}function n(){return t}return{extractWeights:a,getRemainingWeights:n}}function jL(e,t){let a=$I(e,t),n=RI(e,t);function r(i,o,u,d=!1){let c=d?a(i,o,3,`${u}/conv0`):n(i,o,`${u}/conv0`),f=n(o,o,`${u}/conv1`),m=n(o,o,`${u}/conv2`);return{conv0:c,conv1:f,conv2:m}}function s(i,o,u,d=!1){let{conv0:c,conv1:f,conv2:m}=r(i,o,u,d),g=n(o,o,`${u}/conv3`);return{conv0:c,conv1:f,conv2:m,conv3:g}}return{extractDenseBlock3Params:r,extractDenseBlock4Params:s}}function K1e(e){let t=[],{extractWeights:a,getRemainingWeights:n}=Zo(e),{extractDenseBlock4Params:r}=jL(a,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2"),u=r(128,256,"dense3");if(n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:u}}}function KL(e){return t=>{let a=e(`${t}/filters`,4),n=e(`${t}/bias`,1);return{filters:a,bias:n}}}function XL(e,t){let a=Fc(e,t),n=KL(a),r=DI(a);function s(o,u=!1){let d=u?n(`${o}/conv0`):r(`${o}/conv0`),c=r(`${o}/conv1`),f=r(`${o}/conv2`);return{conv0:d,conv1:c,conv2:f}}function i(o,u=!1){let d=u?n(`${o}/conv0`):r(`${o}/conv0`),c=r(`${o}/conv1`),f=r(`${o}/conv2`),m=r(`${o}/conv3`);return{conv0:d,conv1:c,conv2:f,conv3:m}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function X1e(e){let t=[],{extractDenseBlock4Params:a}=XL(e,t),n={dense0:a("dense0",!0),dense1:a("dense1"),dense2:a("dense2"),dense3:a("dense3")};return Yo(e,t),{params:n,paramMappings:t}}var YL=class extends Xo{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return ae(()=>{let a=Te(e.toBatchTensor(112,!0),"float32"),n=dg(a,[122.782,117.001,104.298]).div(255),r=My(n,t.dense0,!0);return r=My(r,t.dense1),r=My(r,t.dense2),r=My(r,t.dense3),r=Ni(r,[7,7],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await An(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return X1e(e)}extractParams(e){return K1e(e)}};function E1(e,t){return ae(()=>ge(lt(e,t.weights),t.bias))}function Y1e(e,t,a){let n=[],{extractWeights:r,getRemainingWeights:s}=Zo(e),i=HL(r,n)(t,a,"fc");if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:n,params:{fc:i}}}function Z1e(e){let t=[],a=Fc(e,t);function n(s){let i=a(`${s}/weights`,2),o=a(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:n("fc")};return Yo(e,t),{params:r,paramMappings:t}}function ZL(e){let t={},a={};return Object.keys(e).forEach(n=>{let r=n.startsWith("fc")?a:t;r[n]=e[n]}),{featureExtractorMap:t,classifierMap:a}}var QL=class extends Xo{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ae(()=>{let a=e instanceof wb?this.faceFeatureExtractor.forwardInput(e):e;return E1(a.as2D(a.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:a}=this.extractClassifierParams(e);this._params=t,this._paramMappings=a}extractClassifierParams(e){return Y1e(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:a}=ZL(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Z1e(a)}extractParams(e){let t=this.getClassifierChannelsIn(),a=this.getClassifierChannelsOut(),n=a*t+a,r=e.slice(0,e.length-n),s=e.slice(e.length-n);return this.faceFeatureExtractor.extractWeights(r),this.extractClassifierParams(s)}},lA=["neutral","happy","sad","angry","fearful","disgusted","surprised"],MI=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);lA.forEach((t,a)=>{this[t]=e[a]})}asSortedArray(){return lA.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},Q1e=class extends QL{constructor(e=new YL){super("FaceExpressionNet",e)}forwardInput(e){return ae(()=>Vo(this.runNet(e)))}async forward(e){return this.forwardInput(await An(e))}async predictExpressions(e){let t=await An(e),a=await this.forwardInput(t),n=await Promise.all(ya(a).map(async s=>{let i=s.dataSync();return s.dispose(),i}));a.dispose();let r=n.map(s=>new MI(s));return t.isBatchInput?r:r[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function J1e(e){return e.expressions instanceof MI}function eke(e,t){return{...e,expressions:t}}function tke(e,t,a=.1,n){(Array.isArray(t)?t:[t]).forEach(r=>{let s=r instanceof MI?r:J1e(r)?r.expressions:void 0;if(!s)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=s.asSortedArray().filter(u=>u.probability>a),o=om(r)?r.detection.box.bottomLeft:n||new Wt(0,0);new AI(i.map(u=>`${u.expression} (${II(u.probability)})`),o).draw(e)})}function FI(e){return om(e)&&e.landmarks instanceof im&&e.unshiftedLandmarks instanceof im&&e.alignedRect instanceof Hr}function ake(e){let t=u=>u*180/Math.PI,a=(u,d)=>Math.sqrt((u.x-d.x)**2+(u.y-d.y)**2),n={roll:void 0,pitch:void 0,yaw:void 0},r=(u,d,c)=>{let f=Math.floor(u.x-d.x),m=Math.floor(d.x-c.x);return f-m},s=(u,d)=>{let c=Math.hypot(d.x-u.x,d.y-u.y),f=d.y-u.y,m=Math.asin(f/c),g=t(m),b=Math.floor(90-g),v=d.x-u.x<0?-1:1;return b*v},i=(u,d,c)=>{let f=a(u,c),m=new Wt((u.x+c.x)/2,(u.y+c.y)/2),g=a(d,m),b=Math.atan(g/f),v=Math.floor(t(b)),x=m.y-d.y<0?-1:1;return v*x};if(!e||!e.positions||e.positions.length!==68)return n;let o=e.positions;return n.roll=s(o[27],o[66]),n.pitch=i(o[14],o[30],o[2]),n.yaw=r(o[14],o[33],o[2]),n}function JL(e,t){let{box:a}=e.detection,n=t.shiftBy(a.x,a.y),r=n.align(),{imageDims:s}=e.detection,i=new Hr(e.detection.score,r.rescale(s.reverse()),s),o=ake(t);return{...e,landmarks:n,unshiftedLandmarks:t,alignedRect:i,angle:o}}var eB=class{constructor(e={}){let{drawLines:t=!0,drawPoints:a=!0,lineWidth:n,lineColor:r,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=a,this.lineWidth=n||1,this.pointSize=s||2,this.lineColor=r||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},tB=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new eB(t)}draw(e){let t=Mo(e),{drawLines:a,drawPoints:n,lineWidth:r,lineColor:s,pointSize:i,pointColor:o}=this.options;if(a&&this.faceLandmarks instanceof AL&&(t.strokeStyle=s,t.lineWidth=r,lo(t,this.faceLandmarks.getJawOutline()),lo(t,this.faceLandmarks.getLeftEyeBrow()),lo(t,this.faceLandmarks.getRightEyeBrow()),lo(t,this.faceLandmarks.getNose()),lo(t,this.faceLandmarks.getLeftEye(),!0),lo(t,this.faceLandmarks.getRightEye(),!0),lo(t,this.faceLandmarks.getMouth(),!0)),n){t.strokeStyle=o,t.fillStyle=o;let u=d=>{t.beginPath(),t.arc(d.x,d.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(u)}}};function nke(e,t){(Array.isArray(t)?t:[t]).forEach(a=>{let n=a instanceof im?a:FI(a)?a.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new tB(n).draw(e)})}function rke(e,t){let a=$I(e,t),n=RI(e,t);function r(i,o,u){let d=n(i,o,`${u}/separable_conv0`),c=n(o,o,`${u}/separable_conv1`),f=a(i,o,1,`${u}/expansion_conv`);return{separable_conv0:d,separable_conv1:c,expansion_conv:f}}function s(i,o){let u=n(i,i,`${o}/separable_conv0`),d=n(i,i,`${o}/separable_conv1`),c=n(i,i,`${o}/separable_conv2`);return{separable_conv0:u,separable_conv1:d,separable_conv2:c}}return{extractConvParams:a,extractSeparableConvParams:n,extractReductionBlockParams:r,extractMainBlockParams:s}}function ske(e,t){let a=[],{extractWeights:n,getRemainingWeights:r}=Zo(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:u}=rke(n,a),d=s(3,32,3,"entry_flow/conv_in"),c=o(32,64,"entry_flow/reduction_block_0"),f=o(64,128,"entry_flow/reduction_block_1"),m={conv_in:d,reduction_block_0:c,reduction_block_1:f},g={};qd(t,0,1).forEach(k=>{g[`main_block_${k}`]=u(128,`middle_flow/main_block_${k}`)});let b=o(128,256,"exit_flow/reduction_block"),v=i(256,512,"exit_flow/separable_conv"),x={reduction_block:b,separable_conv:v};if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:a,params:{entry_flow:m,middle_flow:g,exit_flow:x}}}function ike(e,t){let a=Fc(e,t),n=KL(a),r=DI(a);function s(o){let u=r(`${o}/separable_conv0`),d=r(`${o}/separable_conv1`),c=n(`${o}/expansion_conv`);return{separable_conv0:u,separable_conv1:d,expansion_conv:c}}function i(o){let u=r(`${o}/separable_conv0`),d=r(`${o}/separable_conv1`),c=r(`${o}/separable_conv2`);return{separable_conv0:u,separable_conv1:d,separable_conv2:c}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}}function oke(e,t){let a=[],{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:i}=ike(e,a),o=n("entry_flow/conv_in"),u=s("entry_flow/reduction_block_0"),d=s("entry_flow/reduction_block_1"),c={conv_in:o,reduction_block_0:u,reduction_block_1:d},f={};qd(t,0,1).forEach(v=>{f[`main_block_${v}`]=i(`middle_flow/main_block_${v}`)});let m=s("exit_flow/reduction_block"),g=r("exit_flow/separable_conv"),b={reduction_block:m,separable_conv:g};return Yo(e,a),{params:{entry_flow:c,middle_flow:f,exit_flow:b},paramMappings:a}}function aB(e,t,a){return ge(Cn(e,t.filters,a,"same"),t.bias)}function ww(e,t,a=!0){let n=a?Ot(e):e;return n=Sr(n,t.separable_conv0,[1,1]),n=Sr(Ot(n),t.separable_conv1,[1,1]),n=Ka(n,[3,3],[2,2],"same"),n=ge(n,aB(e,t.expansion_conv,[2,2])),n}function lke(e,t){let a=Sr(Ot(e),t.separable_conv0,[1,1]);return a=Sr(Ot(a),t.separable_conv1,[1,1]),a=Sr(Ot(a),t.separable_conv2,[1,1]),a=ge(a,e),a}var uke=class extends Xo{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return ae(()=>{let a=Te(e.toBatchTensor(112,!0),"float32"),n=dg(a,[122.782,117.001,104.298]).div(255),r=Ot(aB(n,t.entry_flow.conv_in,[2,2]));return r=ww(r,t.entry_flow.reduction_block_0,!1),r=ww(r,t.entry_flow.reduction_block_1),qd(this._numMainBlocks,0,1).forEach(s=>{r=lke(r,t.middle_flow[`main_block_${s}`])}),r=ww(r,t.exit_flow.reduction_block),r=Ot(Sr(r,t.exit_flow.separable_conv,[1,1])),r})}async forward(e){return this.forwardInput(await An(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return oke(e,this._numMainBlocks)}extractParams(e){return ske(e,this._numMainBlocks)}};function cke(e){let t=[],{extractWeights:a,getRemainingWeights:n}=Zo(e),r=HL(a,t),s=r(512,1,"fc/age"),i=r(512,2,"fc/gender");if(n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function dke(e){let t=[],a=Fc(e,t);function n(s){let i=a(`${s}/weights`,2),o=a(`${s}/bias`,1);return{weights:i,bias:o}}let r={fc:{age:n("fc/age"),gender:n("fc/gender")}};return Yo(e,t),{params:r,paramMappings:t}}var hke=(e=>(e.FEMALE="female",e.MALE="male",e))(hke||{}),pke=class extends Xo{constructor(e=new uke(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ae(()=>{let a=e instanceof wb?this.faceFeatureExtractor.forwardInput(e):e,n=Ni(a,[7,7],[2,2],"valid").as2D(a.shape[0],-1),r=E1(n,t.fc.age).as1D(),s=E1(n,t.fc.gender);return{age:r,gender:s}})}forwardInput(e){return ae(()=>{let{age:t,gender:a}=this.runNet(e);return{age:t,gender:Vo(a)}})}async forward(e){return this.forwardInput(await An(e))}async predictAgeAndGender(e){let t=await An(e),a=await this.forwardInput(t),n=ya(a.age),r=ya(a.gender),s=n.map((o,u)=>({ageTensor:o,genderTensor:r[u]})),i=await Promise.all(s.map(async({ageTensor:o,genderTensor:u})=>{let d=o.dataSync()[0],c=u.dataSync()[0],f=c>.5,m=f?"male":"female",g=f?c:1-c;return o.dispose(),u.dispose(),{age:d,gender:m,genderProbability:g}}));return a.age.dispose(),a.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:a}=this.extractClassifierParams(e);this._params=t,this._paramMappings=a}extractClassifierParams(e){return cke(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:a}=ZL(e);return this.faceFeatureExtractor.loadFromWeightMap(t),dke(a)}extractParams(e){let t=e.slice(0,e.length-1539),a=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(a)}},nB=class extends QL{postProcess(e,t,a){let n=a.map(({width:s,height:i})=>{let o=t/Math.max(i,s);return{width:s*o,height:i*o}}),r=n.length;return ae(()=>{let s=(d,c)=>$a([ir([68],d,"float32"),ir([68],c,"float32")],1).as2D(1,136).as1D(),i=(d,c)=>{let{width:f,height:m}=n[d];return c(f,m)?Math.abs(f-m)/2:0},o=d=>i(d,(c,f)=>c<f),u=d=>i(d,(c,f)=>f<c);return e.mul(ir([r,136],t,"float32")).sub($a(Array.from(Array(r),(d,c)=>s(o(c),u(c))))).div($a(Array.from(Array(r),(d,c)=>s(n[c].width,n[c].height))))})}forwardInput(e){return ae(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([a,n])=>({height:a,width:n})))})}async forward(e){return this.forwardInput(await An(e))}async detectLandmarks(e){let t=await An(e),a=ae(()=>ya(this.forwardInput(t))),n=await Promise.all(a.map(async(r,s)=>{let i=Array.from(r.dataSync()),o=i.filter((d,c)=>N1(c)),u=i.filter((d,c)=>!N1(c));return new AL(Array(68).fill(0).map((d,c)=>new Wt(o[c],u[c])),{height:t.getInputHeight(s),width:t.getInputWidth(s)})}));return a.forEach(r=>r.dispose()),t.isBatchInput?n:n[0]}getClassifierChannelsOut(){return 136}},fke=class extends nB{constructor(e=new YL){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function mke(e){let t=[],{extractDenseBlock3Params:a}=XL(e,t),n={dense0:a("dense0",!0),dense1:a("dense1"),dense2:a("dense2")};return Yo(e,t),{params:n,paramMappings:t}}function gke(e){let t=[],{extractWeights:a,getRemainingWeights:n}=Zo(e),{extractDenseBlock3Params:r}=jL(a,t),s=r(3,32,"dense0",!0),i=r(32,64,"dense1"),o=r(64,128,"dense2");if(n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var yke=class extends Xo{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return ae(()=>{let a=Te(e.toBatchTensor(112,!0),"float32"),n=dg(a,[122.782,117.001,104.298]).div(255),r=xw(n,t.dense0,!0);return r=xw(r,t.dense1),r=xw(r,t.dense2),r=Ni(r,[14,14],[2,2],"valid"),r})}async forward(e){return this.forwardInput(await An(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return mke(e)}extractParams(e){return gke(e)}},bke=class extends nB{constructor(e=new yke){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function vke(e,t){return ge(Z(e,t.weights),t.biases)}function OI(e,t,a,n,r="same"){let{filters:s,bias:i}=t.conv,o=Cn(e,s,a,r);return o=ge(o,i),o=vke(o,t.scale),n?Ot(o):o}function xke(e,t){return OI(e,t,[1,1],!0)}function rB(e,t){return OI(e,t,[1,1],!1)}function sB(e,t){return OI(e,t,[2,2],!0,"valid")}function wke(e,t){function a(o,u,d){let c=e(o),f=c.length/(u*d*d);if(SL(f))throw new Error(`depth has to be an integer: ${f}, weights.length: ${c.length}, numFilters: ${u}, filterSize: ${d}`);return ae(()=>ut(_o(c,[u,f,d,d]),[2,3,1,0]))}function n(o,u,d,c){let f=a(o,u,d),m=Mt(e(u));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:f,bias:m}}function r(o,u){let d=Mt(e(o)),c=Mt(e(o));return t.push({paramPath:`${u}/weights`},{paramPath:`${u}/biases`}),{weights:d,biases:c}}function s(o,u,d,c){let f=n(o,u,d,`${c}/conv`),m=r(u,`${c}/scale`);return{conv:f,scale:m}}function i(o,u,d,c,f=!1){let m=s((f?.5:1)*o,u,d,`${c}/conv1`),g=s(o,u,d,`${c}/conv2`);return{conv1:m,conv2:g}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function kke(e){let{extractWeights:t,getRemainingWeights:a}=Zo(e),n=[],{extractConvLayerParams:r,extractResidualLayerParams:s}=wke(t,n),i=r(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),u=s(9216,32,3,"conv32_2"),d=s(9216,32,3,"conv32_3"),c=s(36864,64,3,"conv64_down",!0),f=s(36864,64,3,"conv64_1"),m=s(36864,64,3,"conv64_2"),g=s(36864,64,3,"conv64_3"),b=s(147456,128,3,"conv128_down",!0),v=s(147456,128,3,"conv128_1"),x=s(147456,128,3,"conv128_2"),k=s(589824,256,3,"conv256_down",!0),S=s(589824,256,3,"conv256_1"),N=s(589824,256,3,"conv256_2"),T=s(589824,256,3,"conv256_down_out"),_=ae(()=>ut(Ls(t(256*128),[128,256]),[1,0]));if(n.push({paramPath:"fc"}),a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:u,conv32_3:d,conv64_down:c,conv64_1:f,conv64_2:m,conv64_3:g,conv128_down:b,conv128_1:v,conv128_2:x,conv256_down:k,conv256_1:S,conv256_2:N,conv256_down_out:T,fc:_},paramMappings:n}}function Ske(e,t){let a=Fc(e,t);function n(i){let o=a(`${i}/scale/weights`,1),u=a(`${i}/scale/biases`,1);return{weights:o,biases:u}}function r(i){let o=a(`${i}/conv/filters`,4),u=a(`${i}/conv/bias`,1),d=n(i);return{conv:{filters:o,bias:u},scale:d}}function s(i){return{conv1:r(`${i}/conv1`),conv2:r(`${i}/conv2`)}}return{extractConvLayerParams:r,extractResidualLayerParams:s}}function Ike(e){let t=[],{extractConvLayerParams:a,extractResidualLayerParams:n}=Ske(e,t),r=a("conv32_down"),s=n("conv32_1"),i=n("conv32_2"),o=n("conv32_3"),u=n("conv64_down"),d=n("conv64_1"),c=n("conv64_2"),f=n("conv64_3"),m=n("conv128_down"),g=n("conv128_1"),b=n("conv128_2"),v=n("conv256_down"),x=n("conv256_1"),k=n("conv256_2"),S=n("conv256_down_out"),{fc:N}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!kL(N))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${N}`);let T={conv32_down:r,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:u,conv64_1:d,conv64_2:c,conv64_3:f,conv128_down:m,conv128_1:g,conv128_2:b,conv256_down:v,conv256_1:x,conv256_2:k,conv256_down_out:S,fc:N};return Yo(e,t),{params:T,paramMappings:t}}function Cs(e,t){let a=xke(e,t.conv1);return a=rB(a,t.conv2),a=ge(a,e),a=Ot(a),a}function Fy(e,t){let a=sB(e,t.conv1);a=rB(a,t.conv2);let n=Ni(e,2,2,"valid"),r=da(n.shape),s=n.shape[3]!==a.shape[3];if(n.shape[1]!==a.shape[1]||n.shape[2]!==a.shape[2]){let i=[...a.shape];i[1]=1;let o=da(i);a=Gt([a,o],1);let u=[...a.shape];u[2]=1;let d=da(u);a=Gt([a,d],2)}return n=s?Gt([n,r],3):n,a=ge(n,a),a=Ot(a),a}var Nke=class extends Xo{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return ae(()=>{let a=Te(e.toBatchTensor(150,!0),"float32"),n=dg(a,[122.782,117.001,104.298]).div(255),r=sB(n,t.conv32_down);r=Ka(r,3,2,"valid"),r=Cs(r,t.conv32_1),r=Cs(r,t.conv32_2),r=Cs(r,t.conv32_3),r=Fy(r,t.conv64_down),r=Cs(r,t.conv64_1),r=Cs(r,t.conv64_2),r=Cs(r,t.conv64_3),r=Fy(r,t.conv128_down),r=Cs(r,t.conv128_1),r=Cs(r,t.conv128_2),r=Fy(r,t.conv256_down),r=Cs(r,t.conv256_1),r=Cs(r,t.conv256_2),r=Fy(r,t.conv256_down_out);let s=r.mean([1,2]);return lt(s,t.fc)})}async forward(e){return this.forwardInput(await An(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(s=>s<=0))return new Float32Array(128);let a=await An(e),n=ae(()=>ya(this.forwardInput(a))),r=await Promise.all(n.map(s=>s.data()));return n.forEach(s=>s.dispose()),a.isBatchInput?r:r[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return Ike(e)}extractParams(e){return kke(e)}};function Tke(e,t){return{...e,descriptor:t}}function _ke(e,t){return{...e,age:t}}function Cke(e,t,a){return{...e,gender:t,genderProbability:a}}function Eke(e,t){function a(u,d){let c=_o(e(9*u),[3,3,u,1]),f=Mt(e(u)),m=Mt(e(u)),g=Mt(e(u)),b=Mt(e(u));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/batch_norm_scale`},{paramPath:`${d}/batch_norm_offset`},{paramPath:`${d}/batch_norm_mean`},{paramPath:`${d}/batch_norm_variance`}),{filters:c,batch_norm_scale:f,batch_norm_offset:m,batch_norm_mean:g,batch_norm_variance:b}}function n(u,d,c,f,m){let g=_o(e(u*d*c*c),[c,c,u,d]),b=Mt(e(d));return t.push({paramPath:`${f}/filters`},{paramPath:`${f}/${m?"batch_norm_offset":"bias"}`}),{filters:g,bias:b}}function r(u,d,c,f){let{filters:m,bias:g}=n(u,d,c,f,!0);return{filters:m,batch_norm_offset:g}}function s(u,d,c){let f=a(u,`${c}/depthwise_conv`),m=r(u,d,1,`${c}/pointwise_conv`);return{depthwise_conv:f,pointwise_conv:m}}function i(){let u=r(3,32,3,"mobilenetv1/conv_0"),d=s(32,64,"mobilenetv1/conv_1"),c=s(64,128,"mobilenetv1/conv_2"),f=s(128,128,"mobilenetv1/conv_3"),m=s(128,256,"mobilenetv1/conv_4"),g=s(256,256,"mobilenetv1/conv_5"),b=s(256,512,"mobilenetv1/conv_6"),v=s(512,512,"mobilenetv1/conv_7"),x=s(512,512,"mobilenetv1/conv_8"),k=s(512,512,"mobilenetv1/conv_9"),S=s(512,512,"mobilenetv1/conv_10"),N=s(512,512,"mobilenetv1/conv_11"),T=s(512,1024,"mobilenetv1/conv_12"),_=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:u,conv_1:d,conv_2:c,conv_3:f,conv_4:m,conv_5:g,conv_6:b,conv_7:v,conv_8:x,conv_9:k,conv_10:S,conv_11:N,conv_12:T,conv_13:_}}function o(){let u=r(1024,256,1,"prediction_layer/conv_0"),d=r(256,512,3,"prediction_layer/conv_1"),c=r(512,128,1,"prediction_layer/conv_2"),f=r(128,256,3,"prediction_layer/conv_3"),m=r(256,128,1,"prediction_layer/conv_4"),g=r(128,256,3,"prediction_layer/conv_5"),b=r(256,64,1,"prediction_layer/conv_6"),v=r(64,128,3,"prediction_layer/conv_7"),x=n(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),k=n(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),S=n(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),N=n(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),T=n(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),_=n(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),R=n(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),M=n(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),F=n(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),B=n(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),V=n(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),P=n(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:u,conv_1:d,conv_2:c,conv_3:f,conv_4:m,conv_5:g,conv_6:b,conv_7:v,box_predictor_0:{box_encoding_predictor:x,class_predictor:k},box_predictor_1:{box_encoding_predictor:S,class_predictor:N},box_predictor_2:{box_encoding_predictor:T,class_predictor:_},box_predictor_3:{box_encoding_predictor:R,class_predictor:M},box_predictor_4:{box_encoding_predictor:F,class_predictor:B},box_predictor_5:{box_encoding_predictor:V,class_predictor:P}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function Ake(e){let t=[],{extractWeights:a,getRemainingWeights:n}=Zo(e),{extractMobilenetV1Params:r,extractPredictionLayerParams:s}=Eke(a,t),i=r(),o=s(),u={extra_dim:cv(a(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:u},paramMappings:t}}function $ke(e,t){let a=Fc(e,t);function n(d,c,f){let m=a(`${d}/Conv2d_${c}_pointwise/weights`,4,`${f}/filters`),g=a(`${d}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${f}/batch_norm_offset`);return{filters:m,batch_norm_offset:g}}function r(d){let c=`mobilenetv1/conv_${d}`,f=`MobilenetV1/Conv2d_${d}_depthwise`,m=`${c}/depthwise_conv`,g=`${c}/pointwise_conv`,b=a(`${f}/depthwise_weights`,4,`${m}/filters`),v=a(`${f}/BatchNorm/gamma`,1,`${m}/batch_norm_scale`),x=a(`${f}/BatchNorm/beta`,1,`${m}/batch_norm_offset`),k=a(`${f}/BatchNorm/moving_mean`,1,`${m}/batch_norm_mean`),S=a(`${f}/BatchNorm/moving_variance`,1,`${m}/batch_norm_variance`);return{depthwise_conv:{filters:b,batch_norm_scale:v,batch_norm_offset:x,batch_norm_mean:k,batch_norm_variance:S},pointwise_conv:n("MobilenetV1",d,g)}}function s(){return{conv_0:n("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:r(1),conv_2:r(2),conv_3:r(3),conv_4:r(4),conv_5:r(5),conv_6:r(6),conv_7:r(7),conv_8:r(8),conv_9:r(9),conv_10:r(10),conv_11:r(11),conv_12:r(12),conv_13:r(13)}}function i(d,c){let f=a(`${d}/weights`,4,`${c}/filters`),m=a(`${d}/biases`,1,`${c}/bias`);return{filters:f,bias:m}}function o(d){let c=i(`Prediction/BoxPredictor_${d}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${d}/box_encoding_predictor`),f=i(`Prediction/BoxPredictor_${d}/ClassPredictor`,`prediction_layer/box_predictor_${d}/class_predictor`);return{box_encoding_predictor:c,class_predictor:f}}function u(){return{conv_0:n("Prediction",0,"prediction_layer/conv_0"),conv_1:n("Prediction",1,"prediction_layer/conv_1"),conv_2:n("Prediction",2,"prediction_layer/conv_2"),conv_3:n("Prediction",3,"prediction_layer/conv_3"),conv_4:n("Prediction",4,"prediction_layer/conv_4"),conv_5:n("Prediction",5,"prediction_layer/conv_5"),conv_6:n("Prediction",6,"prediction_layer/conv_6"),conv_7:n("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:u}}function Rke(e){let t=[],{extractMobilenetV1Params:a,extractPredictionLayerParams:n}=$ke(e,t),r=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!cg(r))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${r}`);let s={mobilenetv1:a(),prediction_layer:n(),output_layer:{extra_dim:r}};return Yo(e,t),{params:s,paramMappings:t}}function $s(e,t,a){return ae(()=>{let n=Cn(e,t.filters,a,"same");return n=ge(n,t.batch_norm_offset),yn(n,0,6)})}var Dke=.0010000000474974513;function Mke(e,t,a){return ae(()=>{let n=Nc(e,t.filters,a,"same");return n=Ic(n,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Dke),yn(n,0,6)})}function Fke(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function Oke(e,t){return ae(()=>{let a,n=$s(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((r,s)=>{let i=s+1,o=Fke(i);n=Mke(n,r.depthwise_conv,o),n=$s(n,r.pointwise_conv,[1,1]),i===11&&(a=n)}),a===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:n,conv11:a}})}function zke(e,t,a){let n=e.arraySync(),r=Math.min(n[t][0],n[t][2]),s=Math.min(n[t][1],n[t][3]),i=Math.max(n[t][0],n[t][2]),o=Math.max(n[t][1],n[t][3]),u=Math.min(n[a][0],n[a][2]),d=Math.min(n[a][1],n[a][3]),c=Math.max(n[a][0],n[a][2]),f=Math.max(n[a][1],n[a][3]),m=(i-r)*(o-s),g=(c-u)*(f-d);if(m<=0||g<=0)return 0;let b=Math.max(r,u),v=Math.max(s,d),x=Math.min(i,c),k=Math.min(o,f),S=Math.max(x-b,0)*Math.max(k-v,0);return S/(m+g-S)}function Lke(e,t,a,n,r){let s=e.shape[0],i=Math.min(a,s),o=t.map((c,f)=>({score:c,boxIndex:f})).filter(c=>c.score>r).sort((c,f)=>f.score-c.score),u=c=>c<=n?1:0,d=[];return o.forEach(c=>{if(d.length>=i)return;let f=c.score;for(let m=d.length-1;m>=0;--m){let g=zke(e,c.boxIndex,d[m]);if(g!==0&&(c.score*=u(g),c.score<=r))break}f===c.score&&d.push(c.boxIndex)}),d}function Bke(e){let t=ya(ut(e,[1,0])),a=[$e(t[2],t[0]),$e(t[3],t[1])],n=[ge(t[0],Fe(a[0],2)),ge(t[1],Fe(a[1],2))];return{sizes:a,centers:n}}function Uke(e,t){let{sizes:a,centers:n}=Bke(e),r=ya(ut(t,[1,0])),s=Fe(Z(bn(Fe(r[2],5)),a[0]),2),i=ge(Z(Fe(r[0],10),a[0]),n[0]),o=Fe(Z(bn(Fe(r[3],5)),a[1]),2),u=ge(Z(Fe(r[1],10),a[1]),n[1]);return ut($a([$e(i,s),$e(u,o),ge(i,s),ge(u,o)]),[1,0])}function Pke(e,t,a){return ae(()=>{let n=e.shape[0],r=Uke(te(sr(a.extra_dim,[n,1,1]),[-1,4]),te(e,[-1,4]));r=te(r,[n,r.shape[0]/n,4]);let s=Vr(bt(t,[0,0,1],[-1,-1,-1])),i=bt(s,[0,0,0],[-1,-1,1]);i=te(i,[n,i.shape[1]]);let o=ya(r),u=ya(i);return{boxes:o,scores:u}})}function xd(e,t){return ae(()=>{let a=e.shape[0],n=te(Pf(e,t.box_encoding_predictor),[a,-1,1,4]),r=te(Pf(e,t.class_predictor),[a,-1,3]);return{boxPredictionEncoding:n,classPrediction:r}})}function Wke(e,t,a){return ae(()=>{let n=$s(e,a.conv_0,[1,1]),r=$s(n,a.conv_1,[2,2]),s=$s(r,a.conv_2,[1,1]),i=$s(s,a.conv_3,[2,2]),o=$s(i,a.conv_4,[1,1]),u=$s(o,a.conv_5,[2,2]),d=$s(u,a.conv_6,[1,1]),c=$s(d,a.conv_7,[2,2]),f=xd(t,a.box_predictor_0),m=xd(e,a.box_predictor_1),g=xd(r,a.box_predictor_2),b=xd(i,a.box_predictor_3),v=xd(u,a.box_predictor_4),x=xd(c,a.box_predictor_5),k=Gt([f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding,b.boxPredictionEncoding,v.boxPredictionEncoding,x.boxPredictionEncoding],1),S=Gt([f.classPrediction,m.classPrediction,g.classPrediction,b.classPrediction,v.classPrediction,x.classPrediction],1);return{boxPredictions:k,classPredictions:S}})}var Yv=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},Vke=class extends Xo{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return ae(()=>{let a=Te(e.toBatchTensor(512,!1),"float32"),n=$e(Fe(a,127.5),1),r=Oke(n,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=Wke(r.out,r.conv11,t.prediction_layer);return Pke(s,i,t.output_layer)})}async forward(e){return this.forwardInput(await An(e))}async locateFaces(e,t={}){let{maxResults:a,minConfidence:n}=new Yv(t),r=await An(e),{boxes:s,scores:i}=this.forwardInput(r),o=s[0],u=i[0];for(let k=1;k<s.length;k++)s[k].dispose(),i[k].dispose();let d=Array.from(u.dataSync()),c=Lke(o,d,a,.5,n),f=r.getReshapedInputDimensions(0),m=r.inputSize,g=m/f.width,b=m/f.height,v=o.arraySync(),x=c.map(k=>{let[S,N]=[Math.max(0,v[k][0]),Math.min(1,v[k][2])].map(R=>R*b),[T,_]=[Math.max(0,v[k][1]),Math.min(1,v[k][3])].map(R=>R*g);return new Hr(d[k],new EL(T,S,_-T,N-S),{height:r.getInputHeight(0),width:r.getInputWidth(0)})});return o.dispose(),u.dispose(),x}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return Rke(e)}extractParams(e){return Ake(e)}},Gke=.4,Hke=[new Wt(.738768,.874946),new Wt(2.42204,2.65704),new Wt(4.30971,7.04493),new Wt(10.246,4.59428),new Wt(12.6868,11.8741)],qke=[new Wt(1.603231,2.094468),new Wt(6.041143,7.080126),new Wt(2.882459,3.518061),new Wt(4.266906,5.178857),new Wt(9.041765,10.66308)],jke=[117.001,114.697,97.404],Kke="tiny_yolov2_model",Xke="tiny_yolov2_separable_conv_model",Oy=e=>typeof e=="number";function Yke(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!Oy(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>Oy(t.x)&&Oy(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(Oy)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function zI(e){return ae(()=>{let t=Z(e,We(.10000000149011612));return ge(Ot($e(e,t)),t)})}function ro(e,t){return ae(()=>{let a=ms(e,[[0,0],[1,1],[1,1],[0,0]]);return a=Cn(a,t.conv.filters,[1,1],"valid"),a=$e(a,t.bn.sub),a=Z(a,t.bn.truediv),a=ge(a,t.conv.bias),zI(a)})}function so(e,t){return ae(()=>{let a=ms(e,[[0,0],[1,1],[1,1],[0,0]]);return a=tp(a,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),a=ge(a,t.bias),zI(a)})}function Zke(e,t){let a=$I(e,t);function n(i,o){let u=Mt(e(i)),d=Mt(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:u,truediv:d}}function r(i,o,u){let d=a(i,o,3,`${u}/conv`),c=n(o,`${u}/bn`);return{conv:d,bn:c}}let s=RI(e,t);return{extractConvParams:a,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}}function Qke(e,t,a,n){let{extractWeights:r,getRemainingWeights:s}=Zo(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:u,extractSeparableConvParams:d}=Zke(r,i),c;if(t.withSeparableConvs){let[f,m,g,b,v,x,k,S,N]=n,T=t.isFirstLayerConv2d?o(f,m,3,"conv0"):d(f,m,"conv0"),_=d(m,g,"conv1"),R=d(g,b,"conv2"),M=d(b,v,"conv3"),F=d(v,x,"conv4"),B=d(x,k,"conv5"),V=S?d(k,S,"conv6"):void 0,P=N?d(S,N,"conv7"):void 0,A=o(N||S||k,5*a,1,"conv8");c={conv0:T,conv1:_,conv2:R,conv3:M,conv4:F,conv5:B,conv6:V,conv7:P,conv8:A}}else{let[f,m,g,b,v,x,k,S,N]=n,T=u(f,m,"conv0"),_=u(m,g,"conv1"),R=u(g,b,"conv2"),M=u(b,v,"conv3"),F=u(v,x,"conv4"),B=u(x,k,"conv5"),V=u(k,S,"conv6"),P=u(S,N,"conv7"),A=o(N,5*a,1,"conv8");c={conv0:T,conv1:_,conv2:R,conv3:M,conv4:F,conv5:B,conv6:V,conv7:P,conv8:A}}if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{params:c,paramMappings:i}}function Jke(e,t){let a=Fc(e,t);function n(o){let u=a(`${o}/sub`,1),d=a(`${o}/truediv`,1);return{sub:u,truediv:d}}function r(o){let u=a(`${o}/filters`,4),d=a(`${o}/bias`,1);return{filters:u,bias:d}}function s(o){let u=r(`${o}/conv`),d=n(`${o}/bn`);return{conv:u,bn:d}}let i=DI(a);return{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function eSe(e,t){let a=[],{extractConvParams:n,extractConvWithBatchNormParams:r,extractSeparableConvParams:s}=Jke(e,a),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?n("conv0"):s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:o>7?s("conv6"):void 0,conv7:o>8?s("conv7"):void 0,conv8:n("conv8")}}else i={conv0:r("conv0"),conv1:r("conv1"),conv2:r("conv2"),conv3:r("conv3"),conv4:r("conv4"),conv5:r("conv5"),conv6:r("conv6"),conv7:r("conv7"),conv8:n("conv8")};return Yo(e,a),{params:i,paramMappings:a}}var LI=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},iB=class oB extends Xo{constructor(t){super("TinyYolov2"),Yke(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,a){let n=ro(t,a.conv0);return n=Ka(n,[2,2],[2,2],"same"),n=ro(n,a.conv1),n=Ka(n,[2,2],[2,2],"same"),n=ro(n,a.conv2),n=Ka(n,[2,2],[2,2],"same"),n=ro(n,a.conv3),n=Ka(n,[2,2],[2,2],"same"),n=ro(n,a.conv4),n=Ka(n,[2,2],[2,2],"same"),n=ro(n,a.conv5),n=Ka(n,[2,2],[1,1],"same"),n=ro(n,a.conv6),n=ro(n,a.conv7),Pf(n,a.conv8,"valid",!1)}runMobilenet(t,a){let n=this.config.isFirstLayerConv2d?zI(Pf(t,a.conv0,"valid",!1)):so(t,a.conv0);return n=Ka(n,[2,2],[2,2],"same"),n=so(n,a.conv1),n=Ka(n,[2,2],[2,2],"same"),n=so(n,a.conv2),n=Ka(n,[2,2],[2,2],"same"),n=so(n,a.conv3),n=Ka(n,[2,2],[2,2],"same"),n=so(n,a.conv4),n=Ka(n,[2,2],[2,2],"same"),n=so(n,a.conv5),n=Ka(n,[2,2],[1,1],"same"),n=a.conv6?so(n,a.conv6):n,n=a.conv7?so(n,a.conv7):n,Pf(n,a.conv8,"valid",!1)}forwardInput(t,a){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return ae(()=>{let r=Te(t.toBatchTensor(a,!1),"float32");return r=this.config.meanRgb?dg(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)})}async forward(t,a){return this.forwardInput(await An(t),a)}async detect(t,a={}){let{inputSize:n,scoreThreshold:r}=new LI(a),s=await An(t),i=await this.forwardInput(s,n),o=ae(()=>ya(i)[0].expandDims()),u={width:s.getInputWidth(0),height:s.getInputHeight(0)},d=await this.extractBoxes(o,s.getReshapedInputDimensions(0),r);i.dispose(),o.dispose();let c=d.map(b=>b.box),f=d.map(b=>b.score),m=d.map(b=>b.classScore),g=d.map(b=>this.config.classes[b.label]);return M1e(c.map(b=>b.rescale(n)),f,this.config.iouThreshold,!0).map(b=>new TL(f[b],m[b],g[b],c[b],u))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return eSe(t,this.config)}extractParams(t){let a=this.config.filterSizes||oB.DEFAULT_FILTER_SIZES,n=a?a.length:void 0;if(n!==7&&n!==8&&n!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${n} filterSizes in config`);return Qke(t,this.config,this.boxEncodingSize,a)}async extractBoxes(t,a,n){let{width:r,height:s}=a,i=Math.max(r,s),o=i/r,u=i/s,d=t.shape[1],c=this.config.anchors.length,[f,m,g]=ae(()=>{let k=t.reshape([d,d,c,this.boxEncodingSize]),S=k.slice([0,0,0,0],[d,d,c,4]),N=k.slice([0,0,0,4],[d,d,c,1]),T=this.withClassScores?Vo(k.slice([0,0,0,5],[d,d,c,this.config.classes.length]),3):We(0);return[S,N,T]}),b=[],v=await m.array(),x=await f.array();for(let k=0;k<d;k++)for(let S=0;S<d;S++)for(let N=0;N<c;N++){let T=vw(v[k][S][N][0]);if(!n||T>n){let _=(S+vw(x[k][S][N][0]))/d*o,R=(k+vw(x[k][S][N][1]))/d*u,M=Math.exp(x[k][S][N][2])*this.config.anchors[N].x/d*o,F=Math.exp(x[k][S][N][3])*this.config.anchors[N].y/d*u,B=_-M/2,V=R-F/2,P={row:k,col:S,anchor:N},{classScore:A,label:G}=this.withClassScores?await this.extractPredictedClass(g,P):{classScore:1,label:0};b.push({box:new NL(B,V,B+M,V+F),score:T,classScore:T*A,label:G,...P})}}return f.dispose(),m.dispose(),g.dispose(),b}async extractPredictedClass(t,a){let{row:n,col:r,anchor:s}=a,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,u)=>i[n][r][s][u]).map((o,u)=>({classScore:o,label:u})).reduce((o,u)=>o.classScore>u.classScore?o:u)}};iB.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var lB=iB,tSe=class extends lB{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:Gke,classes:["face"],...e?{anchors:qke,meanRgb:jke}:{anchors:Hke,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(a=>new Hr(a.score,a.relativeBox,{width:a.imageWidth,height:a.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?Xke:Kke}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},uB=class extends LI{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},hg=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function BI(e,t,a,n,r=({alignedRect:s})=>s){let s=e.map(u=>FI(u)?r(u):u.detection),i=n||(t instanceof ht?await VL(t,s):await WL(t,s)),o=await a(i);return i.forEach(u=>u instanceof ht&&u.dispose()),o}var aSe=.4,nSe=[new Wt(1.603231,2.094468),new Wt(6.041143,7.080126),new Wt(2.882459,3.518061),new Wt(4.266906,5.178857),new Wt(9.041765,10.66308)],rSe=[117.001,114.697,97.404],sSe=class extends lB{constructor(){let e={withSeparableConvs:!0,iouThreshold:aSe,classes:["face"],anchors:nSe,meanRgb:rSe,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(a=>new Hr(a.score,a.relativeBox,{width:a.imageWidth,height:a.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},xi={ssdMobilenetv1:new Vke,tinyFaceDetector:new sSe,tinyYolov2:new tSe,faceLandmark68Net:new fke,faceLandmark68TinyNet:new bke,faceRecognitionNet:new Nke,faceExpressionNet:new Q1e,ageGenderNet:new pke},iSe=class extends hg{constructor(e,t,a){super(),this.parentTask=e,this.input=t,this.extractedFaces=a}},UI=class extends iSe{async run(){let e=await this.parentTask,t=await BI(e,this.input,async a=>Promise.all(a.map(n=>xi.faceExpressionNet.predictExpressions(n))),this.extractedFaces);return e.map((a,n)=>eke(a,t[n]))}withAgeAndGender(){return new WI(this,this.input)}},PI=class extends UI{withAgeAndGender(){return new VI(this,this.input)}withFaceDescriptors(){return new GI(this,this.input)}},oSe=class extends hg{constructor(e,t,a){super(),this.parentTask=e,this.input=t,this.extractedFaces=a}},WI=class extends oSe{async run(){let e=await this.parentTask,t=await BI(e,this.input,async a=>Promise.all(a.map(n=>xi.ageGenderNet.predictAgeAndGender(n))),this.extractedFaces);return e.map((a,n)=>{let{age:r,gender:s,genderProbability:i}=t[n];return _ke(Cke(a,s,i),r)})}withFaceExpressions(){return new UI(this,this.input)}},VI=class extends WI{withFaceExpressions(){return new PI(this,this.input)}withFaceDescriptors(){return new GI(this,this.input)}},lSe=class extends hg{constructor(e,t){super(),this.parentTask=e,this.input=t}},GI=class extends lSe{async run(){let e=await this.parentTask;return(await BI(e,this.input,t=>Promise.all(t.map(a=>xi.faceRecognitionNet.computeFaceDescriptor(a))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,a)=>Tke(e[a],t))}withFaceExpressions(){return new PI(this,this.input)}withAgeAndGender(){return new VI(this,this.input)}},uSe=class extends hg{constructor(e,t,a){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=a}get landmarkNet(){return this.useTinyLandmarkNet?xi.faceLandmark68TinyNet:xi.faceLandmark68Net}},cSe=class extends uSe{async run(){let e=await this.parentTask,t=e.map(r=>r.detection),a=this.input instanceof ht?await VL(this.input,t):await WL(this.input,t),n=await Promise.all(a.map(r=>this.landmarkNet.detectLandmarks(r)));return a.forEach(r=>r instanceof ht&&r.dispose()),e.filter((r,s)=>n[s]).map((r,s)=>JL(r,n[s]))}withFaceExpressions(){return new PI(this,this.input)}withAgeAndGender(){return new VI(this,this.input)}withFaceDescriptors(){return new GI(this,this.input)}},dSe=class extends hg{constructor(e,t=new Yv){super(),this.input=e,this.options=t}},hSe=class extends dSe{async run(){let{input:e,options:t}=this,a;if(t instanceof uB)a=xi.tinyFaceDetector.locateFaces(e,t);else if(t instanceof Yv)a=xi.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof LI)a=xi.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return a}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(a=>e(a.map(n=>_1({},n)))).catch(a=>t(a))})}withFaceLandmarks(e=!1){return new cSe(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new UI(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new WI(this.runAndExtendWithFaceDetections(),this.input)}};function pSe(e,t=new Yv){return new hSe(e,t)}function cB(e,t){let{width:a,height:n}=new zl(t.width,t.height);if(a<=0||n<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:a,height:n})}`);if(Array.isArray(e))return e.map(r=>cB(r,{width:a,height:n}));if(FI(e)){let r=e.detection.forSize(a,n),s=e.unshiftedLandmarks.forSize(r.box.width,r.box.height);return JL(_1(e,r),s)}return om(e)?_1(e,e.detection.forSize(a,n)):e instanceof im||e instanceof Hr?e.forSize(a,n):e}/**
 * @license lucide-react v0.507.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fSe=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),mSe=e=>e.replace(/^([A-Z])|[\s-_]+(\w)/g,(t,a,n)=>n?n.toUpperCase():a.toLowerCase()),uA=e=>{const t=mSe(e);return t.charAt(0).toUpperCase()+t.slice(1)},dB=(...e)=>e.filter((t,a,n)=>!!t&&t.trim()!==""&&n.indexOf(t)===a).join(" ").trim(),gSe=e=>{for(const t in e)if(t.startsWith("aria-")||t==="role"||t==="title")return!0};/**
 * @license lucide-react v0.507.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var ySe={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.507.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const bSe=ga.forwardRef(({color:e="currentColor",size:t=24,strokeWidth:a=2,absoluteStrokeWidth:n,className:r="",children:s,iconNode:i,...o},u)=>ga.createElement("svg",{ref:u,...ySe,width:t,height:t,stroke:e,strokeWidth:n?Number(a)*24/Number(t):a,className:dB("lucide",r),...!s&&!gSe(o)&&{"aria-hidden":"true"},...o},[...i.map(([d,c])=>ga.createElement(d,c)),...Array.isArray(s)?s:[s]]));/**
 * @license lucide-react v0.507.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hB=(e,t)=>{const a=ga.forwardRef(({className:n,...r},s)=>ga.createElement(bSe,{ref:s,iconNode:t,className:dB(`lucide-${fSe(uA(e))}`,`lucide-${e}`,n),...r}));return a.displayName=uA(e),a};/**
 * @license lucide-react v0.507.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vSe=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["line",{x1:"12",x2:"12",y1:"8",y2:"12",key:"1pkeuh"}],["line",{x1:"12",x2:"12.01",y1:"16",y2:"16",key:"4dfq90"}]],xSe=hB("circle-alert",vSe);/**
 * @license lucide-react v0.507.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wSe=[["path",{d:"M21 12a9 9 0 1 1-6.219-8.56",key:"13zald"}]],kSe=hB("loader-circle",wSe);function SSe(){const e=ga.useRef(null),t=ga.useRef(null),a=ga.useRef(null),[n,r]=ga.useState(!0),[s,i]=ga.useState(null),[o,u]=ga.useState([]),[d,c]=ga.useState(!1),[f,m]=ga.useState(!1),[g,b]=ga.useState({width:0,height:0}),[v,x]=ga.useState(null);ga.useEffect(()=>{(async()=>{try{await xi.tinyFaceDetector.loadFromUri("/ai-image-recognition-app-react/models")}catch(B){console.error(" Error loading Face-api.js models",B)}})()},[]),ga.useEffect(()=>{(()=>{if(!a.current||o.length===0)return;const B=a.current,V=B.getContext("2d");V&&(B.width=g.width,B.height=g.height,V.clearRect(0,0,B.width,B.height),xL.drawDetections(B,o))})()},[o,g]);const k=ga.useCallback((F={})=>{var V;u([]),c(!1),b({width:0,height:0});const B=(V=a.current)==null?void 0:V.getContext("2d");B==null||B.clearRect(0,0,B.canvas.width,B.canvas.height),F.resetToDefault?(r(!0),i(null)):(r(!1),F.keepPreview||i(null))},[]),S=ga.useCallback(async F=>{var A;x(null),m(!0);const B=(A=F.target.files)==null?void 0:A[0];if(!B)return;m(!0);const V=R(B);if(V){x(V),m(!1);return}k({keepPreview:!0});const P=new FileReader;P.onload=()=>i(P.result),P.readAsDataURL(B)},[k]),N=ga.useCallback(async()=>{if(!t.current)return;m(!0);const F=t.current,B=F.clientWidth,V=F.clientHeight;b({width:B,height:V});try{const P=await pSe(F,new uB),A=cB(P,{width:B,height:V});u(A),c(!0)}catch(P){console.error("Face detection failed:",P)}finally{c(!0),m(!1)}},[]),T=ga.useCallback(()=>{k({resetToDefault:!0})},[k]),_=ga.useCallback(()=>{var F;(F=e.current)==null||F.click()},[]),R=F=>{if(!["image/jpeg","image/png"].includes(F.type))return"Please upload a JPEG or PNG image.";const V=5*1024*1024;return F.size>V?"Image too large, please keep it under 5MB.":null},M=()=>it.jsx(it.Fragment,{children:it.jsxs("div",{className:"flex flex-col items-center space-y-2",children:[it.jsx(kSe,{id:"loader",className:"animate-spin h-8 w-8 text-gray-600"}),it.jsx("p",{className:"text-sm text-gray-700"})]})});return it.jsx("div",{className:"w-full max-w-[1000px] mx-auto bg-white rounded-2xl mt-20 animate-fade-in-up",children:it.jsxs("div",{className:"flex flex-col md:flex-row gap-3",children:[it.jsx("div",{className:"p-5 flex-1 min-h-[175px]",children:it.jsxs("div",{className:"intro-container flex flex-col items-center justify-center px-4 p-4 align-baseline inline-block",children:[it.jsx("h1",{className:"intro-title text-3xl text-center mb-6",children:"Welcome to My Face Detection App!"}),it.jsxs("div",{className:"max-w-prose space-y-4",children:[it.jsxs("div",{className:"max-w-prose space-y-4 text-left",children:[it.jsx("p",{className:"intro-text",children:"This is an AI-powered face-detection app built with React & Face-api.js. Upload an image, and the app will detect faces instantly!"}),it.jsx("p",{className:"text-sm text-gray-500 italic",children:" All facedetection happens locally in your browser. No images or data are uploaded or stored anywhere."}),it.jsx("p",{className:"intro-text",children:"Im Miriam Arajoa frontend developer with over 7 years of experience in web development. Lately Ive been focusing on React, building this project to sharpen my skills."}),it.jsxs("p",{className:"intro-text",children:[" ",it.jsx("strong",{children:"Project goal:"})," Gain hands-on experience with Reacts modern ecosystem (functional components, state management, side effects) by tackling a practical face-detection challenge."]}),it.jsxs("p",{className:"intro-text",children:[" Feel free to reach out on",it.jsx("a",{href:"https://www.linkedin.com/in/miriam-araujo-dev/",target:"_blank",rel:"noopener noreferrer",className:"text-blue-600 hover:underline",children:"LinkedIn"})]})]}),it.jsx("input",{type:"file",ref:e,onChange:S,style:{display:"none"},accept:"image/*","data-testid":"file-input"}),it.jsxs("div",{className:"flex justify-center gap-4 mt-6",children:[it.jsx(wC,{onClick:_,btnClasses:"uploadBtn transition-transform transform hover:scale-105 active:scale-95",text:"Upload Image"}),it.jsx(wC,{onClick:T,btnClasses:"clearBtn transition-transform transform hover:scale-105 active:scale-95",text:"Clear image"})]}),v&&it.jsxs("div",{className:"mt-2 flex items-center bg-red-50 border-l-4 border-red-500 text-red-700 p-2 rounded",children:[it.jsx(xSe,{className:"w-5 h-5 mr-2 flex-shrink-0"}),it.jsx("span",{className:"text-sm",children:v})]})]})]})}),it.jsx("div",{className:"p-5 flex-1 flex",children:it.jsxs("div",{className:"image-preview-container flex flex-col items-center justify-center flex-1 px-4 p-4",children:[it.jsx("div",{className:"status-container",children:it.jsxs("div",{className:"status-container",children:[f&&it.jsx(M,{}),!n&&!f&&d&&it.jsx("p",{className:`face-count transition-all duration-500 ease-in-out ${d} ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-2'}`,children:o.length>0?it.jsxs("span",{className:"text-green-500",children:[" Detected Faces: ",o.length]}):it.jsx("span",{className:"text-red-500",children:" No Faces Detected"})})]})}),it.jsxs("div",{className:"canvas-wrapper",children:[n?it.jsx("img",{src:"./assets/defaultImg.jpg",alt:"Default placeholder",className:"image-preview rounded-2xl max-h-80 transition-opacity duration-500 opacity-0",onLoad:F=>F.currentTarget.classList.add("opacity-100")}):s&&it.jsx("div",{className:"mt-4",children:it.jsx("img",{src:s,ref:t,alt:"Uploaded preview",className:`image-preview rounded-2xl max-h-80 transition-opacity duration-700 ${d?"opacity-100":"opacity-0"}`,onLoad:N})}),it.jsx("canvas",{ref:a,className:`canvas-overlay transition-opacity duration-700 ${d?"opacity-100":"opacity-0"}`})]})]})})]})})}function ISe(){return it.jsx(it.Fragment,{children:it.jsx(SSe,{})})}kU.createRoot(document.getElementById("root")).render(it.jsx(ga.StrictMode,{children:it.jsx(ISe,{})}));
